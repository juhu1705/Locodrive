use crate::jni_c_header::*;
use std::fmt::{Debug, Formatter, Display};
use std::time::Duration;
use std::sync::{Arc, Mutex, Condvar};

use std::thread;
use std::thread::JoinHandle;

use std::mem;

use std::io::prelude::*;
use std::io;
use std::io::Write as IoWrite;
use std::fmt::Write as FmtWrite;
use std::result::Result;
use std::env;

use std::error::Error;

use serialport::{DataBits, FlowControl, Parity, StopBits, SerialPort};

#[derive(Debug)]
pub enum MessageParseError {
    UnknownOpcode(u8),
    UnexpectedEnd,
    InvalidChecksum,
    IoError(io::Error),
    Update(io::Error)
}

impl Display for MessageParseError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnknownOpcode(opc) => write!(f, "unknown opcode: {:x}", opc),
            Self::UnexpectedEnd => write!(f, "unexpected end of stream"),
            Self::InvalidChecksum => write!(f, "invalid checksum"),
            Self::IoError(err) => write!(f, "io error: {}", err),
            Self::Update(err) => write!(f, "io error: {}", err),
        }
    }
}

impl Error for MessageParseError {}

impl MessageParseError {
    fn msg(&self) -> String {
        let mut f = String::new();
        match self {
            Self::UnknownOpcode(opc) => write!(&mut f, "unknown opcode: {:x}", opc).unwrap_or(()),
            Self::UnexpectedEnd => write!(&mut f, "unexpected end of stream").unwrap_or(()),
            Self::InvalidChecksum => write!(&mut f, "invalid checksum").unwrap_or(()),
            Self::IoError(err) => write!(&mut f, "io error: {}", err).unwrap_or(()),
            Self::Update(err) => write!(&mut f, "io error: {}", err).unwrap_or(()),
        };
        f
    }

    fn error_type(&self) -> u8 {
        return match self {
            Self::UnknownOpcode(_opc) => 0,
            Self::UnexpectedEnd => 1,
            Self::InvalidChecksum => 2,
            Self::IoError(_err) => 3,
            Self::Update(_err) => 4,
        }
    }

    fn get_unknown_opc(&self) -> u8 {
        match self {
            Self::UnknownOpcode(opc) => *opc,
            _ => { panic!("No unexpected opc!") },
        }
    }
}

foreign_class!(
    /// A class representing a rust error, when sending to or reading from the loco net fails
    class MessageParseError {
        self_type MessageParseError;
        private constructor = empty;
        /// @return The message of this error
        fn MessageParseError::msg(&self) -> String; alias toString;
        /// @return The error type of this error. (1 - unknown op code, 2 - unexpected end, 3 - invalid checksum, 4 - io error, 5 - update (only for rust intern use should not be thrown))
        fn MessageParseError::error_type(&self) -> u8; alias getErrorType;
        /// @return The unknown op code only for unknown op code errors. Please do not invoke this method for other errors.
        fn MessageParseError::get_unknown_opc(&self) -> u8; alias getUnknownOpc;
        foreign_code r#"
    /**
     * Checks whether this error is equal to another object.
     * @param o The object to compare to
     * @return If this error is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.toString().equals(((MessageParseError) o).toString());
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
    }
);

#[derive(Debug, Copy, Clone, Eq)]
pub struct AddressArg(u16);

impl AddressArg {
    pub fn new(adr: u16) -> Self {
        Self(adr)
    }

    pub fn parse(adr2: u8, adr: u8) -> Self {
        let mut address = adr as u16;
        address |= (adr2 as u16) << 7;
        Self(address)
    }

    pub fn address(&self) -> u16 {
        self.0
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x3FFF,
            0,
            "address must only use the 14 least significant bits"
        );
        self.0 = address;
    }

    pub fn adr1(&self) -> u8 {
        (self.0 & 0x007F) as u8
    }

    pub fn adr2(&self) -> u8 {
        ((self.0 >> 7) & 0x007F) as u8
    }

    pub fn equals(&self, other: AddressArg) -> bool {
        self.0 == other.0
    }

    pub fn to_string(&self) -> String {
        format!("adr: {}", self.0)
    }
}

impl PartialEq for AddressArg {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Display for AddressArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "adr: {}", self.0)
    }
}

foreign_class!(
    /// This arg represents a loco net address of 14 byte length.
    #[derive(Clone)]
    class AddressArg {
        self_type AddressArg;
        /// Creates a new loco net address. Please consider to keep in range of 14 bytes.
        /// @param address The loco net address
        constructor AddressArg::new(address: u16) -> AddressArg;
        /// @return The 14 byte loco net address
        fn AddressArg::address(&self) -> u16; alias address;
        /// Sets a new 14 byte loco net address to this arg
        /// @param address The 14 byte loco net address
        fn AddressArg::set_address(&mut self, address: u16); alias setAddress;
        /// Checks whether this address is equal to another. To addresses are equal, when their 14 byte addresses are equal.
        /// @param other The other address to check equality with
        fn AddressArg::eq(&self, other: &AddressArg) -> bool; alias equals;
        /// @return A string of the format: 'adr: 14 byte address'
        fn AddressArg::to_string(&self) -> String; alias toString;
        foreign_code r#"
    /**
     * Checks whether this address is equal to another object.
     * @param o The object to compare to
     * @return If this address is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((AddressArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.address());
    }
"#;
    }
);

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SwitchDirection {
    Straight,
    Curved,
}

foreign_enum!(
    /// Indicates the state oh a switch
    enum SwitchDirection {
        /// The switch is straight (1)
        STRAIGHT = SwitchDirection::Straight,
        /// The switch is curved (0)
        CURVED = SwitchDirection::Curved,
    }
);

#[derive(Debug, Copy, Clone, Eq)]
pub struct SwitchArg {
    address: u16,
    direction: SwitchDirection,
    state: bool,
}

impl SwitchArg {
    pub fn new(address: u16, direction: SwitchDirection, state: bool) -> Self {
        Self{address, direction, state}
    }

    pub fn parse(sw1: u8, sw2: u8) -> Self {
        let mut address = sw1 as u16;
        address |= (sw2 as u16 & 0x0F) << 7;

        let direction = if sw2 & 0x20 == 0 {
            SwitchDirection::Curved
        } else {
            SwitchDirection::Straight
        };

        let state = (sw2 & 0x10) != 0;
        Self {
            address,
            direction,
            state,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }
    pub fn direction(&self) -> SwitchDirection {
        self.direction
    }
    pub fn state(&self) -> bool {
        self.state
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x07FF,
            0,
            "address must only use the 11 least significant bits"
        );
        self.address = address;
    }
    pub fn set_direction(&mut self, direction: SwitchDirection) {
        self.direction = direction;
    }
    pub fn set_state(&mut self, state: bool) {
        self.state = state;
    }

    pub fn sw1(&self) -> u8 {
        (self.address & 0x007F) as u8
    }

    pub fn sw2(&self) -> u8 {
        let mut sw2 = ((self.address >> 7) & 0x000F) as u8;

        sw2 |= match self.direction {
            SwitchDirection::Curved => 0x00,
            SwitchDirection::Straight => 0x20
        };

        if self.state {
            sw2 |= 0x10;
        }

        sw2
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl PartialEq for SwitchArg {
    fn eq(&self, other: &Self) -> bool {
        self.address == other.address && self.state == other.state && self.direction == other.direction
    }
}

impl Display for SwitchArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "sw: {}, {}, {:?}", self.address, self.state, self.direction)
    }
}

foreign_class!(
    /// Represents a switch loco net message.
    class SwitchArg {
        self_type SwitchArg;
        /// Creates a new switch message
        /// @param address The switch address
        /// @param direction The switch direction
        /// @param state The switch state
        constructor SwitchArg::new(address: u16, direction: SwitchDirection, state: bool) -> SwitchArg;
        /// @return The switch address
        fn SwitchArg::address(&self) -> u16;
        /// @return The switch direction
        fn SwitchArg::direction(&self) -> SwitchDirection;
        /// @return The switch state
        fn SwitchArg::state(&self) -> bool;
        /// Sets the switch address
        /// @param address The switch address
        fn SwitchArg::set_address(&mut self, address: u16); alias setAddress;
        /// Sets the switch direction
        /// @param direction The switch direction
        fn SwitchArg::set_direction(&mut self, direction: SwitchDirection); alias setDirection;
        /// Sets the switch state
        /// @param state The switch state
        fn SwitchArg::set_state(&mut self, state: bool); alias setState;
        /// @return A string in the format "sw: address, direction, state"
        fn SwitchArg::to_string(&self) -> String; alias toString;
        /// @param other Another switch arg to compare
        /// @return If the other switch arg is equals to this
        fn SwitchArg::eq(&self, other: &SwitchArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this switch arg is equal to another object.
     * @param o The object to compare to
     * @return If this switch arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SwitchArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.address(), this.direction(), this.state());
    }
"#;
    }
);

#[derive(Debug, Copy, Clone, Eq)]
pub struct SlotArg(u8);

impl SlotArg {
    pub fn parse(slot: u8) -> Self {
        Self(slot & 0x7F)
    }

    pub fn slot(&self) -> u8 {
        self.0
    }

    pub fn set_slot(&mut self, slot: u8) {
        assert_eq!(
            slot & 0x7F,
            0,
            "number must only use the 7 least significant bits"
        );
        self.0 = slot;
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl PartialEq for SlotArg {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Display for SlotArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "slot: {}", self.0)
    }
}

foreign_class!(
/// This class represents a slot arg, defined by a slot
class SlotArg {
    self_type SlotArg;
        /// Creates a slot with the given slot number
        /// @param slot The slots number
    constructor SlotArg::parse(slot: u8) -> SlotArg;
        /// @return The slot of this arg
    fn SlotArg::slot(&self) -> u8;
        /// Sets the slot to the given number
        /// @param slot The slot to set
    fn SlotArg::set_slot(&mut self, slot: u8); alias setSlot;
        /// Checks whether this slot arg is equal to another object.
        /// @param other The slot arg to compare to
        /// @return If this slot arg is equal to the given object
    fn SlotArg::eq(&self, other: &SlotArg) -> bool; alias equals;
        /// @return A string in the format "slot: slot"
    fn SlotArg::to_string(&self) -> String; alias toString;
    foreign_code r#"
    /**
     * Checks whether this slot arg is equal to another object.
     * @param o The object to compare to
     * @return If this slot arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.slot());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SpeedArg {
    Stop,
    EmergencyStop,
    Drive(u8),
}

impl SpeedArg {
    pub fn parse(spd: u8) -> Self {
        match spd {
            0x00 => Self::Stop,
            0x01 => Self::EmergencyStop,
            _ => Self::Drive(spd - 1),
        }
    }

    pub fn new(spd: u8) -> Self {
        match spd {
            0x00 => Self::Stop,
            _ => Self::Drive(spd)
        }
    }

    pub fn new_emergency() -> Self {
        Self::EmergencyStop
    }

    pub fn spd(&self) -> u8 {
        match *self {
            SpeedArg::Stop => 0x00,
            SpeedArg::EmergencyStop => 0x01,
            SpeedArg::Drive(spd) => spd + 1
        }
    }

    pub fn get_spd(&self) -> u8 {
        match *self {
            SpeedArg::Stop => 0x00,
            SpeedArg::EmergencyStop => 0x00,
            SpeedArg::Drive(spd) => spd,
        }
    }

    pub fn is_emergency_stop(&self) -> bool {
        match self {
            SpeedArg::EmergencyStop => true,
            _ => false
        }
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SpeedArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            SpeedArg::Stop => write!(f, "speed: stop"),
            SpeedArg::EmergencyStop => write!(f, "speed: emergency stop"),
            SpeedArg::Drive(spd) => write!(f, "speed: {}", spd)
        }
    }
}

foreign_class!(
    /// This class represents a train speed
    class SpeedArg {
    self_type SpeedArg;
        /// Sets the speed to the given spd. 0 is a normal stop. To set an emergency stop use SpeedArg()
        /// @param spd The speed to set this speed arg to
    constructor SpeedArg::new(spd: u8) -> SpeedArg;
        /// Creates a new SpeedArg with the spd set to emergency stop.
    constructor SpeedArg::new_emergency() -> SpeedArg;
        /// @return The speed of this arg with a value reserved for the emergency stop. 0 - Stop, 1 - Emergency Stop, other - Speed: other-1
    fn SpeedArg::spd(&self) -> u8; alias calculatedSpeed;
        /// @return The speed of this arg. All values are the actual speed, an emergency stop and stop value are both represented as 0.
    fn SpeedArg::get_spd(&self) -> u8; alias spd;
        /// @return If this speed arg represents an emergency stop for this train
    fn SpeedArg::is_emergency_stop(&self) -> bool; alias isEmergencyStop;
        /// @return A string in the format "speed: value" value = stop|emergency stop|speed
    fn SpeedArg::to_string(&self) -> String; alias toString;
        /// Checks whether this speed arg is equal to another speed arg
        /// @param other The speed arg to compare with
        /// @return If this speed arg is equal to the given speed arg
    fn SpeedArg::eq(&self, other: &SpeedArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this speed arg is equal to another object.
     * @param o The object to compare to
     * @return If this speed arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.calculatedSpeed());
    }
"#;
});

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DirfArg(u8);

impl DirfArg {
    pub fn new(dir: bool, f0: bool, f1: bool, f2: bool, f3: bool, f4: bool) -> Self {
        let mut dirf = if dir { 0x20 } else { 0x00 };
        if f0 {
            dirf |= 0x10
        }
        if f1 {
            dirf |= 0x01
        }
        if f2 {
            dirf |= 0x02
        }
        if f3 {
            dirf |= 0x04
        }
        if f4 {
            dirf |= 0x08
        }
        Self(dirf & 0x3F)
    }

    pub fn parse(dirf: u8) -> Self {
        Self(dirf & 0x3F)
    }

    pub fn dir(&self) -> bool {
        self.0 & 0x20 != 0
    }

    pub fn f(&self, f_num: u8) -> bool {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        self.0 >> (if f_num == 0 { 4 } else { f_num - 1 }) & 1 != 0
    }

    pub fn set_dir(&mut self, value: bool) {
        if value {
            self.0 |= 0x20;
        } else {
            self.0 &= !0x20
        }
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        let mask = 1 << if f_num == 0 { 4 } else { f_num - 1 };
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn dirf(&self) -> u8 {
        self.0
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Debug for DirfArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "dirf: (dir: {}, f0: {}, f1: {}, f2: {}, f3: {}, f4: {})",
            self.dir(),
            self.f(0),
            self.f(1),
            self.f(2),
            self.f(3),
            self.f(4)
        )
    }
}

impl Display for DirfArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "dirf: (dir: {}, f0: {}, f1: {}, f2: {}, f3: {}, f4: {})",
            self.dir(),
            self.f(0),
            self.f(1),
            self.f(2),
            self.f(3),
            self.f(4)
        )
    }
}

foreign_class!(
    /// This class represents an direction and function arg
    class DirfArg {
        self_type DirfArg;
        /// Creates a new direction and function arg
        /// @param dir The direction to set
        /// @param f0 The function 0
        /// @param f1 The function 1
        /// @param f2 The function 2
        /// @param f3 The function 3
        /// @param f4 The function 4
        constructor DirfArg::new(dir: bool, f0: bool, f1: bool, f2: bool, f3: bool, f4: bool) -> DirfArg;
        /// Creates a concentrated function and direction arg
        /// @param dirf The function and direction arg to set
        constructor DirfArg::parse(dirf: u8) -> DirfArg;
        /// @return The set direction. true = forward, false = backward
        fn DirfArg::dir(&self) -> bool;
        /// @param fNum The function number to read (0 - 4)
        /// @return The functions value
        fn DirfArg::f(&self, fNum: u8) -> bool;
        /// Sets the direction of this arg
        /// @param dir The direction to set
        fn DirfArg::set_dir(&mut self, dir: bool); alias setDir;
        /// Sets the value f to the function number fNum (0-4)
        fn DirfArg::set_f(&mut self, fNum: u8, f: bool); alias setF;
        /// @return A string in the format "dirf: (dir: dir, f0: f0 - f4: f4)"
        fn DirfArg::to_string(&self) -> String; alias toString;
        /// Checks whether this dirf arg is equal to another dirf arg
        /// @param other The dirf arg to compare to
        /// @return If this dirf arg is equal to the other dirf arg
        fn DirfArg::eq(&self, other: &DirfArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this dirf arg is equal to another object.
     * @param o The object to compare to
     * @return If this dirf arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.dir(), this.f((short) 0), this.f((short) 1), this.f((short) 2), this.f((short) 3), this.f((short) 4));
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct TrkArg {
    power: bool,
    idle: bool,
    mlok1: bool,
    prog_busy: bool,
}

impl TrkArg {
    pub fn new(power: bool, idle: bool, mlok1: bool, prog_busy: bool) -> Self {
        TrkArg {power, idle, mlok1, prog_busy}
    }

    pub fn parse(trk_arg: u8) -> Self {
        let power = trk_arg & 0x01 == 0x01;
        let idle = trk_arg & 0x02 == 0x00;
        let mlok1 = trk_arg & 0x04 == 0x04;
        let prog_busy = trk_arg & 0x08 == 0x08;
        TrkArg {
            power,
            idle,
            mlok1,
            prog_busy,
        }
    }

    pub fn power_on(&self) -> bool {
        self.power
    }

    pub fn track_idle(&self) -> bool {
        self.idle
    }

    pub fn mlok1(&self) -> bool {
        self.mlok1
    }

    pub fn prog_busy(&self) -> bool {
        self.prog_busy
    }

    pub fn trk_arg(&self) -> u8 {
        let mut trk_arg = if self.power { 0x01 } else { 0x00 };
        if !self.idle {
            trk_arg |= 0x02;
        }
        if self.mlok1 {
            trk_arg |= 0x04;
        }
        if self.prog_busy {
            trk_arg |= 0x08;
        }
        trk_arg
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for TrkArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "trk_arg: (power: {}, idle: {}, mlok1: {}, prog_busy: {})",
            self.power,
            self.idle,
            self.mlok1,
            self.prog_busy
        )
    }
}

foreign_class!(
    /// This class holds the track parameters
    class TrkArg {
        self_type TrkArg;
        /// Creates a new track arg
        /// @param power True = DCC packets are on in master and global power is up
        /// @param idle Ture = The track is paused (emergency stop)
        /// @param mlok1 True = This master implements LocoNet 1.1 capability, False = Master is DT200
        /// @param progBusy True = Programming track in this master is busy
        constructor TrkArg::new(power: bool, idle: bool, mlok1: bool, progBusy: bool) -> TrkArg;
        /// @return If dcc packets can be send to track and if the track has energy
        fn TrkArg::power_on(&self) -> bool; alias powerOn;
        /// @return If the track is paused by something like an emergency stop
        fn TrkArg::track_idle(&self) -> bool; alias trackIdle;
        /// @return If this master implements LocoNet 1.1 capability (true) or this master is DT200 (false)
        fn TrkArg::mlok1(&self) -> bool;
        /// @return If the programming track is in state busy
        fn TrkArg::prog_busy(&self) -> bool; alias progBusy;
        /// @return A string in the format "trk_arg: (power: power, idle: idle, mlok1: mlok1, prog_busy: prog_busy)"
        fn TrkArg::to_string(&self) -> String; alias toString;
        /// Checks whether this trk arg is equal to another trk arg
        /// @param other The trk arg to compare to
        /// @return If this trk arg is equal to the other trk arg
        fn TrkArg::eq(&self, other: &TrkArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this trk arg is equal to another object.
     * @param o The object to compare to
     * @return If this trk arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((TrkArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.powerOn(), this.trackIdle(), this.mlok1(), this.progBusy());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SndArg(u8);

impl SndArg {
    pub fn parse(snd: u8) -> Self {
        Self(snd & 0x0F)
    }
    pub fn new(f5: bool, f6: bool, f7: bool, f8: bool) -> Self{
        let mut snd = if f5 { 0x01 } else { 0x00 } as u8;
        if f6 {
            snd |= 0x02
        }
        if f7 {
            snd |= 0x04
        }
        if f8 {
            snd |= 0x08
        }
        Self(snd)
    }

    pub fn f(&self, f_num: u8) -> bool {
        assert!(
            (5..=8).contains(&f_num),
            "f_num must be within 5 and 8 (inclusive)"
        );
        self.0 & 1 << (f_num - 5) != 0
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(
            (5..=8).contains(&f_num),
            "f_num must be within 5 and 8 (inclusive)"
        );
        let mask = 1 << (f_num - 5);
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn snd(&self) -> u8 {
        self.0
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SndArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "snd: (f5: {}, f6: {}, f7: {}, f8: {})",
            self.f(5),
            self.f(6),
            self.f(7),
            self.f(8)
        )
    }
}


foreign_class!(
    /// This arg holds the trains sound function parameters f5 to f8
    class SndArg {
        self_type SndArg;
        /// Sets a new snd arg by parsing the least significant four bits as functions f8 to f5
        /// @param snd The snd function values as short. The least significant 4 bits are the function values
        constructor SndArg::parse(snd: u8) -> SndArg;
        /// Sets a new snd arg by giving the functions values
        /// @param f5 The f5 function value
        /// @param f6 The f6 function value
        /// @param f7 The f7 function value
        /// @param f8 The f8 function value
        constructor SndArg::new(f5: bool, f6: bool, f7: bool, f8: bool) -> SndArg;
        /// Calculates the function value of position fNum. Only values between 5 and 8 (inclusive) are allowed
        /// @param fNum The position of the value to read (5-8)
        /// @return The value of the position
        fn SndArg::f(&self, fNum: u8) -> bool;
        /// Sets the function value at the position fNum. For fNum only values between 5 and 8 (inclusive) are allowed
        /// @param fNum The position to set the value at
        /// @param f The value for the position
        fn SndArg::set_f(&mut self, fNum: u8, f: bool); alias setF;
        /// @return A string in the format "snd: (f5: f5, f6: f6, f7: f7, f8: f8)"
        fn SndArg::to_string(&self) -> String; alias toString;
        /// Checks whether this snd arg is equal to another snd arg
        /// @param other The snd arg to compare to
        /// @return If this snd arg is equal to the other snd arg
        fn SndArg::eq(&self, other: &SndArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this snd arg is equal to another object.
     * @param o The object to compare to
     * @return If this trk snd is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SndArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.f((short) 5), this.f((short) 6), this.f((short) 7), this.f((short) 8));
    }
"#;
});

#[derive(Debug, Copy, Clone)]
pub struct Stat1Arg {
    spurge: bool,
    consist: Consist,
    state: State,
    decoder_type: DecoderType,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Consist {
    LogicalMid,
    LogicalTop,
    LogicalSubMember,
    Free,
}

foreign_enum!(enum Consist {
    LOGICAL_MID = Consist::LogicalMid,
    LOGICAL_TOP = Consist::LogicalTop,
    LOGICAL_SUB_MEMBER = Consist::LogicalSubMember,
    FREE = Consist::Free,
});

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum State {
    InUse,
    Idle,
    Common,
    Free,
}

foreign_enum!(enum State {
    IN_USE = State::InUse,
    IDLE = State::Idle,
    COMMON = State::Common,
    FREE = State::Free,
});

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum DecoderType {
    Dcc28,
    Dcc128,
    Regular28,
    AdrMobile28,
    Step14,
    Speed128,
}

foreign_enum!(enum DecoderType {
    DCC_28 = DecoderType::Dcc28,
    DCC_128 = DecoderType::Dcc128,
    REGULAR_128 = DecoderType::Regular28,
    ADR_MOBILE_28 = DecoderType::AdrMobile28,
    STEP_14 = DecoderType::Step14,
    SPEED_128 = DecoderType::Speed128,
});

impl Stat1Arg {
    pub fn new(spurge: bool, consist: Consist, state: State, decoder_type: DecoderType) -> Self {
        Stat1Arg { spurge, consist, state, decoder_type }
    }

    pub fn parse(stat1: u8) -> Self {
        let spurge = stat1 & 0x80 != 0;

        let consist = match stat1 & 0x48 {
            0x48 => Consist::LogicalMid,
            0x08 => Consist::LogicalTop,
            0x40 => Consist::LogicalSubMember,
            0x00 => Consist::Free,
            _ => panic!("No valid consist is given!"),
        };

        let state = match stat1 & 0x30 {
            0x30 => State::InUse,
            0x20 => State::Idle,
            0x10 => State::Common,
            0x00 => State::Free,
            _ => panic!("No valid state is given!"),
        };

        let decoder_type = match stat1 & 0x07 {
            0x02 => DecoderType::Step14,
            0x01 => DecoderType::AdrMobile28,
            0x00 => DecoderType::Regular28,
            0x03 => DecoderType::Speed128,
            0x07 => DecoderType::Dcc128,
            0x04 => DecoderType::Dcc28,
            _ => panic!("The given decoder type was invalid!"),
        };

        Stat1Arg {
            spurge,
            consist,
            state,
            decoder_type,
        }
    }

    pub fn spurge(&self) -> bool {
        self.spurge
    }

    pub fn consist(&self) -> Consist {
        self.consist
    }

    pub fn state(&self) -> State {
        self.state
    }

    pub fn decoder_type(&self) -> DecoderType {
        self.decoder_type
    }

    pub fn stat1(&self) -> u8 {
        let mut stat1: u8 = if self.spurge { 0x80 } else { 0x00 };

        stat1 |= match self.consist {
            Consist::LogicalMid => 0x48,
            Consist::LogicalTop => 0x08,
            Consist::LogicalSubMember => 0x40,
            Consist::Free => 0x00
        };

        stat1 |= match self.state {
            State::InUse => 0x30,
            State::Idle => 0x20,
            State::Common => 0x10,
            State::Free => 0x00
        };

        stat1 |= match self.decoder_type {
            DecoderType::Dcc28 => 0x04,
            DecoderType::Dcc128 => 0x07,
            DecoderType::Regular28 => 0x00,
            DecoderType::AdrMobile28 => 0x01,
            DecoderType::Step14 => 0x02,
            DecoderType::Speed128 => 0x03
        };

        stat1
    }
}

foreign_class!(class Stat1Arg {
    self_type Stat1Arg;
    constructor Stat1Arg::new(_: bool, _: Consist, _: State, decoder: DecoderType) -> Stat1Arg;
    fn Stat1Arg::spurge(&self) -> bool;
    fn Stat1Arg::consist(&self) -> Consist;
    fn Stat1Arg::state(&self) -> State;
    fn Stat1Arg::decoder_type(&self) -> DecoderType; alias decoderType;
});

#[derive(Debug, Copy, Clone)]
pub struct Stat2Arg {
    has_adv: bool,
    no_id_usage: bool,
    id_encoded_alias: bool,
}

impl Stat2Arg {
    pub fn new(has_adv: bool, no_id_usage: bool, id_encoded_alias: bool) -> Self {
        Stat2Arg{ has_adv, no_id_usage, id_encoded_alias }
    }

    pub fn parse(stat2: u8) -> Self {
        let has_adv = stat2 & 0x01 != 0;

        let no_id_usage = stat2 & 0x04 != 0;

        let id_encoded_alias = stat2 & 0x08 != 0;

        Stat2Arg {
            has_adv,
            no_id_usage,
            id_encoded_alias,
        }
    }

    pub fn has_adv(&self) -> bool {
        self.has_adv
    }

    pub fn no_id_usage(&self) -> bool {
        self.no_id_usage
    }

    pub fn id_encoded_alias(&self) -> bool {
        self.id_encoded_alias
    }

    pub fn stat2(&self) -> u8 {
        let mut stat2 = if self.has_adv { 0x01 } else { 0x00 };
        if self.no_id_usage {
            stat2 |= 0x04;
        }
        if self.id_encoded_alias {
            stat2 |= 0x08;
        }
        stat2
    }
}

foreign_class!(class Stat2Arg {
    self_type Stat2Arg;
    constructor Stat2Arg::new(_: bool, _: bool, _: bool) -> Stat2Arg;
    fn Stat2Arg::has_adv(&self) -> bool; alias hasAdv;
    fn Stat2Arg::no_id_usage(&self) -> bool; alias noIdUsage;
    fn Stat2Arg::id_encoded_alias(&self) -> bool; alias idEncodedAlias;
});

#[derive(Debug, Copy, Clone)]
pub struct LopcArg(u8);

impl LopcArg {
    pub fn parse(lopc: u8) -> Self {
        Self(lopc & !0x40)
    }

    pub fn lopc(&self) -> u8 {
        self.0
    }

    pub fn set_lopc(&mut self, lopc: u8) {
        assert_eq!(lopc & 0x40, 0, "7th least significant bit must be 0");
        self.0 = lopc
    }
}

foreign_class!(class LopcArg {
    self_type LopcArg;
    constructor LopcArg::parse(_: u8) -> LopcArg;
    fn LopcArg::lopc(&self) -> u8;
    fn LopcArg::set_lopc(&mut self, _: u8); alias setLopc;
});

#[derive(Debug, Copy, Clone)]
pub struct Ack1Arg(u8);

impl Ack1Arg {
    pub fn parse(ack1: u8) -> Self {
        Self(ack1)
    }

    pub fn ack1(&self) -> u8 {
        self.0
    }

    pub fn success(&self) -> bool {
        self.0 != 0
    }

    pub fn is_busy(&self) -> bool {
        self.0 == 0
    }

    pub fn accepted(&self) -> bool {
        self.0 == 1
    }

    pub fn accepted_blind(&self) -> bool {
        self.0 == 0x40
    }

    pub fn set_code(&mut self, code: u8) {
        self.0 = code
    }
}

foreign_class!(class Ack1Arg {
    self_type Ack1Arg;
    constructor Ack1Arg::parse(_: u8) -> Ack1Arg;
    fn Ack1Arg::ack1(&self) -> u8;
    fn Ack1Arg::success(&self) -> bool;
    fn Ack1Arg::is_busy(&self) -> bool; alias isBusy;
    fn Ack1Arg::accepted(&self) -> bool;
    fn Ack1Arg::accepted_blind(&self) -> bool; alias acceptedBlind;
    fn Ack1Arg::set_code(&mut self, _: u8); alias setCode;
});

#[derive(Copy, Clone)]
pub struct InArg {
    address: u16,
    source_type: SourceType,
    state: bool,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum SourceType {
    Aux,
    Switch,
}

foreign_enum!(enum SourceType {
    AUX = SourceType::Aux,
    SWITCH = SourceType::Switch,
});

impl InArg {
    pub fn new(address: u16, source_type: SourceType, state: bool) -> Self {
        InArg { address, source_type, state }
    }

    pub fn parse(in1: u8, in2: u8) -> Self {
        let mut address = in1 as u16;
        address |= (in2 as u16 & 0x0F) << 7;

        let source_type = if in2 & 0x20 == 0 {
            SourceType::Aux
        } else {
            SourceType::Switch
        };

        let state = (in2 & 0x10) != 0;
        Self {
            address,
            source_type,
            state,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn address_ds54(&self) -> u16 {
        self.address << 1
            | if self.source_type() == SourceType::Switch {
            1
        } else {
            0
        }
    }

    pub fn source_type(&self) -> SourceType {
        self.source_type
    }

    pub fn state(&self) -> bool {
        self.state
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x07FF,
            0,
            "address must only use the 11 least significant bits"
        );
        self.address = address;
    }

    pub fn set_address_ds54(&mut self, address_ds54: u16) {
        assert_eq!(
            self.address & 0x0FFF,
            0,
            "address must only use the 12 least significant bits"
        );
        self.set_source_type(if address_ds54 & 1 == 0 {
            SourceType::Aux
        } else {
            SourceType::Switch
        });
        self.set_address(address_ds54 >> 1);
    }

    pub fn set_source_type(&mut self, source_type: SourceType) {
        self.source_type = source_type;
    }

    pub fn set_state(&mut self, state: bool) {
        self.state = state;
    }

    pub fn in1(&self) -> u8 {
        self.address as u8 & 0x7F
    }

    pub fn in2(&self) -> u8 {
        let mut in2 = ((self.address >> 7) as u8) & 0x0F;
        in2 |= match self.source_type {
            SourceType::Aux => 0x00,
            SourceType::Switch => 0x20
        };
        if self.state {
            in2 |= 0x10;
        }
        in2
    }
}

impl Debug for InArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InArg {{ address: {:?} (DS54: {:?}), source_type: {:?}, state: {:?} }}",
            self.address(),
            self.address_ds54(),
            self.source_type(),
            self.state()
        )
    }
}

foreign_class!(class InArg {
    self_type InArg;
    constructor InArg::new(_: u16, _: SourceType, _: bool) -> InArg;
    fn InArg::address(&self) -> u16;
    fn InArg::address_ds54(&self) -> u16; alias addressDs54;
    fn InArg::source_type(&self) -> SourceType; alias sourceType;
    fn InArg::state(&self) -> bool;
    fn InArg::set_address(&mut self, _: u16); alias setAddress;
    fn InArg::set_address_ds54(&mut self, _: u16); alias setAddressDs54;
    fn InArg::set_source_type(&mut self, _: SourceType); alias setSourceType;
    fn InArg::set_state(&mut self, _: bool); alias setState;
});

#[derive(Debug, Copy, Clone)]
pub struct SnArg {
    address: u16,
    format: bool,
    c: bool,
    t: bool,
}

impl SnArg {
    pub fn new(address: u16, format: bool, c: bool, t: bool) -> Self {
        SnArg { address, format, c, t }
    }

    pub fn parse(sn1: u8, sn2: u8) -> Self {
        let mut address = sn1 as u16;
        address |= (sn2 as u16 & 0x0F) << 7;

        let format = sn2 & 0x20 == 0x20;

        let c = sn2 & 0x40 == 0x40;
        let t = sn2 & 0x80 == 0x80;

        SnArg {
            address,
            format,
            c,
            t,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn format(&self) -> bool {
        self.format
    }

    pub fn c(&self) -> bool {
        self.c
    }

    pub fn t(&self) -> bool {
        self.t
    }

    pub fn set_address(&mut self, address: u16) {
        self.address = address;
    }

    pub fn set_format(&mut self, format: bool) {
        self.format = format;
    }

    pub fn set_c(&mut self, c: bool) {
        self.c = c;
    }

    pub fn set_t(&mut self, t: bool) {
        self.t = t;
    }

    pub fn sn1(&self) -> u8 {
        (self.address as u8) & 0x7F
    }

    pub fn sn2(&self) -> u8 {
        let mut sn2 = (self.address >> 7) as u8 & 0x0F;
        if self.format {
            sn2 |= 0x20;
        }
        if self.c {
            sn2 |= 0x40;
        }
        if self.t {
            sn2 |= 0x80;
        }
        sn2
    }
}

foreign_class!(class SnArg {
    self_type SnArg;
    constructor SnArg::new(_: u16, _: bool, _: bool, _: bool) -> SnArg;
    fn SnArg::address(&self) -> u16;
    fn SnArg::format(&self) -> bool;
    fn SnArg::c(&self) -> bool;
    fn SnArg::t(&self) -> bool;
    fn SnArg::set_address(&mut self, _: u16); alias setAddress;
    fn SnArg::set_format(&mut self, _: bool); alias setFormat;
    fn SnArg::set_c(&mut self, _: bool); alias setC;
    fn SnArg::set_t(&mut self, _: bool);alias setT;
});

#[derive(Debug, Copy, Clone)]
pub struct IdArg(u8, u8);

impl IdArg {
    pub fn parse(id1: u8, id2: u8) -> Self {
        IdArg(id1 & 0xF7, id2 & 0xF7)
    }

    pub fn id1(&self) -> u8 {
        self.0
    }

    pub fn id2(&self) -> u8 {
        self.1
    }
}

foreign_class!(class IdArg {
    self_type IdArg;
    constructor IdArg::parse(_: u8, _: u8) -> IdArg;
    fn IdArg::id1(&self) -> u8;
    fn IdArg::id2(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct MTypeArg(u8);

impl MTypeArg {
    pub fn parse(m_type: u8) -> Self {
        MTypeArg(m_type)
    }

    pub fn m_type(&self) -> u8 {
        self.0
    }
}

foreign_class!(class MTypeArg {
    self_type MTypeArg;
    constructor MTypeArg::parse(_: u8) -> MTypeArg;
    fn MTypeArg::m_type(&self) -> u8; alias mType;
});

#[derive(Debug, Copy, Clone)]
pub struct ZasArg(u8);

impl ZasArg {
    pub fn parse(zone_and_section: u8) -> Self {
        ZasArg(zone_and_section)
    }

    pub fn zas(&self) -> u8 {
        self.0
    }
}

foreign_class!(class ZasArg {
    self_type ZasArg;
    constructor ZasArg::parse(_: u8) -> ZasArg;
    fn ZasArg::zas(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct SenseAddrArg(u16);

impl SenseAddrArg {
    pub fn new(address: u16) -> Self {
        SenseAddrArg(address)
    }

    pub fn parse(addr1: u8, addr2: u8) -> Self {
        let mut address = addr1 as u16;
        address |= (addr2 as u16) << 7;

        SenseAddrArg(address)
    }

    pub fn address(&self) -> u16 {
        self.0
    }

    pub fn addr1(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn addr2(&self) -> u8 {
        (self.0 >> 7) as u8
    }
}

foreign_class!(class SenseAddrArg {
    self_type SenseAddrArg;
    constructor SenseAddrArg::new(_: u16) -> SenseAddrArg;
    constructor SenseAddrArg::parse(_: u8, _: u8) -> SenseAddrArg;
    fn SenseAddrArg::address(&self) -> u16;
    fn SenseAddrArg::addr1(&self) -> u8;
    fn SenseAddrArg::addr2(&self) -> u8;
});

#[derive(Copy, Clone)]
pub struct FunctionArg(u8, u8);

impl FunctionArg {
    pub fn new(group: u8) -> Self {
        FunctionArg(group, 0)
    }

    pub fn parse(group: u8, function: u8) -> Self {
        FunctionArg(group, function)
    }

    pub fn f(&self, f_num: u8) -> bool {
        if f_num > 8 && f_num < 12 && self.0 == 0x07 {
            (self.1 >> (f_num - 9) & 1) != 0
        } else if (f_num == 12 || f_num == 20 || f_num == 28) && self.0 == 0x05 {
            (self.1
                >> (if f_num == 12 {
                0
            } else if f_num == 20 {
                1
            } else {
                2
            })
                & 1)
                != 0
        } else if f_num > 12 && f_num < 20 && self.0 == 0x08 {
            (self.1 >> (f_num - 13) & 1) != 0
        } else if f_num > 20 && f_num < 28 && self.0 == 0x09 {
            (self.1 >> (f_num - 21) & 1) != 0
        } else {
            false
        }
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        let mask = 1 << (f_num - 9);
        if value {
            self.1 |= mask;
        } else {
            self.1 &= !mask;
        }
    }

    pub fn group(&self) -> u8 {
        self.0
    }

    pub fn function(&self) -> u8 {
        self.1
    }
}

impl Debug for FunctionArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DirfArg(f9: {}, f10: {}, f11: {}, f12: {}, f13: {}, f14: {}, f15: {}, f16: {}, f17: {}, f18: {}, f19: {}, f20: {}, f21: {}, f22: {}, f23: {}, f24: {}, f25: {}, f26: {}, f27: {}, f28: {})",
            self.f(9),
            self.f(10),
            self.f(11),
            self.f(12),
            self.f(13),
            self.f(14),
            self.f(15),
            self.f(16),
            self.f(17),
            self.f(18),
            self.f(19),
            self.f(20),
            self.f(21),
            self.f(22),
            self.f(23),
            self.f(24),
            self.f(25),
            self.f(26),
            self.f(27),
            self.f(28),
        )
    }
}

foreign_class!(class FunctionArg {
    self_type FunctionArg;
    constructor FunctionArg::new(_: u8) -> FunctionArg;
    constructor FunctionArg::parse(_: u8, _: u8) -> FunctionArg;
    fn FunctionArg::group(&self) -> u8;
    fn FunctionArg::f(&self, _: u8) -> bool;
    fn FunctionArg::set_f(&mut self, _: u8, _: bool); alias setF;
});

#[derive(Debug, Copy, Clone)]
pub struct Pcmd {
    write: bool,
    byte_mode: bool,
    ops_mode: bool,
    ty1: bool, // Programing type select bit
    ty2: bool, // prog type select bit
}

impl Pcmd {
    pub fn new(write: bool, byte_mode: bool, ops_mode: bool, ty1: bool, ty2: bool) -> Self {
        Pcmd{ write, byte_mode, ops_mode, ty1, ty2 }
    }

    pub fn parse(pcmd: u8) -> Self {
        let write = pcmd & 0x20 == 0x20;
        let byte_mode = pcmd & 0x40 == 0x40;
        let ops_mode = pcmd & 0x02 == 0x02;
        let ty1 = pcmd & 0x80 == 0x80;
        let ty2 = pcmd & 0x01 == 0x01;

        Pcmd {
            write,
            byte_mode,
            ops_mode,
            ty1,
            ty2,
        }
    }

    pub fn write(&self) -> bool {
        self.write
    }

    pub fn byte_mode(&self) -> bool {
        self.byte_mode
    }

    pub fn ops_mode(&self) -> bool {
        self.ops_mode
    }

    pub fn ty1(&self) -> bool {
        self.ty1
    }

    pub fn ty2(&self) -> bool {
        self.ty2
    }

    pub fn pcmd(&self) -> u8 {
        let mut pcmd = if self.write { 0x20 } else { 0x00 };
        if self.byte_mode {
            pcmd |= 0x40;
        }
        if self.ops_mode {
            pcmd |= 0x02;
        }
        if self.ty1 {
            pcmd |= 0x80;
        }
        if self.ty2 {
            pcmd |= 0x01;
        }
        pcmd
    }
}

foreign_class!(class Pcmd {
    self_type Pcmd;
    constructor Pcmd::new(_: bool, _: bool, _: bool, _: bool, _: bool) -> Pcmd;
    fn Pcmd::write(&self) -> bool;
    fn Pcmd::byte_mode(&self) -> bool; alias byteMode;
    fn Pcmd::ops_mode(&self) -> bool; alias opsMode;
    fn Pcmd::ty1(&self) -> bool;
    fn Pcmd::ty2(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct PStat {
    user_aborted: bool,
    no_read_ack: bool,
    no_write_ack: bool,
    programming_track_empty: bool,
}

impl PStat {
    pub fn new(user_aborted: bool, no_read_ack: bool, no_write_ack: bool, programming_track_empty: bool) -> Self {
        PStat { user_aborted, no_read_ack, no_write_ack, programming_track_empty }
    }

    pub fn parse(stat: u8) -> Self {
        let user_aborted = stat & 0x01 == 0x01;
        let no_read_ack = stat & 0x02 == 0x02;
        let no_write_ack = stat & 0x04 == 0x04;
        let programming_track_empty = stat & 0x08 == 0x08;

        PStat {
            user_aborted,
            no_read_ack,
            no_write_ack,
            programming_track_empty,
        }
    }

    pub fn user_aborted(&self) -> bool {
        self.user_aborted
    }

    pub fn no_read_ack(&self) -> bool {
        self.no_read_ack
    }

    pub fn no_write_ack(&self) -> bool {
        self.no_write_ack
    }

    pub fn programming_track_empty(&self) -> bool {
        self.programming_track_empty
    }

    pub fn stat(&self) -> u8 {
        let mut stat = if self.user_aborted { 0x01 } else { 0x00 };
        if self.no_read_ack {
            stat |= 0x02;
        }
        if self.no_write_ack {
            stat |= 0x04;
        }
        if self.programming_track_empty {
            stat |= 0x08;
        }
        stat
    }
}

foreign_class!(class PStat {
    self_type PStat;
    constructor PStat::new(_: bool, _: bool, _: bool, _: bool) -> PStat;
    fn PStat::user_aborted(&self) -> bool; alias userAborted;
    fn PStat::no_read_ack(&self) -> bool; alias noReadAck;
    fn PStat::no_write_ack(&self) -> bool; alias noWriteAck;
    fn PStat::programming_track_empty(&self) -> bool; alias programmingTrackEmpty;
});

#[derive(Debug, Copy, Clone)]
pub struct Hopsa(u8);

impl Hopsa {
    pub fn parse(o_mode: u8) -> Self {
        Hopsa(o_mode & 0x7F)
    }

    pub fn service_mode(&self) -> bool {
        self.0 == 0
    }

    pub fn o_mode(&self) -> u8 {
        self.0
    }
}

foreign_class!(class Hopsa {
    self_type Hopsa;
    constructor Hopsa::parse(_: u8) -> Hopsa;
    fn Hopsa::service_mode(&self) -> bool; alias serviceMode;
    fn Hopsa::o_mode(&self) -> u8; alias oMode;
});

#[derive(Debug, Copy, Clone)]
pub struct Lopsa(u8);

impl Lopsa {
    pub fn parse(o_mode: u8) -> Self {
        Lopsa(o_mode & 0x7F)
    }

    pub fn service_mode(&self) -> bool {
        self.0 == 0
    }

    pub fn o_mode(&self) -> u8 {
        self.0
    }
}

foreign_class!(class Lopsa {
    self_type Lopsa;
    constructor Lopsa::parse(_: u8) -> Lopsa;
    fn Lopsa::service_mode(&self) -> bool; alias serviceMode;
    fn Lopsa::o_mode(&self) -> u8; alias oMode;
});

#[derive(Copy, Clone)]
pub struct CvArg(u16);

impl CvArg {
    pub fn new() -> Self {
        CvArg(0)
    }

    pub fn parse(cvh: u8, cvl: u8) -> Self {
        let mut cv_arg = cvl as u16;

        let data_arg = (cvh & 0x02) >> 1;
        let mut high_cv_arg = cvh & 0x01;
        high_cv_arg |= (cvh & 0x30) >> 3;
        high_cv_arg |= (data_arg) << 3;

        cv_arg |= (high_cv_arg as u16) << 7;

        CvArg(cv_arg)
    }

    pub fn data7(&self) -> bool {
        self.0 & 0x0800 != 0
    }

    pub fn cv(&self, cv_num: u8) -> bool {
        assert!(cv_num <= 9, "cv must be lower than or equal to 9");
        self.0 >> cv_num & 1 != 0
    }

    pub fn set_data7(&mut self, value: bool) {
        if value {
            self.0 |= 0x0800;
        } else {
            self.0 &= !0x0800;
        }
    }

    pub fn set_cv(&mut self, cv_num: u8, value: bool) {
        assert!(cv_num <= 9, "cv must be lower than or equal to 9");
        let mask = 1 << cv_num;
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn cvh(&self) -> u8 {
        let mut cvh = (self.0 >> 7) as u8;
        let high_cv = cvh & 0x06 << 3;
        cvh &= 0x01;
        cvh |= high_cv;
        if self.data7() {
            cvh |= 0x02;
        }
        cvh
    }

    pub fn cvl(&self) -> u8 {
        self.0 as u8 & 0x7F
    }
}

impl Debug for CvArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CvArg(data7: {}, cv0: {}, cv1: {}, cv2: {}, cv3: {}, cv4: {}, cv5: {}, cv6: {}, cv7: {}, cv8: {})",
            self.data7(),
            self.cv(0),
            self.cv(1),
            self.cv(2),
            self.cv(3),
            self.cv(4),
            self.cv(5),
            self.cv(6),
            self.cv(7),
            self.cv(8),
        )
    }
}

foreign_class!(class CvArg {
    self_type CvArg;
    constructor CvArg::new() -> CvArg;
    fn CvArg::data7(&self) -> bool;
    fn CvArg::cv(&self, _: u8) -> bool;
    fn CvArg::set_data7(&mut self, _: bool); alias setData7;
    fn CvArg::set_cv(&mut self, _: u8, _: bool); alias setCv;
});

#[derive(Copy, Clone)]
pub struct DataArg(u8);

impl DataArg {
    pub fn new() -> Self {
        DataArg(0)
    }

    pub fn parse(data: u8) -> Self {
        DataArg(data)
    }

    pub fn d(&self, d_num: u8) -> bool {
        assert!(d_num <= 6, "d must be lower than or equal to 6");
        self.0 >> d_num & 1 != 0
    }

    pub fn set_d(&mut self, d_num: u8, value: bool) {
        assert!(d_num <= 6, "d must be lower than or equal to 6");
        let mask = 1 << d_num;
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn data(&self) -> u8 {
        self.0
    }
}

impl Debug for DataArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DataArg(d0: {}, d1: {}, d2: {}, d3: {}, d4: {}, d5: {}, d6: {})",
            self.d(0),
            self.d(1),
            self.d(2),
            self.d(3),
            self.d(4),
            self.d(5),
            self.d(6),
        )
    }
}

foreign_class!(class DataArg {
    self_type DataArg;
    constructor DataArg::new() -> DataArg;
    constructor DataArg::parse(_: u8) -> DataArg;
    fn DataArg::d(&self, _: u8) -> bool;
    fn DataArg::set_d(&mut self, _: u8, _: bool); alias setD;
});

#[derive(Debug, Copy, Clone)]
pub struct ClkRateArg(u8);

impl ClkRateArg {
    pub fn parse(clk_rate: u8) -> Self {
        ClkRateArg(clk_rate & 0x7F)
    }

    pub fn set_rate(&mut self, clk_rate: u8) {
        assert!(
            clk_rate > 0x7F,
            "Clock rate {:?} is to high. Only values up to 0x7F are allowed",
            clk_rate
        );

        self.0 = clk_rate & 0x7F;
    }

    pub fn clk_rate(&self) -> u8 {
        self.0
    }
}

foreign_class!(class ClkRateArg {
    self_type ClkRateArg;
    constructor ClkRateArg::parse(_: u8) -> ClkRateArg;
    fn ClkRateArg::clk_rate(&self) -> u8; alias clkRate;
    fn ClkRateArg::set_rate(&mut self, _: u8); alias setRate;
});

#[derive(Debug, Copy, Clone)]
pub struct FastClock {
    clk_rate: u8,
    frac_minsl: u8,
    frac_minsh: u8,
    duration: Duration,
    clk_cntrl: u8,
}

impl FastClock {
    pub fn parse(clk_rate: u8, frac_minsl: u8, frac_minsh: u8, mins: u8, hours: u8, days: u8, clk_cntrl: u8) -> Self {
        let min = mins % 60 - 0xFF;
        let hour = hours % 60 - 0xFF;

        let secs: u64 = min as u64 * 60 + hour as u64 * 60 * 60 + days as u64 * 24 * 60 * 60;

        let duration = Duration::new(secs, 0);

        FastClock {
            clk_rate: clk_rate & 0x7F,
            frac_minsl,
            frac_minsh,
            duration,
            clk_cntrl,
        }
    }

    pub fn clk_rate(&self) -> u8 {
        self.clk_rate
    }

    pub fn frac_minsl(&self) -> u8 {
        self.frac_minsl
    }

    pub fn frac_minsh(&self) -> u8 {
        self.frac_minsh
    }

    pub fn mins(&self) -> u8 {
        0xFF - (self.duration.as_secs() % 60) as u8
    }

    pub fn hours(&self) -> u8 {
        0xFF - (self.duration.as_secs() / 60 % 60) as u8
    }

    pub fn days(&self) -> u8 {
        0xFF - (self.duration.as_secs() / 60 / 60 % 24) as u8
    }

    pub fn clk_cntrl(&self) -> u8 {
        self.clk_cntrl
    }
}

foreign_class!(class FastClock {
    self_type FastClock;
    constructor FastClock::parse(clkRate: u8, fracMinsl: u8, fracMinsh: u8, mins: u8, hours: u8, days: u8, clkCntrl: u8) -> FastClock;
    fn FastClock::clk_rate(&self) -> u8; alias clkRate;
    fn FastClock::frac_minsl(&self) -> u8; alias fracMinsl;
    fn FastClock::frac_minsh(&self) -> u8; alias fracMinsh;
    fn FastClock::mins(&self) -> u8;
    fn FastClock::hours(&self) -> u8;
    fn FastClock::days(&self) -> u8;
    fn FastClock::clk_cntrl(&self) -> u8; alias clkCntrl;
});

#[derive(Debug, Copy, Clone)]
pub struct ImArg {
    reps: u8,
    dhi: u8,
    address: u16,
    function_type: u8,
    function_bits: u8,
    im5: u8
}

impl ImArg {
    pub fn new(reps: u8, dhi: u8, address: u16, function_type: u8, function_bits: u8, im5: u8) -> Self {
        ImArg { reps, dhi, address, function_type, function_bits, im5 }
    }

    pub fn parse(check_byte: u8, reps: u8, dhi: u8, im1: u8, im2 : u8, im3: u8, im4: u8, im5: u8) -> ImArg {
        assert_eq!(check_byte, 0x7F, "Checkbyte of ImmPacket is not 0x7F");

        if reps == 0x34 {
            let address = ((im2 as u16) << 8) | im1 as u16;

            let function_type = if im3 == 0x5E { 0x5E } else if im3 == 0x5F { 0x5F } else { 0x20 };
            let mut function_bits = if function_type == 0x5E || function_type == 0x5F { im4 } else { im3 };

            function_bits = function_bits & 0x7F;

            Self {reps, dhi, address, function_type, function_bits, im5}
        } else {
            let address = im1 as u16;

            let function_type = if im3 == 0x5E { 0x5E } else if im3 == 0x5F { 0x5F } else { 0x20 };
            let mut function_bits = if function_type == 0x5E || function_type == 0x5F { im3 } else { im2 & 0xDF };

            function_bits = function_bits & 0x7F;

            Self {reps, dhi, address, function_type, function_bits, im5}
        }
    }

    pub fn check_byte(&self) -> u8 {
        0x7F
    }

    pub fn reps(&self) -> u8 {
        self.reps
    }

    pub fn dhi(&self) -> u8 {
        self.dhi
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn function_type(&self) -> u8 {
        self.function_type
    }

    pub fn function_bits(&self) -> u8 {
        self.function_bits
    }

    pub fn im1(&self) -> u8 {
        self.address as u8
    }

    pub fn im2(&self) -> u8 {
        return if self.reps == 0x34 {
            (self.address >> 8) as u8
        } else {
            if self.function_type == 0x20 {
                self.function_bits | 0x20
            } else {
                self.function_type
            }
        }
    }

    pub fn im3(&self) -> u8 {
        return if self.reps() == 0x34 {
            if self.function_type == 0x20 {
                self.function_bits | 0x20
            } else {
                self.function_type
            }
        } else {
            if self.function_type == 0x20 {
                0x00
            } else {
                self.function_bits
            }
        }
    }

    pub fn im4(&self) -> u8 {
        if self.reps() == 0x34 {
            if self.function_type != 0x20 {
                return self.function_bits;
            }
        }
        0x00
    }

    pub fn im5(&self) -> u8 {
        self.im5
    }
}

foreign_class!(class ImArg {
    self_type ImArg;
    constructor ImArg::new(reps: u8, dhi: u8, address: u16, functionType: u8, functionBits: u8, im5: u8) -> ImArg;
    constructor ImArg::parse(checkByte: u8, reps: u8, dhi: u8, im1: u8, im2 : u8, im3: u8, im4: u8, im5: u8) -> ImArg;
    fn ImArg::check_byte(&self) -> u8; alias checkByte;
    fn ImArg::reps(&self) -> u8;
    fn ImArg::dhi(&self) -> u8;
    fn ImArg::address(&self) -> u16;
    fn ImArg::function_type(&self) -> u8; alias functionType;
    fn ImArg::function_bits(&self) -> u8; alias functionBits;
    fn ImArg::im1(&self) -> u8;
    fn ImArg::im2(&self) -> u8;
    fn ImArg::im3(&self) -> u8;
    fn ImArg::im4(&self) -> u8;
    fn ImArg::im5(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataTime(FastClock, TrkArg, IdArg);

impl WrSlDataTime {
    pub fn new(fast_clock: FastClock, trk_arg: TrkArg, id_arg: IdArg) -> Self {
        WrSlDataTime(fast_clock, trk_arg, id_arg)
    }

    pub fn parse(clk_rate: u8, frac_minsh: u8, frac_minsl: u8, mins: u8, trk: u8, hours: u8, days: u8, clk_cntr: u8, id1: u8, id2: u8) -> Self {
        WrSlDataTime(FastClock::parse(clk_rate, frac_minsl, frac_minsh, mins, hours, days, clk_cntr),
                     TrkArg::parse(trk),
                     IdArg::parse(id1, id2))
    }

    pub fn fast_clock(&self) -> FastClock {
        self.0
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.1
    }

    pub fn id_arg(&self) -> IdArg {
        self.2
    }
}

foreign_class!(class WrSlDataTime {
    self_type WrSlDataTime;
    constructor WrSlDataTime::new(fastClock: FastClock, trkArg: TrkArg, idArg: IdArg) -> WrSlDataTime;
    fn WrSlDataTime::fast_clock(&self) -> FastClock; alias fastClock;
    fn WrSlDataTime::trk_arg(&self) -> TrkArg; alias trkArg;
    fn WrSlDataTime::id_arg(&self) -> IdArg; alias idArg;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataPt(Pcmd, Hopsa, Lopsa, TrkArg, CvArg, DataArg);

impl WrSlDataPt {
    pub fn new(pcmd: Pcmd, hopsa: Hopsa, lopsa: Lopsa, trk_arg: TrkArg, cv_arg: CvArg, data_arg: DataArg) -> Self {
        WrSlDataPt(pcmd, hopsa, lopsa, trk_arg, cv_arg, data_arg)
    }

    pub fn parse(pcmd: u8, _arg3: u8, hopsa: u8, lopsa: u8, trk: u8, cvh: u8, cvl: u8, data7: u8, _arg10: u8, _arg11: u8) -> Self {
        WrSlDataPt(Pcmd::parse(pcmd), Hopsa::parse(hopsa), Lopsa::parse(lopsa), TrkArg::parse(trk), CvArg::parse(cvh, cvl), DataArg::parse(data7))
    }

    pub fn pcmd(&self) -> Pcmd {
        self.0
    }

    pub fn hopsa(&self) -> Hopsa {
        self.1
    }

    pub fn lopsa(&self) -> Lopsa {
        self.2
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.3
    }

    pub fn cv_arg(&self) -> CvArg {
        self.4
    }

    pub fn data_arg(&self) -> DataArg {
        self.5
    }
}

foreign_class!(class WrSlDataPt {
    self_type WrSlDataPt;
    constructor WrSlDataPt::new(_: Pcmd, _: Hopsa, _: Lopsa, trkArg: TrkArg, cvArg: CvArg, dataArg: DataArg) -> WrSlDataPt;
    fn WrSlDataPt::pcmd(&self) -> Pcmd;
    fn WrSlDataPt::hopsa(&self) -> Hopsa;
    fn WrSlDataPt::lopsa(&self) -> Lopsa;
    fn WrSlDataPt::trk_arg(&self) -> TrkArg; alias trkArg;
    fn WrSlDataPt::cv_arg(&self) -> CvArg; alias cvArg;
    fn WrSlDataPt::data_arg(&self) -> DataArg; alias dataArg;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataGeneral(SlotArg, Stat1Arg, Stat2Arg, AddressArg, SpeedArg, DirfArg, TrkArg, SndArg, IdArg);

impl WrSlDataGeneral {
    pub fn new(slot_arg: SlotArg, stat1_arg: Stat1Arg, stat2_arg: Stat2Arg, address_arg: AddressArg, speed_arg: SpeedArg, dirf_arg: DirfArg, trk_arg: TrkArg, id_arg: IdArg) -> Self {
        WrSlDataGeneral(slot_arg, stat1_arg, stat2_arg, address_arg, speed_arg, dirf_arg, trk_arg, SndArg(0), id_arg)
    }

    pub fn parse(slot: u8, stat1: u8, adr: u8, spd: u8, dirf: u8, trk: u8, stat2: u8, adr2: u8, snd: u8, id1: u8, id2: u8) -> Self {
        WrSlDataGeneral(SlotArg::parse(slot),
                        Stat1Arg::parse(stat1),
                        Stat2Arg::parse(stat2),
                        AddressArg::parse(adr2, adr),
                        SpeedArg::parse(spd),
                        DirfArg::parse(dirf),
                        TrkArg::parse(trk),
                        SndArg::parse(snd),
                        IdArg::parse(id1, id2))
    }

    pub fn slot_arg(&self) -> SlotArg {
        self.0
    }

    pub fn stat1_arg(&self) -> Stat1Arg {
        self.1
    }

    pub fn stat2_arg(&self) -> Stat2Arg {
        self.2
    }

    pub fn address_arg(&self) -> AddressArg {
        self.3
    }

    pub fn speed_arg(&self) -> SpeedArg {
        self.4
    }

    pub fn dirf_arg(&self) -> DirfArg {
        self.5
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.6
    }

    pub fn snd_arg(&self) -> SndArg {
        self.7
    }

    pub fn id_arg(&self) -> IdArg {
        self.8
    }

    pub fn set_snd_arg(&mut self, snd_arg: SndArg) {
        self.7 = snd_arg;
    }
}

foreign_class!(class WrSlDataGeneral {
    self_type WrSlDataGeneral;
    constructor WrSlDataGeneral::new(_: SlotArg, _: Stat1Arg, _: Stat2Arg, _: AddressArg, _: SpeedArg, _: DirfArg, _: TrkArg, _: IdArg) -> WrSlDataGeneral;
    fn WrSlDataGeneral::slot_arg(&self) -> SlotArg; alias slotArg;
    fn WrSlDataGeneral::stat1_arg(&self) -> Stat1Arg; alias stat1Arg;
    fn WrSlDataGeneral::stat2_arg(&self) -> Stat2Arg; alias stat2Arg;
    fn WrSlDataGeneral::address_arg(&self) -> AddressArg; alias addressArg;
    fn WrSlDataGeneral::speed_arg(&self) -> SpeedArg; alias speedArg;
    fn WrSlDataGeneral::dirf_arg(&self) -> DirfArg; alias dirfArg;
    fn WrSlDataGeneral::trk_arg(&self) -> TrkArg; alias trkArg;
    fn WrSlDataGeneral::snd_arg(&self) -> SndArg; alias sndArg;
    fn WrSlDataGeneral::id_arg(&self) -> IdArg; alias idArg;
    fn WrSlDataGeneral::set_snd_arg(&mut self, _: SndArg); alias setSndArg;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataStructure {
    slot_type: u8,
    time_slot: WrSlDataTime,
    pt_slot: WrSlDataPt,
    general_slot: WrSlDataGeneral
}

impl WrSlDataStructure {
    pub fn new(slot_type: u8, time_slot: WrSlDataTime, pt_slot: WrSlDataPt, general_slot: WrSlDataGeneral) -> Self {
        WrSlDataStructure { slot_type, time_slot, pt_slot, general_slot }
    }

    pub fn parse(arg1: u8, arg2: u8, arg3: u8, arg4: u8, arg5: u8, arg6: u8, arg7: u8, arg8: u8, arg9: u8, arg10: u8, arg11: u8) -> Self {
        let slot_type = if arg1 == 0x7C { 0x7C } else if arg1 == 0x7B { 0x7B } else { 0x00 };

        let time_slot = WrSlDataTime::parse(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        let pt_slot = WrSlDataPt::parse(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        let general_slot = WrSlDataGeneral::parse(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

        WrSlDataStructure{ slot_type, time_slot, pt_slot, general_slot }
    }

    pub fn slot_type(&self) -> u8 {
        self.slot_type
    }

    pub fn time_slot(&self) -> WrSlDataTime {
        self.time_slot
    }

    pub fn pt_slot(&self) -> WrSlDataPt {
        self.pt_slot
    }

    pub fn general_slot(&self) -> WrSlDataGeneral {
        self.general_slot
    }

    pub fn to_message(&self) -> Vec<u8> {
        if self.slot_type == 0x7C {
            return vec![0xEF as u8, 0x0E as u8, 0x7C as u8, self.pt_slot.0.pcmd(), 0x00 as u8, self.pt_slot.1.o_mode(), self.pt_slot.2.o_mode(), self.pt_slot.3.trk_arg(), self.pt_slot.4.cvh(), self.pt_slot.4.cvl(), self.pt_slot.5.data(), 0x00 as u8, 0x00 as u8];
        } else if self.slot_type == 0x7B {
            return vec![0xEF as u8, 0x0E as u8, 0x7B as u8, self.time_slot.0.clk_rate(), self.time_slot.0.frac_minsl(), self.time_slot.0.frac_minsh(), self.time_slot.0.mins(), self.time_slot.1.trk_arg(), self.time_slot.0.hours(), self.time_slot.0.days(), self.time_slot.0.clk_cntrl(), self.time_slot.2.id1(), self.time_slot.2.id2()];
        }
        return vec![0xEF as u8, 0x0E as u8, self.general_slot.0.slot(), self.general_slot.1.stat1(), self.general_slot.3.adr1(), self.general_slot.4.spd(), self.general_slot.5.dirf(), self.general_slot.6.trk_arg(), self.general_slot.2.stat2(), self.general_slot.3.adr2(), self.general_slot.7.snd(), self.general_slot.8.id1(), self.general_slot.8.id2()];
    }
}

foreign_class!(class WrSlDataStructure {
    self_type WrSlDataStructure;
    constructor WrSlDataStructure::new(_: u8, _: WrSlDataTime, _: WrSlDataPt, _: WrSlDataGeneral) -> WrSlDataStructure;
    fn WrSlDataStructure::slot_type(&self) -> u8; alias slotType;
    fn WrSlDataStructure::time_slot(&self) -> WrSlDataTime; alias timeSlot;
    fn WrSlDataStructure::pt_slot(&self) -> WrSlDataPt; alias ptSlot;
    fn WrSlDataStructure::general_slot(&self) -> WrSlDataGeneral; alias generalSlot;
});

#[derive(Debug, Copy, Clone)]
pub struct LissyIrReport {
    arg1: u8,
    dir: bool,
    unit: u16,
    address: u16,
    arg6: u8
}

impl LissyIrReport {
    pub fn new(dir: bool, unit: u16, address: u16, arg6: u8) -> Self {
        LissyIrReport{
            arg1:0x00,
            dir,
            unit,
            address,
            arg6
        }
    }

    pub fn parse(arg1: u8, high_unit: u8, low_unit: u8, high_adr: u8, low_adr: u8, arg6: u8) -> Self {
        assert_eq!(arg1, 0x00, "Given message is not a LissyIR report!");

        let dir = high_unit & 0x40 == 0x40;
        let unit = (((high_unit & 0x3F) as u16) << 7) | (low_unit as u16);
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);

        LissyIrReport{arg1, dir, unit, address, arg6}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let mut high_unit = ((self.unit >> 7) as u8) & 0x3F;
        if self.dir {
            high_unit |= 0x40;
        }
        let low_unit = self.unit as u8 & 0x7F;
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = self.address as u8 & 0x7F;
        vec![0xE4, 0x08, self.arg1, high_unit, low_unit, high_adr, low_adr, self.arg6]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn arg6(&self) -> u8 {
        self.arg6
    }

    pub fn dir(&self) -> bool {
        self.dir
    }

    pub fn unit(&self) -> u16 {
        self.unit
    }

    pub fn address(&self) -> u16 {
        self.address
    }
}

foreign_class!(class LissyIrReport {
    self_type LissyIrReport;
    constructor LissyIrReport::new(dir: bool, unit: u16, address: u16, arg6: u8) -> LissyIrReport;
    fn LissyIrReport::arg1(&self) -> u8;
    fn LissyIrReport::arg6(&self) -> u8;
    fn LissyIrReport::dir(&self) -> bool;
    fn LissyIrReport::unit(&self) -> u16;
    fn LissyIrReport::address(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct RFID5Report {
    arg1: u8,
    address: u16,
    rfid0: u8,
    rfid1: u8,
    rfid2: u8,
    rfid3: u8,
    rfid4: u8,
    rfid_hi: u8
}

impl RFID5Report {
    pub fn new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> Self {
        RFID5Report{ arg1:0x41, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid_hi }
    }

    pub fn parse(arg1: u8, high_adr: u8, low_adr: u8, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> Self {
        assert_eq!(arg1, 0x41, "Given message is not a RFID-5 report!");
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);
        RFID5Report{ arg1, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid_hi }
    }

    pub fn to_message(&self) -> Vec<u8> {
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = (self.address as u8) & 0x7F;
        vec![0xE4, 0x0C, self.arg1, high_adr, low_adr, self.rfid0, self.rfid1, self.rfid2, self.rfid3, self.rfid4, self.rfid_hi]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn rfid0(&self) -> u8 {
        self.rfid0
    }

    pub fn rfid1(&self) -> u8 {
        self.rfid1
    }

    pub fn rfid2(&self) -> u8 {
        self.rfid2
    }

    pub fn rfid3(&self) -> u8 {
        self.rfid3
    }

    pub fn rfid4(&self) -> u8 {
        self.rfid4
    }

    pub fn rfid_hi(&self) -> u8 {
        self.rfid_hi
    }
}

foreign_class!(class RFID5Report {
    self_type RFID5Report;
    constructor RFID5Report::new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfidHi: u8) -> RFID5Report;
    fn RFID5Report::arg1(&self) -> u8;
    fn RFID5Report::rfid0(&self) -> u8;
    fn RFID5Report::rfid1(&self) -> u8;
    fn RFID5Report::rfid2(&self) -> u8;
    fn RFID5Report::rfid3(&self) -> u8;
    fn RFID5Report::rfid4(&self) -> u8;
    fn RFID5Report::rfid_hi(&self) -> u8; alias rfidHi;
    fn RFID5Report::address(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct RFID7Report {
    arg1: u8,
    address: u16,
    rfid0: u8,
    rfid1: u8,
    rfid2: u8,
    rfid3: u8,
    rfid4: u8,
    rfid5: u8,
    rfid6: u8,
    rfid_hi: u8
}

impl RFID7Report {
    pub fn new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> Self {
        RFID7Report{ arg1:0x41, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid5, rfid6, rfid_hi }
    }

    pub fn parse(arg1: u8, high_adr: u8, low_adr: u8, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> Self {
        assert_eq!(arg1, 0x41, "Given message is not a RFID-7 report!");
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);
        RFID7Report{arg1, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid5, rfid6, rfid_hi}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = (self.address as u8) & 0x7F;
        vec![0xE4, 0x0E, self.arg1, high_adr, low_adr, self.rfid0, self.rfid1, self.rfid2, self.rfid3, self.rfid4, self.rfid5, self.rfid6, self.rfid_hi]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn rfid0(&self) -> u8 {
        self.rfid0
    }

    pub fn rfid1(&self) -> u8 {
        self.rfid1
    }

    pub fn rfid2(&self) -> u8 {
        self.rfid2
    }

    pub fn rfid3(&self) -> u8 {
        self.rfid3
    }

    pub fn rfid4(&self) -> u8 {
        self.rfid4
    }

    pub fn rfid5(&self) -> u8 {
        self.rfid5
    }

    pub fn rfid6(&self) -> u8 {
        self.rfid6
    }

    pub fn rfid_hi(&self) -> u8 {
        self.rfid_hi
    }
}

foreign_class!(class RFID7Report {
    self_type RFID7Report;
    constructor RFID7Report::new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> RFID7Report;
    fn RFID7Report::arg1(&self) -> u8;
    fn RFID7Report::rfid0(&self) -> u8;
    fn RFID7Report::rfid1(&self) -> u8;
    fn RFID7Report::rfid2(&self) -> u8;
    fn RFID7Report::rfid3(&self) -> u8;
    fn RFID7Report::rfid4(&self) -> u8;
    fn RFID7Report::rfid5(&self) -> u8;
    fn RFID7Report::rfid6(&self) -> u8;
    fn RFID7Report::rfid_hi(&self) -> u8; alias rfidHi;
    fn RFID7Report::address(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct WheelcntReport {
    arg1: u8,
    unit: u16,
    direction: bool,
    count: u16,
    arg6: u8
}

impl WheelcntReport {
    pub fn new(unit: u16, direction: bool, count: u16, arg6: u8) -> Self {
        WheelcntReport{ arg1:0x40, unit, direction, count, arg6 }
    }

    pub fn parse(arg1: u8, high_unit: u8, low_unit: u8, high_count: u8, low_count: u8, arg6: u8) -> Self {
        assert_eq!(arg1, 0x40, "Given message is not a wheelcnt report!");
        let count = ((high_count as u16) << 7) | (low_count as u16);
        let direction = high_unit & 0x40 == 0x40;
        let unit = (((high_unit & 0x3F) as u16) << 7) | (low_unit as u16);
        WheelcntReport{arg1, unit, direction, count, arg6}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let mut high_unit = ((self.unit >> 7) as u8) & 0x3F;
        if self.direction {
            high_unit |= 0x40;
        }
        let low_unit = self.unit as u8 & 0x7F;
        let high_count = ((self.count >> 7) as u8) & 0x7F;
        let low_count = self.count as u8 & 0x7F;
        vec![0xE4, 0x08, self.arg1, high_unit, low_unit, high_count, low_count, self.arg6]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn arg6(&self) -> u8 {
        self.arg6
    }

    pub fn unit(&self) -> u16 {
        self.unit
    }

    pub fn count(&self) -> u16 {
        self.count
    }

    pub fn direction(&self) -> bool {
        self.direction
    }
}

foreign_class!(class WheelcntReport {
    self_type WheelcntReport;
    constructor WheelcntReport::new(unit: u16, direction: bool, count: u16, arg6: u8) -> WheelcntReport;
    fn WheelcntReport::arg1(&self) -> u8;
    fn WheelcntReport::arg6(&self) -> u8;
    fn WheelcntReport::unit(&self) -> u16;
    fn WheelcntReport::count(&self) -> u16;
    fn WheelcntReport::direction(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub enum RepStructure {
    LissyIrReport(LissyIrReport),
    RFID5Report(RFID5Report),
    RFID7Report(RFID7Report),
    WheelcntReport(WheelcntReport)
}

impl RepStructure {
    pub fn new_lissy_ir(rep: LissyIrReport) -> Self {
        RepStructure::LissyIrReport(rep)
    }

    pub fn new_rfid_5(rep: RFID5Report, _b1: bool) -> Self {
        RepStructure::RFID5Report(rep)
    }

    pub fn new_rfid_7(rep: RFID7Report, _b1: bool, _b2: bool) -> Self {
        RepStructure::RFID7Report(rep)
    }

    pub fn new_wheelcnt(rep: WheelcntReport, _b1: bool, _b2: bool, _b3: bool) -> Self {
        RepStructure::WheelcntReport(rep)
    }

    pub fn parse(count: u8, args: &[u8]) -> Self {
        return if args[0] == 0x00 {
            Self::LissyIrReport(LissyIrReport::parse(args[0], args[1], args[2], args[3], args[4], args[5]))
        } else if args[0] == 0x40 {
            Self::WheelcntReport(WheelcntReport::parse(args[0], args[1], args[2], args[3], args[4], args[5]))
        } else if args[0] == 0x41 && count == 0x0C {
            Self::RFID5Report(RFID5Report::parse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]))
        } else {
            Self::RFID7Report(RFID7Report::parse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]))
        }
    }

    pub fn get_type(&self) -> u8 {
        match self {
            Self::LissyIrReport(_) => 0,
            Self::RFID5Report(_) => 1,
            Self::RFID7Report(_) => 2,
            Self::WheelcntReport(_) => 3,
        }
    }

    pub fn get_lissy_ir_report(&self) -> LissyIrReport {
        match self {
            Self::LissyIrReport(rep) => *rep,
            Self::RFID5Report(_) => panic!("This information is not available!"),
            Self::RFID7Report(_) => panic!("This information is not available!"),
            Self::WheelcntReport(_) => panic!("This information is not available!"),
        }
    }

    pub fn get_rfid5_report(&self) -> RFID5Report {
        match self {
            Self::LissyIrReport(_) => panic!("This information is not available!"),
            Self::RFID5Report(rep) => *rep,
            Self::RFID7Report(_) => panic!("This information is not available!"),
            Self::WheelcntReport(_) => panic!("This information is not available!"),
        }
    }

    pub fn get_rfid7_report(&self) -> RFID7Report {
        match self {
            Self::LissyIrReport(_) => panic!("This information is not available!"),
            Self::RFID5Report(_) => panic!("This information is not available!"),
            Self::RFID7Report(rep) => *rep,
            Self::WheelcntReport(_) => panic!("This information is not available!"),
        }
    }

    pub fn get_wheelcnt_report(&self) -> WheelcntReport {
        match self {
            Self::LissyIrReport(_) => panic!("This information is not available!"),
            Self::RFID5Report(_) => panic!("This information is not available!"),
            Self::RFID7Report(_) => panic!("This information is not available!"),
            Self::WheelcntReport(rep) => *rep,
        }
    }
}

foreign_class!(class RepStructure {
    self_type RepStructure;
    constructor RepStructure::new_lissy_ir(rep: LissyIrReport) -> RepStructure;
    constructor RepStructure::new_rfid_5(rep: RFID5Report, b1: bool) -> RepStructure;
    constructor RepStructure::new_rfid_7(rep: RFID7Report, b1: bool, b2: bool) -> RepStructure;
    constructor RepStructure::new_wheelcnt(rep: WheelcntReport, b1: bool, b2: bool, b3: bool) -> RepStructure;
    fn RepStructure::get_wheelcnt_report(&self) -> WheelcntReport; alias getWheelcntReport;
    fn RepStructure::get_rfid7_report(&self) -> RFID7Report; alias getRfid7Report;
    fn RepStructure::get_rfid5_report(&self) -> RFID5Report; alias getRfid5Report;
    fn RepStructure::get_lissy_ir_report(&self) -> LissyIrReport; alias getLissyIrReport;
    fn RepStructure::get_type(&self) -> u8; alias getType;
});

#[derive(Debug, Copy, Clone)]
pub struct DstArg(u16);

impl DstArg {
    pub fn new(dst: u16) -> Self {
        DstArg(dst)
    }

    pub fn parse(dst_low: u8, dst_high: u8) -> Self {
        let dst = ((dst_high as u16) << 7) | (dst_low as u16);
        DstArg(dst)
    }

    pub fn dst(&self) -> u16 {
        self.0
    }

    pub fn dst_low(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn dst_high(&self) -> u8 {
        (self.0 >> 7) as u8 & 0x7F
    }
}

foreign_class!(class DstArg {
    self_type DstArg;
    constructor DstArg::new(dst: u16) -> DstArg;
    fn DstArg::dst(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct PxctData {
    pxc: u8,
    d1: u8,
    d2: u8,
    d3: u8,
    d4: u8,
    d5: u8,
    d6: u8,
    d7: u8,
    d8: u8
}

impl PxctData {
    pub fn new(pxc: u8, d1: u8, d2: u8, d3: u8, d4: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> Self {
        PxctData { pxc, d1, d2, d3, d4, d5, d6, d7, d8 }
    }

    pub fn parse(pxct1: u8, d1: u8, d2: u8, d3: u8, d4: u8, pxct2: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> Self {
        let pxc = ((pxct1 & 0x70) >> 4) | ((pxct2 & 0x70) >> 1);

        PxctData{pxc, d1: d1 | ((pxct1 & 0x01) << 7), d2: d2 | ((pxct1 & 0x02) << 6), d3: d3 | ((pxct1 & 0x04) << 5), d4: d4 | ((pxct1 & 0x08) << 4), d5: d5 | ((pxct2 & 0x01) << 7), d6: d6 | ((pxct2 & 0x02) << 6), d7: d7 | ((pxct2 & 0x04) << 5), d8: d8 | ((pxct2 & 0x08) << 4)}
    }

    pub fn pxc(&self) -> u8 {
        self.pxc
    }

    pub fn pxct1(&self) -> u8 {
        let mut pxct1 = self.pxc & 0x07 << 4;

        if self.d1 & 0x40 == 0x40 {
            pxct1 |= 0x01;
        }
        if self.d2 & 0x40 == 0x40 {
            pxct1 |= 0x02;
        }
        if self.d3 & 0x40 == 0x40 {
            pxct1 |= 0x04;
        }
        if self.d4 & 0x40 == 0x40 {
            pxct1 |= 0x08;
        }

        pxct1
    }

    pub fn pxct2(&self) -> u8 {
        let mut pxct1 = self.pxc & 0x78 << 1;

        if self.d5 & 0x40 == 0x40 {
            pxct1 |= 0x01;
        }
        if self.d6 & 0x40 == 0x40 {
            pxct1 |= 0x02;
        }
        if self.d7 & 0x40 == 0x40 {
            pxct1 |= 0x04;
        }
        if self.d8 & 0x40 == 0x40 {
            pxct1 |= 0x08;
        }

        pxct1
    }

    pub fn d1(&self) -> u8 {
        self.d1 & 0x3F
    }

    pub fn d2(&self) -> u8 {
        self.d2 & 0x3F
    }

    pub fn d3(&self) -> u8 {
        self.d3 & 0x3F
    }

    pub fn d4(&self) -> u8 {
        self.d4 & 0x3F
    }

    pub fn d5(&self) -> u8 {
        self.d5 & 0x3F
    }

    pub fn d6(&self) -> u8 {
        self.d6 & 0x3F
    }

    pub fn d7(&self) -> u8 {
        self.d7 & 0x3F
    }

    pub fn d8(&self) -> u8 {
        self.d8 & 0x3F
    }
}

foreign_class!(class PxctData {
    self_type PxctData;
    constructor PxctData::new(pxc: u8, d1: u8, d2: u8, d3: u8, d4: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> PxctData;
    fn PxctData::pxc(&self) -> u8;
    fn PxctData::d1(&self) -> u8;
    fn PxctData::d2(&self) -> u8;
    fn PxctData::d3(&self) -> u8;
    fn PxctData::d4(&self) -> u8;
    fn PxctData::d5(&self) -> u8;
    fn PxctData::d6(&self) -> u8;
    fn PxctData::d7(&self) -> u8;
    fn PxctData::d8(&self) -> u8;
});

pub trait LocoNetMessage {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool;
}

#[derive(Debug, Copy, Clone)]
pub struct Idle();

impl LocoNetMessage for Idle {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x85 as u8])
    }
}

impl Idle {
    pub fn new() -> Self {
        Idle()
    }
}

foreign_class!(class Idle {
    self_type Idle;
    constructor Idle::new() -> Idle;
    fn Idle::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct GpOn();

impl LocoNetMessage for GpOn {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x83 as u8])
    }
}

impl GpOn {
    pub fn new() -> Self {
        GpOn()
    }
}

foreign_class!(class GpOn {
    self_type GpOn;
    constructor GpOn::new() -> GpOn;
    fn GpOn::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct GpOff();

impl LocoNetMessage for GpOff {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x82 as u8])
    }
}

impl GpOff {
    pub fn new() -> Self { GpOff() }
}

foreign_class!(class GpOff {
    self_type GpOff;
    constructor GpOff::new() -> GpOff;
    fn GpOff::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct Busy();

impl LocoNetMessage for Busy {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x81 as u8])
    }
}

impl Busy {
    pub fn new() -> Self { Busy() }
}

foreign_class!(class Busy {
    self_type Busy;
    constructor Busy::new() -> Busy;
    fn Busy::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LocoAdr(AddressArg);

impl LocoNetMessage for LocoAdr {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBF as u8, self.0.adr2(), self.0.adr1()])
    }
}

impl LocoAdr {
    pub fn new(address: AddressArg) -> Self { LocoAdr(address) }
    pub fn get_address(&self) -> AddressArg { self.0 }
}

foreign_class!(class LocoAdr {
    self_type LocoAdr;
    constructor LocoAdr::new(address: AddressArg) -> LocoAdr;
    fn LocoAdr::get_address(&self) -> AddressArg; alias getAddress;
    fn LocoAdr::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SwAck(SwitchArg);

impl LocoNetMessage for SwAck {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBD as u8, self.0.sw1(), self.0.sw2()])
    }
}

impl SwAck {
    pub fn new(sw: SwitchArg) -> Self { SwAck(sw) }
    pub fn get_switch(&self) -> SwitchArg { self.0 }
}

foreign_class!(class SwAck {
    self_type SwAck;
    constructor SwAck::new(sw: SwitchArg) -> SwAck;
    fn SwAck::get_switch(&self) -> SwitchArg; alias getSwitch;
    fn SwAck::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SwState(SwitchArg);

impl LocoNetMessage for SwState {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBC as u8, self.0.sw1(), self.0.sw2()])
    }
}

impl SwState {
    pub fn new(sw: SwitchArg) -> Self { SwState(sw) }
    pub fn get_switch(&self) -> SwitchArg { self.0 }
}

foreign_class!(class SwState {
    self_type SwState;
    constructor SwState::new(sw: SwitchArg) -> SwState;
    fn SwState::get_switch(&self) -> SwitchArg; alias getSwitch;
    fn SwState::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct RqSlData(SlotArg);

impl LocoNetMessage for RqSlData {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBB as u8, self.0.slot(), 0x00 as u8])
    }
}

impl RqSlData {
    pub fn new(slot: SlotArg) -> Self { RqSlData(slot) }
    pub fn get_slot(&self) -> SlotArg { self.0 }
}

foreign_class!(class RqSlData {
    self_type RqSlData;
    constructor RqSlData::new(slot: SlotArg) -> RqSlData;
    fn RqSlData::get_slot(&self) -> SlotArg; alias getSlot;
    fn RqSlData::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct MoveSlots(SlotArg, SlotArg);

impl LocoNetMessage for MoveSlots {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBA as u8, self.0.slot(), self.1.slot()])
    }
}

impl MoveSlots {
    pub fn new(slot_from: SlotArg, slot_to: SlotArg) -> Self {
        MoveSlots(slot_from, slot_to)
    }
    pub fn get_slot_from(&self) -> SlotArg { self.0 }
    pub fn get_slot_to(&self) -> SlotArg { self.1 }
}

foreign_class!(class MoveSlots {
    self_type MoveSlots;
    constructor MoveSlots::new(slotFrom: SlotArg, slotTo: SlotArg) -> MoveSlots;
    fn MoveSlots::get_slot_from(&self) -> SlotArg; alias getSlotFrom;
    fn MoveSlots::get_slot_to(&self) -> SlotArg; alias getSlotTo;
    fn MoveSlots::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LinkSlots(SlotArg, SlotArg);

impl LocoNetMessage for LinkSlots {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB9 as u8, self.0.slot(), self.1.slot()])
    }
}

impl LinkSlots {
    pub fn new(slot1: SlotArg, slot2: SlotArg) -> Self {
        LinkSlots(slot1, slot2)
    }
    pub fn get_slot1(&self) -> SlotArg { self.0 }
    pub fn get_slot2(&self) -> SlotArg { self.1 }
}

foreign_class!(class LinkSlots {
    self_type LinkSlots;
    constructor LinkSlots::new(slot1: SlotArg, slot2: SlotArg) -> LinkSlots;
    fn LinkSlots::get_slot1(&self) -> SlotArg; alias getSlot1;
    fn LinkSlots::get_slot2(&self) -> SlotArg; alias getSlot2;
    fn LinkSlots::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct UnlinkSlots(SlotArg, SlotArg);

impl LocoNetMessage for UnlinkSlots {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB8 as u8, self.0.slot(), self.1.slot()])
    }
}

impl UnlinkSlots {
    pub fn new(slot1: SlotArg, slot2: SlotArg) -> Self {
        UnlinkSlots(slot1, slot2)
    }
    pub fn get_slot1(&self) -> SlotArg { self.0 }
    pub fn get_slot2(&self) -> SlotArg { self.1 }
}

foreign_class!(class UnlinkSlots {
    self_type UnlinkSlots;
    constructor UnlinkSlots::new(slot1: SlotArg, slot2: SlotArg) -> UnlinkSlots;
    fn UnlinkSlots::get_slot1(&self) -> SlotArg; alias getSlot1;
    fn UnlinkSlots::get_slot2(&self) -> SlotArg; alias getSlot2;
    fn UnlinkSlots::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct ConsistFunc(SlotArg, DirfArg);

impl LocoNetMessage for ConsistFunc {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB6 as u8, self.0.slot(), self.1.dirf()])
    }
}

impl ConsistFunc {
    pub fn new(slot: SlotArg, dirf: DirfArg) -> Self {
        ConsistFunc(slot, dirf)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_dirf(&self) -> DirfArg { self.1 }
}

foreign_class!(class ConsistFunc {
    self_type ConsistFunc;
    constructor ConsistFunc::new(slot: SlotArg, dirf: DirfArg) -> ConsistFunc;
    fn ConsistFunc::get_slot(&self) -> SlotArg; alias getSlot;
    fn ConsistFunc::get_dirf(&self) -> DirfArg; alias getDirf;
    fn ConsistFunc::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SlotStat1(SlotArg, Stat1Arg);

impl LocoNetMessage for SlotStat1 {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB5 as u8, self.0.slot(), self.1.stat1()])
    }
}

impl SlotStat1 {
    pub fn new(slot: SlotArg, stat1: Stat1Arg) -> Self {
        SlotStat1(slot, stat1)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_stat1(&self) -> Stat1Arg { self.1 }
}

foreign_class!(class SlotStat1 {
    self_type SlotStat1;
    constructor SlotStat1::new(slot: SlotArg, dirf: Stat1Arg) -> SlotStat1;
    fn SlotStat1::get_slot(&self) -> SlotArg; alias getSlot;
    fn SlotStat1::get_stat1(&self) -> Stat1Arg; alias getStat1;
    fn SlotStat1::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LongAck(LopcArg, Ack1Arg);

impl LocoNetMessage for LongAck {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB4 as u8, self.0.lopc(), self.1.ack1()])
    }
}

impl LongAck {
    pub fn new(lopc: LopcArg, ack1: Ack1Arg) -> Self {
        LongAck(lopc, ack1)
    }
    pub fn get_lopc(&self) -> LopcArg { self.0 }
    pub fn get_ack1(&self) -> Ack1Arg { self.1 }
}

foreign_class!(class LongAck {
    self_type LongAck;
    constructor LongAck::new(lopc: LopcArg, ack1: Ack1Arg) -> LongAck;
    fn LongAck::get_lopc(&self) -> LopcArg; alias getLopc;
    fn LongAck::get_ack1(&self) -> Ack1Arg; alias getAck1;
    fn LongAck::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct InputRep(InArg);

impl LocoNetMessage for InputRep {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB2 as u8, self.0.in1(), self.0.in2()])
    }
}

impl InputRep {
    pub fn new(in_arg: InArg) -> Self {
        InputRep(in_arg)
    }
    pub fn get_in_arg(&self) -> InArg { self.0 }
}

foreign_class!(class InputRep {
    self_type InputRep;
    constructor InputRep::new(inArg: InArg) -> InputRep;
    fn InputRep::get_in_arg(&self) -> InArg; alias getInArg;
    fn InputRep::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SwRep(SnArg);

impl LocoNetMessage for SwRep {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB1 as u8, self.0.sn1(), self.0.sn2()])
    }
}

impl SwRep {
    pub fn new(sn_arg: SnArg) -> Self {
        SwRep(sn_arg)
    }
    pub fn get_sn_arg(&self) -> SnArg { self.0 }
}

foreign_class!(class SwRep {
    self_type SwRep;
    constructor SwRep::new(snArg: SnArg) -> SwRep;
    fn SwRep::get_sn_arg(&self) -> SnArg; alias getSnArg;
    fn SwRep::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SwReq(SwitchArg);

impl LocoNetMessage for SwReq {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB0 as u8, self.0.sw1(), self.0.sw2()])
    }
}

impl SwReq {
    pub fn new(switch_arg: SwitchArg) -> Self {
        SwReq(switch_arg)
    }
    pub fn get_switch_arg(&self) -> SwitchArg { self.0 }
}

foreign_class!(class SwReq {
    self_type SwReq;
    constructor SwReq::new(switchArg: SwitchArg) -> SwReq;
    fn SwReq::get_switch_arg(&self) -> SwitchArg; alias getSwitchArg;
    fn SwReq::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LocoSnd(SlotArg, SndArg);

impl LocoNetMessage for LocoSnd {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xA2 as u8, self.0.slot(), self.1.snd()])
    }
}

impl LocoSnd {
    pub fn new(slot: SlotArg, snd: SndArg) -> Self {
        LocoSnd(slot, snd)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_snd(&self) -> SndArg { self.1 }
}

foreign_class!(class LocoSnd {
    self_type LocoSnd;
    constructor LocoSnd::new(slot: SlotArg, snd: SndArg) -> LocoSnd;
    fn LocoSnd::get_slot(&self) -> SlotArg; alias getSlot;
    fn LocoSnd::get_snd(&self) -> SndArg; alias getSnd;
    fn LocoSnd::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LocoDirf(SlotArg, DirfArg);

impl LocoNetMessage for LocoDirf {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xA1 as u8, self.0.slot(), self.1.dirf()])
    }
}

impl LocoDirf {
    pub fn new(slot: SlotArg, dirf: DirfArg) -> Self {
        LocoDirf(slot, dirf)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_dirf(&self) -> DirfArg { self.1 }
}

foreign_class!(class LocoDirf {
    self_type LocoDirf;
    constructor LocoDirf::new(slot: SlotArg, dirf: DirfArg) -> LocoDirf;
    fn LocoDirf::get_slot(&self) -> SlotArg; alias getSlot;
    fn LocoDirf::get_dirf(&self) -> DirfArg; alias getDirf;
    fn LocoDirf::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LocoSpd(SlotArg, SpeedArg);

impl LocoNetMessage for LocoSpd {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xA0 as u8, self.0.slot(), self.1.spd()])
    }
}

impl LocoSpd {
    pub fn new_easy(slot: SlotArg, spd: u16) -> Self {
        LocoSpd(slot, SpeedArg::parse(spd as u8))
    }
    pub fn new(slot: SlotArg, spd: SpeedArg) -> Self {
        LocoSpd(slot, spd)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_spd(&self) -> SpeedArg { self.1 }
}

foreign_class!(class LocoSpd {
    self_type LocoSpd;
    constructor LocoSpd::new(slot: SlotArg, spd: SpeedArg) -> LocoSpd;
    constructor LocoSpd::new_easy(slot: SlotArg, spd: u16) -> LocoSpd;
    fn LocoSpd::get_slot(&self) -> SlotArg; alias getSlot;
    fn LocoSpd::get_spd(&self) -> SpeedArg; alias getSpd;
    fn LocoSpd::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct MultiSense(MTypeArg, ZasArg, SenseAddrArg);

impl LocoNetMessage for MultiSense {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xD0 as u8, self.0.m_type(), self.1.zas(), self.2.addr1(), self.2.addr2()])
    }
}

impl MultiSense {
    pub fn new(m_type: MTypeArg, zas: ZasArg, sense_adr: SenseAddrArg) -> Self {
        MultiSense(m_type, zas, sense_adr)
    }
    pub fn get_m_type(&self) -> MTypeArg { self.0 }
    pub fn get_zas(&self) -> ZasArg { self.1 }
    pub fn get_sense_adr(&self) -> SenseAddrArg { self.2 }
}

foreign_class!(class MultiSense {
    self_type MultiSense;
    constructor MultiSense::new(m_type: MTypeArg, zas: ZasArg, senseAdr: SenseAddrArg) -> MultiSense;
    fn MultiSense::get_m_type(&self) -> MTypeArg; alias getMType;
    fn MultiSense::get_zas(&self) -> ZasArg; alias getZas;
    fn MultiSense::get_sense_adr(&self) -> SenseAddrArg; alias getSenseArg;
    fn MultiSense::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct UhliFun(SlotArg, FunctionArg);

impl LocoNetMessage for UhliFun {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xD4 as u8, 0x20 as u8, self.0.slot(), self.1.group(), self.1.function()])
    }
}

impl UhliFun {
    pub fn new(slot: SlotArg, function: FunctionArg) -> Self {
        UhliFun(slot, function)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_function(&self) -> FunctionArg { self.1 }
}

foreign_class!(class UhliFun {
    self_type UhliFun;
    constructor UhliFun::new(slot: SlotArg, function: FunctionArg) -> UhliFun;
    fn UhliFun::get_slot(&self) -> SlotArg; alias getSlot;
    fn UhliFun::get_function(&self) -> FunctionArg; alias getFunction;
    fn UhliFun::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlData(WrSlDataStructure);

impl LocoNetMessage for WrSlData {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(self.0.to_message())
    }
}

impl WrSlData {
    pub fn new(slot_data: WrSlDataStructure) -> Self {
        WrSlData(slot_data)
    }
    pub fn get_slot_data_structure(&self) -> WrSlDataStructure { self.0 }
}

foreign_class!(class WrSlData {
    self_type WrSlData;
    constructor WrSlData::new(slotData: WrSlDataStructure) -> WrSlData;
    fn WrSlData::get_slot_data_structure(&self) -> WrSlDataStructure; alias getSlotDataStructure;
    fn WrSlData::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SlRdData(SlotArg, Stat1Arg, AddressArg, SpeedArg, DirfArg, TrkArg, Stat2Arg, SndArg, IdArg);

impl LocoNetMessage for SlRdData {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xE7 as u8, 0x0E as u8, self.0.slot(), self.1.stat1(), self.2.adr1(), self.3.spd(), self.4.dirf(), self.5.trk_arg(),
                                  self.6.stat2(), self.2.adr2(), self.7.snd(), self.8.id1(), self.8.id2()])
    }
}

impl SlRdData {
    pub fn new(slot: SlotArg, stat1: Stat1Arg, address: AddressArg, speed: SpeedArg, dirf: DirfArg, trk: TrkArg, stat2: Stat2Arg, id: IdArg) -> Self {
        SlRdData(slot, stat1, address, speed, dirf, trk, stat2, SndArg::parse(0), id)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_stat1(&self) -> Stat1Arg { self.1 }
    pub fn get_address(&self) -> AddressArg { self.2 }
    pub fn get_speed(&self) -> SpeedArg { self.3 }
    pub fn get_dirf(&self) -> DirfArg { self.4 }
    pub fn get_trk(&self) -> TrkArg { self.5 }
    pub fn get_stat2(&self) -> Stat2Arg { self.6 }
    pub fn get_snd(&self) -> SndArg { self.7 }
    pub fn get_id(&self) -> IdArg { self.8 }
}

foreign_class!(class SlRdData {
    self_type SlRdData;
    constructor SlRdData::new(slot: SlotArg, stat1: Stat1Arg, address: AddressArg, speed: SpeedArg, dirf: DirfArg, trk: TrkArg, stat2: Stat2Arg, id: IdArg) -> SlRdData;
    fn SlRdData::get_slot(&self) -> SlotArg; alias getSlot;
    fn SlRdData::get_stat1(&self) -> Stat1Arg; alias getStat1;
    fn SlRdData::get_address(&self) -> AddressArg; alias getAddress;
    fn SlRdData::get_speed(&self) -> SpeedArg; alias getSpeed;
    fn SlRdData::get_dirf(&self) -> DirfArg; alias getDirf;
    fn SlRdData::get_trk(&self) -> TrkArg; alias getTrk;
    fn SlRdData::get_stat2(&self) -> Stat2Arg; alias getStat2;
    fn SlRdData::get_snd(&self) -> SndArg; alias getSnd;
    fn SlRdData::get_id(&self) -> IdArg; alias getId;
    fn SlRdData::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct ImmPacket(ImArg);

impl LocoNetMessage for ImmPacket {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xED as u8, 0x0B as u8, 0x7F as u8, self.0.reps(), self.0.dhi(), self.0.im1(), self.0.im2(), self.0.im3(), self.0.im4(), self.0.im5()])
    }
}

impl ImmPacket {
    pub fn new(im_arg: ImArg) -> Self {
        ImmPacket(im_arg)
    }
    pub fn get_im_arg(&self) -> ImArg { self.0 }
}

foreign_class!(class ImmPacket {
    self_type ImmPacket;
    constructor ImmPacket::new(imArg: ImArg) -> ImmPacket;
    fn ImmPacket::get_im_arg(&self) -> ImArg; alias getImArg;
    fn ImmPacket::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct Rep(RepStructure);

impl LocoNetMessage for Rep {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(match self.0 {
            RepStructure::RFID7Report(report) => report.to_message(),
            RepStructure::RFID5Report(report) => report.to_message(),
            RepStructure::LissyIrReport(report) => report.to_message(),
            RepStructure::WheelcntReport(report) => report.to_message(),
        })
    }
}

impl Rep {
    pub fn new(rep: RepStructure) -> Self {
        Rep(rep)
    }
    pub fn get_rep(&self) -> RepStructure { self.0 }
}

foreign_class!(class Rep {
    self_type Rep;
    constructor Rep::new(rep: RepStructure) -> Rep;
    fn Rep::get_rep(&self) -> RepStructure; alias getRep;
    fn Rep::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct PeerXfer(SlotArg, DstArg, PxctData);

impl LocoNetMessage for PeerXfer {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xE5, 0x10, self.0.slot(), self.1.dst_low(), self.1.dst_high(), self.2.pxct1(), self.2.d1(), self.2.d2(), self.2.d3(), self.2.d4(), self.2.pxct2(), self.2.d5(), self.2.d6(), self.2.d7(), self.2.d8()])
    }
}

impl PeerXfer {
    pub fn new(slot: SlotArg, dst: DstArg, pxct: PxctData) -> Self {
        PeerXfer(slot, dst, pxct)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_dst(&self) -> DstArg { self.1 }
    pub fn get_pxct(&self) -> PxctData { self.2 }
}

foreign_class!(class PeerXfer {
    self_type PeerXfer;
    constructor PeerXfer::new(slot: SlotArg, dst: DstArg, pxct: PxctData) -> PeerXfer;
    fn PeerXfer::get_slot(&self) -> SlotArg; alias getSlot;
    fn PeerXfer::get_dst(&self) -> DstArg; alias getDst;
    fn PeerXfer::get_pxct(&self) -> PxctData; alias getPxct;
    fn PeerXfer::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
});

pub fn get_all_ports() -> Vec<String> {
    serialport::available_ports().expect("No ports found").into_iter().map(|port_info| port_info.port_name).collect()
}

foreign_class!(class PortInfos {
    fn get_all_ports() -> Vec<String>; alias getAllPorts;
});

#[repr(u8)]
#[derive(Debug, Copy, Clone)]
pub enum Message {
    Idle(Idle),
    GpOn(GpOn),
    GpOff(GpOff),
    Busy(Busy),

    LocoAdr(LocoAdr),
    SwAck(SwAck),
    SwState(SwState),
    RqSlData(RqSlData),
    MoveSlots(MoveSlots),
    LinkSlots(LinkSlots),
    UnlinkSlots(UnlinkSlots),
    ConsistFunc(ConsistFunc),
    SlotStat1(SlotStat1),
    LongAck(LongAck),
    InputRep(InputRep),
    SwRep(SwRep),
    SwReq(SwReq),
    LocoSnd(LocoSnd),
    LocoDirf(LocoDirf),
    LocoSpd(LocoSpd),
    MultiSense(MultiSense),
    UhliFun(UhliFun),
    WrSlData(WrSlData),
    SlRdData(SlRdData),
    ImmPacket(ImmPacket),
    Rep(Rep),
    PeerXfer(PeerXfer),
}

impl Message {
    pub fn get_message_type(&self) -> u8 {
        match self {
            Message::Idle(_) => 0,
            Message::GpOn(_) => 1,
            Message::GpOff(_) => 2,
            Message::Busy(_) => 3,
            Message::LocoAdr(_) => 4,
            Message::SwAck(_) => 5,
            Message::SwState(_) => 6,
            Message::RqSlData(_) => 7,
            Message::MoveSlots(_) => 8,
            Message::LinkSlots(_) => 9,
            Message::UnlinkSlots(_) => 10,
            Message::ConsistFunc(_) => 11,
            Message::SlotStat1(_) => 12,
            Message::LongAck(_) => 13,
            Message::InputRep(_) => 14,
            Message::SwRep(_) => 15,
            Message::SwReq(_) => 16,
            Message::LocoSnd(_) => 17,
            Message::LocoDirf(_) => 18,
            Message::LocoSpd(_) => 19,
            Message::MultiSense(_) => 20,
            Message::UhliFun(_) => 21,
            Message::WrSlData(_) => 22,
            Message::SlRdData(_) => 23,
            Message::ImmPacket(_) => 24,
            Message::Rep(_) => 25,
            Message::PeerXfer(_) => 26,
        }
    }

    pub fn lack_follows(&self) -> bool {
        match self {
            Message::LocoAdr(_) => true,
            Message::SwAck(_) => true,
            Message::SwState(_) => true,
            Message::SwReq(_) => true,
            Message::WrSlData(_) => true,
            Message::ImmPacket(_) => true,
            _ => false
        }
    }

    pub fn get_idle(&self) -> Idle {
        match *self {
            Message::Idle(idle) => idle,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_gp_on(&self) -> GpOn {
        match *self {
            Message::GpOn(gpon) => gpon,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_gp_off(&self) -> GpOff {
        match *self {
            Message::GpOff(gpoff) => gpoff,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_busy(&self) -> Busy {
        match *self {
            Message::Busy(busy) => busy,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_adr(&self) -> LocoAdr {
        match *self {
            Message::LocoAdr(adr) => adr,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_ack(&self) -> SwAck {
        match *self {
            Message::SwAck(sw_ack) => sw_ack,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_state(&self) -> SwState {
        match *self {
            Message::SwState(sw_state) => sw_state,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_rq_sl_data(&self) -> RqSlData {
        match *self {
            Message::RqSlData(rq_sl_data) => rq_sl_data,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_move_slots(&self) -> MoveSlots {
        match *self {
            Message::MoveSlots(move_slots) => move_slots,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_link_slots(&self) -> LinkSlots {
        match *self {
            Message::LinkSlots(link_slots) => link_slots,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_unlink_slots(&self) -> UnlinkSlots {
        match *self {
            Message::UnlinkSlots(unlink_slots) => unlink_slots,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_consist_func(&self) -> ConsistFunc {
        match *self {
            Message::ConsistFunc(consist_func) => consist_func,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_slot_stat1(&self) -> SlotStat1 {
        match *self {
            Message::SlotStat1(slot_stat1) => slot_stat1,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_long_ack(&self) -> LongAck {
        match *self {
            Message::LongAck(long_ack) => long_ack,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_input_rep(&self) -> InputRep {
        match *self {
            Message::InputRep(input_rep) => input_rep,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_rep(&self) -> SwRep {
        match *self {
            Message::SwRep(sw_rep) => sw_rep,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_req(&self) -> SwReq {
        match *self {
            Message::SwReq(sw_req) => sw_req,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_snd(&self) -> LocoSnd {
        match *self {
            Message::LocoSnd(loco_snd) => loco_snd,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_dirf(&self) -> LocoDirf {
        match *self {
            Message::LocoDirf(loco_dirf) => loco_dirf,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_spd(&self) -> LocoSpd {
        match *self {
            Message::LocoSpd(loco_spd) => loco_spd,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_multi_sense(&self) -> MultiSense {
        match *self {
            Message::MultiSense(multi_sense) => multi_sense,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_uhli_fun(&self) -> UhliFun {
        match *self {
            Message::UhliFun(uhli_fun) => uhli_fun,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_wr_sl_data(&self) -> WrSlData {
        match *self {
            Message::WrSlData(wr_sl_data) => wr_sl_data,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sl_rd_data(&self) -> SlRdData {
        match *self {
            Message::SlRdData(sl_rd_data) => sl_rd_data,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_imm_packet(&self) -> ImmPacket {
        match *self {
            Message::ImmPacket(imm_packet) => imm_packet,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_rep(&self) -> Rep {
        match *self {
            Message::Rep(rep) => rep,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_peer_xfer(&self) -> PeerXfer {
        match *self {
            Message::PeerXfer(peer_xfer) => peer_xfer,
            _ => { panic!("Could not load message") },
        }
    }
}

foreign_class!(
/// This class represents a loco net message. Its type can be found out by calling getMessageType. This class is a bridge for rust and java messages, to dont lose the type data.
class Message {
    self_type Message;
    private constructor = empty;
    /// The type of the loco net message
    /// 0 - Idle,<br>
    /// 1 - GpOn,<br>
    /// 2 - GpOff,<br>
    /// 3 - Busy,<br>
    /// 4 - LocoAdr,<br>
    /// 5 - SwAck,<br>
    /// 6 - SwState,
    /// 7 - RqSlData,
    /// 8 - MoveSlots,
    /// 9 - LinkSlots,
    /// 10 - UnlinkSlots,
    /// 11 - ConsistFunc,
    /// 12 - SlotStat1,
    /// 13 - LongAck,
    /// 14 - InputRep,
    /// 15 - SwRep,
    /// 16 - SwReq,
    /// 17 - LocoSnd,
    /// 18 - LocoDirf,
    /// 19 - LocoSpd,
    /// 20 - MultiSense,
    /// 21 - UhliFun,
    /// 22 - WrSlData,
    /// 23 - SlRdData,
    /// 24 - ImmPacket,
    /// 25 - Rep,
    /// 26 - PeerXfer,
    /// @return The loco net message type
    fn Message::get_message_type(&self) -> u8; alias getMessageType;
    /// @return The Idle message if this message is an Idle message
    fn Message::get_idle(&self) -> Idle; alias getIdle;
    /// @return The GpOn message if this message is an GpOn message
    fn Message::get_gp_on(&self) -> GpOn; alias getGpOn;
    /// @return The GpOff message if this message is an GpOff message
    fn Message::get_gp_off(&self) -> GpOff; alias getGpOff;
    /// @return The Busy message if this message is an Busy message
    fn Message::get_busy(&self) -> Busy; alias getBusy;
    /// @return The LocoAdr message if this message is an LocoAdr message
    fn Message::get_loco_adr(&self) -> LocoAdr; alias getLocoAdr;
    /// @return The SwAck message if this message is an SwAck message
    fn Message::get_sw_ack(&self) -> SwAck; alias getSwAck;
    /// @return The SwState message if this message is an SwState message
    fn Message::get_sw_state(&self) -> SwState; alias getSwState;
    /// @return The RqSlData message if this message is an RqSlData message
    fn Message::get_rq_sl_data(&self) -> RqSlData; alias getRqSlData;
    /// @return The MoveSlots message if this message is an MoveSlots message
    fn Message::get_move_slots(&self) -> MoveSlots; alias getMoveSlots;
    /// @return The LinkSlots message if this message is an LinkSlots message
    fn Message::get_link_slots(&self) -> LinkSlots; alias getLinkSlots;
    /// @return The UnlinkSlots message if this message is an UnlinkSlots message
    fn Message::get_unlink_slots(&self) -> UnlinkSlots; alias getUnlinkSlots;
    /// @return The ConsistFunc message if this message is an ConsistFunc message
    fn Message::get_consist_func(&self) -> ConsistFunc; alias getConsistFunc;
    /// @return The SlotStat1 message if this message is an SlotStat1 message
    fn Message::get_slot_stat1(&self) -> SlotStat1; alias getSlotStat1;
    /// @return The LongAck message if this message is an LongAck message
    fn Message::get_long_ack(&self) -> LongAck; alias getLongAck;
    /// @return The InputRep message if this message is an InputRep message
    fn Message::get_input_rep(&self) -> InputRep; alias getInputRep;
    /// @return The SwRep message if this message is an SwRep message
    fn Message::get_sw_rep(&self) -> SwRep; alias getSwRep;
    /// @return The SwReq message if this message is an SwReq message
    fn Message::get_sw_req(&self) -> SwReq; alias getSwReq;
    /// @return The LocoSnd message if this message is an LocoSnd message
    fn Message::get_loco_snd(&self) -> LocoSnd; alias getLocoSnd;
    /// @return The LocoDirf message if this message is an LocoDirf message
    fn Message::get_loco_dirf(&self) -> LocoDirf; alias getLocoDirf;
    /// @return The LocoSpd message if this message is an LocoSpd message
    fn Message::get_loco_spd(&self) -> LocoSpd; alias getLocoSpd;
    /// @return The MultiSense message if this message is an MultiSense message
    fn Message::get_multi_sense(&self) -> MultiSense; alias getMultiSense;
    /// @return The UhliFun message if this message is an UhliFun message
    fn Message::get_uhli_fun(&self) -> UhliFun; alias getUhliFun;
    /// @return The WrSlData message if this message is an WrSlData message
    fn Message::get_wr_sl_data(&self) -> WrSlData; alias getWrSlData;
    /// @return The SlRdData message if this message is an SlRdData message
    fn Message::get_sl_rd_data(&self) -> SlRdData; alias getSlRdData;
    /// @return The ImmPacket message if this message is an ImmPacket message
    fn Message::get_imm_packet(&self) -> ImmPacket; alias getImmPacket;
    /// @return The Rep message if this message is an Rep message
    fn Message::get_rep(&self) -> Rep; alias getRep;
    /// @return The PeerXfer message if this message is an PeerXfer message
    fn Message::get_peer_xfer(&self) -> PeerXfer; alias getPeerXfer;
});

pub trait ExceptionObserver: Send {
    fn on_exception_occurred(&self, error: MessageParseError);
}

pub trait LocoNetMessageObserver: Send {
    fn on_message_occurred(&self, message: Message);
}

pub trait LackMessageObserver: Send {
    fn on_lack_occurred(&self, lack: LongAck, message: Message);
}

foreign_callback!(
/// This interface represents a observer for a loco net message.
callback LocoNetMessageObserver {
    self_type LocoNetMessageObserver;
    /// Called by the locoNetConnector when a message occurred.
    /// @param message The message that occurred
    onMessageOccurred = LocoNetMessageObserver::on_message_occurred(&self, message: Message);
});

foreign_callback!(
/// This interface represents a observer for handling exceptions, that occurred while reading or writing to the loco net
callback ExceptionObserver {
    self_type ExceptionObserver;
    /// Called by the locoNetConnector when a message occurred.
    /// @param message The error that occurred
    onExceptionOccurred = ExceptionObserver::on_exception_occurred(&self, message: MessageParseError);
});

foreign_callback!(
/// This interface represents a observer for handling lack messages. Lack messages are responses to before messages and immediately follows those
callback LackMessageObserver {
    self_type LackMessageObserver;
    /// Called by the locoNetConnector when a lack message occurred.
    /// @param lack The lack message that was received
    /// @param message The message the lack response was received for
    onLackOccurred = LackMessageObserver::on_lack_occurred(&self, lack: LongAck, message: Message);
});

pub struct LocoNetConnector {
    port: Box<dyn SerialPort>,
    message_observer: Box<dyn LocoNetMessageObserver>,
    lack_observer: Box<dyn LackMessageObserver>,
    error_handler: Box<dyn ExceptionObserver>,
    lack: bool,
    last_message: Message,
    send: Arc<(Mutex<Vec<u8>>, Condvar, Condvar)>,
    stop: Mutex<bool>,
    reading_thread: Option<JoinHandle<()>>,
    sending_timeout: u64
}

impl LocoNetConnector {
    /// Creates a new port
    pub fn new(port_name: &str, baud_rate: u32, sending_timeout: u64, update_cycles: u64, flow_control: FlowControl, message_observer: Box<dyn LocoNetMessageObserver>, lack_observer: Box<dyn LackMessageObserver>, error_handler: Box<dyn ExceptionObserver>) -> Result<Self, String> {
        let port = serialport::new(port_name, baud_rate)
            .data_bits(DataBits::Eight)
            .stop_bits(StopBits::Two)
            .parity(Parity::None)
            .flow_control(flow_control)
            .timeout(Duration::from_millis(update_cycles))
            .open();

        return if port.is_err() {
            Err("Could not open port: ".to_owned() + port_name)
        } else {
            Ok(LocoNetConnector {
                port: port.unwrap(),
                message_observer,
                lack_observer,
                error_handler,
                lack: false,
                last_message: Message::Busy(Busy()),
                send: Arc::new((Mutex::new(vec![0u8; 0]), Condvar::new(), Condvar::new())),
                stop: Mutex::new(false),
                reading_thread: None,
                sending_timeout,
            })
        }
    }

    /// Returns the ports name as a string
    pub fn get_port_name(&self) -> String {
        self.port.name().unwrap_or(String::from("-"))
    }

    /// Start a new thread that reads new loco net message
    pub fn start_reader(&'static mut self) -> bool {
        let s = Arc::new(Mutex::new(self));
        let new_s = Arc::clone(&s);
        let mut save_to = (&*s).lock().unwrap();
        if save_to.reading_thread.is_none() {
            save_to.reading_thread = Some(thread::spawn(move|| {
                let mut save_inner = (&*new_s).lock().unwrap();
                *save_inner.stop.lock().unwrap() = false;
                while !*save_inner.stop.lock().unwrap() {
                    save_inner.read();
                }
            }));
            true
        } else {
            false
        }
    }

    /// Stops the loco net message reader and wait for the stop
    pub fn stop_reader(&mut self) {
        if self.reading_thread.is_some() {
            *self.stop.lock().unwrap() = true;
            mem::replace(&mut self.reading_thread, None).take().unwrap().join().unwrap();
        }
    }

    /// Handels a message after a it was parsed successfully
    pub fn read(&mut self) {
        let parsed = self.parse();
        if let Err(err) = parsed {
            if let MessageParseError::Update(_io) = err {

            } else {
                self.error_handler.on_exception_occurred(err);
                self.lack = false;
            }
        } else {
            let message: Message = parsed.unwrap();

            if self.lack {
                if let Message::LongAck(m) = message {
                    self.lack_observer.on_lack_occurred(m, self.last_message);
                }
            }

            if message.lack_follows() {
                self.lack = true;
                self.last_message = message;
            } else {
                self.lack = false;
            }

            self.message_observer.on_message_occurred(message);
        }
    }

    /// Reads and Parses the next message from `stream`.
    ///
    /// # Errors
    ///
    /// This function returns an error if the message could not be parsed:
    ///
    /// * [`UnknownOpcode`] if the message has an unknown opcode
    /// * [`UnexpectedEnd`] if `stream` unexpectedly yields [`None`]
    /// * [`InvalidChecksum`] if the checksum is invalid
    ///
    /// [`UnknownOpcode`]: MessageParseError::UnknownOpcode
    /// [`UnexpectedEnd`]: MessageParseError::UnexpectedEnd
    /// [`InvalidChecksum`]: MessageParseError::InvalidChecksum
    pub fn parse(&mut self) -> Result<Message, MessageParseError> {
        let mut buf = vec![0u8; 1];
        if let Err(error) = self.port.read_exact(&mut buf) {
            return Err(MessageParseError::Update(error));
        }

        let opc = buf[0];

        let len = match opc & 0xE0 {
            0x80 => 2,
            0xA0 => 4,
            0xC0 => 6,
            0xE0 => {
                let mut byte1 = [0u8; 1];
                if let Err(error) = self.port.read_exact(&mut byte1) {
                    return Err(MessageParseError::IoError(error));
                }
                buf.push(byte1[0]);
                byte1[0] as usize - 1
            }
            _ => return Err(MessageParseError::UnknownOpcode(opc)),
        };

        let mut message = vec![0u8; len - 1];

        if let Err(error) = self.port.read_exact(&mut message) {
            return Err(MessageParseError::IoError(error));
        }

        buf.append(&mut message);

        // validate checksum
        if !Self::validate(&buf) {
            return Err(MessageParseError::InvalidChecksum);
        }

        // Check for receiving last send message
        let (lock, cvar, waiter) = &*self.send;
        let mut last_send = lock.lock().unwrap();

        if !(*last_send).is_empty() && (*last_send) == buf {
            println!("Reset!");
            *last_send = vec![0u8; 0];
            waiter.notify_all();
            cvar.notify_one();
        }

        // call appropriate parse function
        match len {
            2 => Self::parse2(opc),
            4 => Self::parse4(opc, &buf[1..3]),
            6 => Self::parse6(opc, &buf[1..5]),
            var => Self::parse_var(opc, &buf[1..var]),
        }
    }

    fn parse2(opc: u8) -> Result<Message, MessageParseError> {
        match opc {
            0x85 => Ok(Message::Idle(Idle())),
            0x83 => Ok(Message::GpOn(GpOn())),
            0x82 => Ok(Message::GpOff(GpOff())),
            0x81 => Ok(Message::Busy(Busy())),
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    fn parse4(opc: u8, args: &[u8]) -> Result<Message, MessageParseError> {
        if args.len() != 2 {
            return Err(MessageParseError::UnexpectedEnd);
        }
        match opc {
            0xBF => Ok(Message::LocoAdr(LocoAdr(AddressArg::parse(args[0], args[1])))),
            0xBD => Ok(Message::SwAck(SwAck(SwitchArg::parse(args[0], args[1])))),
            0xBC => Ok(Message::SwState(SwState(SwitchArg::parse(args[0], args[1])))),
            0xBB => Ok(Message::RqSlData(RqSlData(SlotArg::parse(args[0])))),
            0xBA => Ok(Message::MoveSlots(MoveSlots(
                SlotArg::parse(args[0]),
                SlotArg::parse(args[1]),
            ))),
            0xB9 => Ok(Message::LinkSlots(LinkSlots(
                SlotArg::parse(args[0]),
                SlotArg::parse(args[1]),
            ))),
            0xB8 => Ok(Message::UnlinkSlots(UnlinkSlots(
                SlotArg::parse(args[0]),
                SlotArg::parse(args[1]),
            ))),
            0xB6 => Ok(Message::ConsistFunc(ConsistFunc(
                SlotArg::parse(args[0]),
                DirfArg::parse(args[1]),
            ))),
            0xB5 => Ok(Message::SlotStat1(SlotStat1(
                SlotArg::parse(args[0]),
                Stat1Arg::parse(args[1]),
            ))),
            0xB4 => Ok(Message::LongAck(LongAck(
                LopcArg::parse(args[0]),
                Ack1Arg::parse(args[1]),
            ))),
            0xB2 => Ok(Message::InputRep(InputRep(InArg::parse(args[0], args[1])))),
            0xB1 => Ok(Message::SwRep(SwRep(SnArg::parse(args[0], args[1])))),
            0xB0 => Ok(Message::SwReq(SwReq(SwitchArg::parse(args[0], args[1])))),
            0xA2 => Ok(Message::LocoSnd(LocoSnd(
                SlotArg::parse(args[0]),
                SndArg::parse(args[1]),
            ))),
            0xA1 => Ok(Message::LocoDirf(LocoDirf(
                SlotArg::parse(args[0]),
                DirfArg::parse(args[1]),
            ))),
            0xA0 => Ok(Message::LocoSpd(LocoSpd(
                SlotArg::parse(args[0]),
                SpeedArg::parse(args[1]),
            ))),
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    fn parse6(opc: u8, args: &[u8]) -> Result<Message, MessageParseError> {
        if args.len() != 4 {
            return Err(MessageParseError::UnexpectedEnd);
        }
        match opc {
            0xD0 => Ok(Message::MultiSense(MultiSense(
                MTypeArg::parse(args[0]),
                ZasArg::parse(args[1]),
                SenseAddrArg::parse(args[2], args[3]),
            ))),
            0xD4 => {
                assert_eq!(0x20, args[0], "Value of arg0 can only be {:?}", 0x20);
                Ok(Message::UhliFun(UhliFun(
                    SlotArg::parse(args[1]),
                    FunctionArg::parse(args[2], args[3]),
                )))
            }
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    fn parse_var(opc: u8, args: &[u8]) -> Result<Message, MessageParseError> {
        if args.len() as u8 + 2 == args[0] {
            return Err(MessageParseError::UnexpectedEnd);
        }
        match opc {
            0xE7 => Ok(Message::SlRdData(SlRdData(
                SlotArg::parse(args[1]),
                Stat1Arg::parse(args[2]),
                AddressArg::parse(args[8], args[3]),
                SpeedArg::parse(args[4]),
                DirfArg::parse(args[5]),
                TrkArg::parse(args[6]),
                Stat2Arg::parse(args[7]),
                SndArg::parse(args[9]),
                IdArg::parse(args[10], args[11]),
            ))),
            0xED => Ok(Message::ImmPacket(ImmPacket(
                ImArg::parse(args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])
            ))),
            0xEF => Ok(Message::WrSlData(WrSlData(
                WrSlDataStructure::parse(args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11])
            ))),
            0xE4 => Ok(Message::Rep(Rep(RepStructure::parse(args[0], &args[1..])))),
            0xE5 => Ok(Message::PeerXfer(PeerXfer(SlotArg::parse(args[1]), DstArg::parse(args[2], args[3]), PxctData::parse(args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13])))),
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    /// Validates a messages checksum
    fn validate(msg: &[u8]) -> bool {
        return msg.iter().fold(0, |acc, &b| acc ^ b) == 0xFF;
    }

    /// Writes a set of bytes to the loco net by appending the checksum and sending it to the connection
    pub fn write(&mut self, message: Vec<u8>) -> bool {
        if self.reading_thread.is_none() {
            self.error_handler.on_exception_occurred(
                MessageParseError::IoError(
                    std::io::Error::new(
                        std::io::ErrorKind::TimedOut, "Reader not started! Please start the reader before sending messages."
                    )));
            return false;
        }

        let bytes = Self::to_message(message);

        let (lock, cvar, waiter) = &*self.send;

        if !(*lock.lock().unwrap()).is_empty() {
            let result = cvar.wait_timeout_while(lock.lock().unwrap(), Duration::from_millis(self.sending_timeout), |pending| !(*pending).is_empty()).unwrap();

            if result.1.timed_out() {
                self.error_handler.on_exception_occurred(
                    MessageParseError::IoError(
                        std::io::Error::new(
                            std::io::ErrorKind::TimedOut, "Connection timed out! Please check your connected device."
                        )));
                return false;
            }
        }

        let mut send = lock.lock().unwrap();

        *send = bytes;

        match self.port.write_all(&*send) {
            Ok(_) => {
                drop(send);
                if !(*lock.lock().unwrap()).is_empty() {
                    let result = waiter.wait_timeout_while(lock.lock().unwrap(), Duration::from_millis(self.sending_timeout), |pending| !(*pending).is_empty()).unwrap();
                    if result.1.timed_out() {
                        self.error_handler.on_exception_occurred(
                            MessageParseError::IoError(
                                std::io::Error::new(
                                    std::io::ErrorKind::TimedOut, "Connection timed out! Please check your connected device."
                                )));
                        return false;
                    }
                }
                true
            },
            Err(_) => false,
        }
    }

    /// Appends the checksum at the end of the message
    pub fn to_message(mut bytes: Vec<u8>) -> Vec<u8> {
        bytes.push(Self::check_sum(&bytes));

        bytes
    }

    /// Calculates the checksum for an array of bytes
    fn check_sum(msg: &[u8]) -> u8 {
        0xFF - msg.iter().fold(0, |acc, &b| acc ^ b)
    }
}

foreign_enum!(
    /// How to control the data flow to the loco net
    enum FlowControl {
        /// Software based flow control (standard for Uhlenbrock loco net systems)
    SOFTWARE = FlowControl::Software,
        /// Hardware based flow control with cts / rts
    HARDWARE = FlowControl::Hardware,
        /// No flow control
    NONE = FlowControl::None,
});

foreign_class!(
    /// This class represents a connection to the loco net.
    class LocoNetConnector {
    self_type LocoNetConnector;
        /// Creates a new port to the loco net.
        /// @param portName The connections port name. (You can list all ports by calling PortInfos.getAllPorts())
        /// @param baudRate The baud rate of the connection
        /// @param sendingTimeout The time the loco net waits for the loco net to respond to a message, before failing
        /// @param updateCycles How often the loco net leaves the freeze state to check whether to close the connection, before waiting for new messages
        /// @param flowControl The flow control to use
        /// @param messageObserver The observer to call when a new message was received from the loco net
        /// @param lackObserver The observer to call when an answer message to a before message received
        /// @param errorHandler The method to call when an error occurred while reading or writing to the connection
        /// @throws Exception when the loco net connection port can not be accessed.
    constructor LocoNetConnector::new(portName: &str, baudRate: u32, sendingTimeout: u64, updateCycles: u64, flowControl: FlowControl, messageObserver: Box<dyn LocoNetMessageObserver>, lackObserver: Box<dyn LackMessageObserver>, errorHandler: Box<dyn ExceptionObserver>) -> Result<LocoNetConnector, String>;
    foreign_code r#"
    /**
     * Creates a new port to the loco net.<br>
     * Sets the updateCycles to 5000, and the flow control to software.
     * @param portName The connections port name. (You can list all ports by calling PortInfos.getAllPorts())
     * @param baudRate The baud rate of the connection
     * @param sendingTimeout The time the loco net waits for the loco net to respond to a message, before failing
     * @param messageObserver The observer to call when a new message was received from the loco net
     * @param lackObserver The observer to call when an answer message to a before message received
     * @param errorHandler The method to call when an error occurred while reading or writing to the connection
     * @throws Exception when the loco net connection port can not be accessed.
     */
    public LocoNetConnector(String portName, long baudRate, long sendingTimeout, LocoNetMessageObserver messageObserver, LackMessageObserver lackObserver, ExceptionObserver errorHandler) throws Exception {
        this(portName, baudRate, sendingTimeout, 5000, FlowControl.SOFTWARE, messageObserver, lackObserver, errorHandler);
    }

    /**
     * Creates a new port to the loco net.<br>
     * Sets the baud rate to 115_200, the sending timeout to 500, the updateCycles to 5000, and the flow control to software.
     * @param portName The connections port name. (You can list all ports by calling PortInfos.getAllPorts())
     * @param messageObserver The observer to call when a new message was received from the loco net
     * @param lackObserver The observer to call when an answer message to a before message received
     * @param errorHandler The method to call when an error occurred while reading or writing to the connection
     * @throws Exception when the loco net connection port can not be accessed.
     */
    public LocoNetConnector(String portName, LocoNetMessageObserver messageObserver, LackMessageObserver lackObserver, ExceptionObserver errorHandler) throws Exception {
        this(portName, 115_200, 500, 5000, FlowControl.SOFTWARE, messageObserver, lackObserver, errorHandler);
    }
"#;
    /// Starts the reader to the loco net connection.
    /// It creates a new rust threads, which reads incoming bytes from the loco net and sends the received messages to the set observers.
    /// @return true, if the thread is started successfully, false otherwise. (Only one thread can be started at any time, this method returns false if a running thread exists)
    fn LocoNetConnector::start_reader(&mut self) -> bool; alias startReader;
    /// Stops the loco net reading thread if one is started and waits until the thread is stopped completely by using rusts thread join.
    fn LocoNetConnector::stop_reader(&mut self); alias stopReader;
    /// @return The ports name
    fn LocoNetConnector::get_port_name(&self) -> String; alias getPortName;
});
