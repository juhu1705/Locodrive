use crate::jni_c_header::*;
use std::fmt::{Debug, Formatter};
use std::time::Duration;

#[derive(Debug, Copy, Clone)]
pub struct AddressArg(u16);

impl AddressArg {
    pub fn new(adr: u16) -> Self {
        Self(adr)
    }

    pub fn parse(adr2: u8, adr: u8) -> Self {
        let mut address = adr as u16;
        address |= (adr2 as u16) << 7;
        Self(address)
    }

    pub fn address(&self) -> u16 {
        self.0
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x3FFF,
            0,
            "address must only use the 14 least significant bits"
        );
        self.0 = address;
    }

    pub fn adr1(&self) -> u8 {
        (self.0 & 0x007F) as u8
    }

    pub fn adr2(&self) -> u8 {
        ((self.0 >> 7) & 0x007F) as u8
    }
}

foreign_class!(class AddressArg {
    self_type AddressArg;
    constructor AddressArg::new(_: u16) -> AddressArg;
    fn AddressArg::address(&self) -> u16;
    fn AddressArg::set_address(&mut self, _: u16);
});

#[derive(Debug, Copy, Clone)]
pub enum SwitchDirection {
    Straight,
    Curved,
}

foreign_enum!(enum SwitchDirection {
    STRAIGHT = SwitchDirection::Straight,
    CURVED = SwitchDirection::Curved,
});

#[derive(Debug, Copy, Clone)]
pub struct SwitchArg {
    address: u16,
    direction: SwitchDirection,
    state: bool,
}

impl SwitchArg {
    pub fn new(address: u16, direction: SwitchDirection, state: bool) -> Self {
        Self{address, direction, state}
    }

    pub fn parse(sw1: u8, sw2: u8) -> Self {
        let mut address = sw1 as u16;
        address |= (sw2 as u16 & 0x0F) << 7;

        let direction = if sw2 & 0x20 == 0 {
            SwitchDirection::Curved
        } else {
            SwitchDirection::Straight
        };

        let state = (sw2 & 0x10) != 0;
        Self {
            address,
            direction,
            state,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }
    pub fn direction(&self) -> SwitchDirection {
        self.direction
    }
    pub fn state(&self) -> bool {
        self.state
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x07FF,
            0,
            "address must only use the 11 least significant bits"
        );
        self.address = address;
    }
    pub fn set_direction(&mut self, direction: SwitchDirection) {
        self.direction = direction;
    }
    pub fn set_state(&mut self, state: bool) {
        self.state = state;
    }

    pub fn sw1(&self) -> u8 {
        (self.address & 0x007F) as u8
    }

    pub fn sw2(&self) -> u8 {
        let mut sw2 = ((self.address >> 7) & 0x000F) as u8;

        sw2 |= match self.direction {
            SwitchDirection::Curved => 0x00,
            SwitchDirection::Straight => 0x20
        };

        if self.state {
            sw2 |= 0x10;
        }

        sw2
    }
}

foreign_class!(class SwitchArg {
    self_type SwitchArg;
    constructor SwitchArg::new(_: u16, _: SwitchDirection, _: bool) -> SwitchArg;
    fn SwitchArg::address(&self) -> u16;
    fn SwitchArg::direction(&self) -> SwitchDirection;
    fn SwitchArg::state(&self) -> bool;
    fn SwitchArg::set_address(&mut self, _: u16);
    fn SwitchArg::set_direction(&mut self, _: SwitchDirection);
    fn SwitchArg::set_state(&mut self, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct SlotArg(u8);

impl SlotArg {
    pub fn parse(slot: u8) -> Self {
        Self(slot & 0x7F)
    }

    pub fn slot(&self) -> u8 {
        self.0
    }

    pub fn set_number(&mut self, number: u8) {
        assert_eq!(
            number & 0x7F,
            0,
            "number must only use the 7 least significant bits"
        );
        self.0 = number;
    }
}

foreign_class!(class SlotArg {
    self_type SlotArg;
    constructor SlotArg::parse(_: u8) -> SlotArg;
    fn SlotArg::slot(&self) -> u8;
    fn SlotArg::set_number(&mut self, _: u8);
});

#[derive(Debug, Copy, Clone)]
pub enum SpeedArg {
    Stop,
    EmergencyStop,
    Drive(u8),
}

impl SpeedArg {
    pub fn parse(spd: u8) -> Self {
        match spd {
            0x00 => Self::Stop,
            0x01 => Self::EmergencyStop,
            _ => Self::Drive(spd - 1),
        }
    }

    pub fn spd(&self) -> u8 {
        match *self {
            SpeedArg::Stop => 0x00,
            SpeedArg::EmergencyStop => 0x01,
            SpeedArg::Drive(spd) => spd + 1
        }
    }
}

foreign_class!(class SpeedArg {
    self_type SpeedArg;
    constructor SpeedArg::parse(_: u8) -> SpeedArg;
    fn SpeedArg::spd(&self) -> u8;
});

#[derive(Copy, Clone)]
pub struct DirfArg(u8);

impl DirfArg {
    pub fn parse(dirf: u8) -> Self {
        Self(dirf & 0x3F)
    }

    pub fn dir(&self) -> bool {
        self.0 & 0x20 != 0
    }

    pub fn f(&self, f_num: u8) -> bool {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        self.0 >> (if f_num == 0 { 4 } else { f_num - 1 }) & 1 != 0
    }

    pub fn set_dir(&mut self, value: bool) {
        if value {
            self.0 |= 0x20;
        } else {
            self.0 &= !0x20
        }
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        let mask = 1 << if f_num == 0 { 4 } else { f_num - 1 };
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn dirf(&self) -> u8 {
        self.0
    }
}

impl Debug for DirfArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DirfArg(dir: {}, f0: {}, f1: {}, f2: {}, f3: {}, f4: {})",
            self.dir(),
            self.f(0),
            self.f(1),
            self.f(2),
            self.f(3),
            self.f(4)
        )
    }
}

foreign_class!(class DirfArg {
    self_type DirfArg;
    constructor DirfArg::parse(_: u8) -> DirfArg;
    fn DirfArg::dir(&self) -> bool;
    fn DirfArg::f(&self, _: u8) -> bool;
    fn DirfArg::set_dir(&mut self, _: bool);
    fn DirfArg::set_f(&mut self, _: u8, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct TrkArg {
    power: bool,
    idle: bool,
    mlok1: bool,
    prog_busy: bool,
}

impl TrkArg {
    pub fn new(power: bool, idle: bool, mlok1: bool, prog_busy: bool) -> Self {
        TrkArg {power, idle, mlok1, prog_busy}
    }

    pub fn parse(trk_arg: u8) -> Self {
        let power = trk_arg & 0x01 == 0x01;
        let idle = trk_arg & 0x02 == 0x00;
        let mlok1 = trk_arg & 0x04 == 0x04;
        let prog_busy = trk_arg & 0x08 == 0x08;
        TrkArg {
            power,
            idle,
            mlok1,
            prog_busy,
        }
    }

    pub fn power_on(&self) -> bool {
        self.power
    }

    pub fn track_idle(&self) -> bool {
        self.idle
    }

    pub fn mlok1(&self) -> bool {
        self.mlok1
    }

    pub fn prog_busy(&self) -> bool {
        self.prog_busy
    }

    pub fn trk_arg(&self) -> u8 {
        let mut trk_arg = if self.power { 0x01 } else { 0x00 };
        if !self.idle {
            trk_arg |= 0x02;
        }
        if self.mlok1 {
            trk_arg |= 0x04;
        }
        if self.prog_busy {
            trk_arg |= 0x08;
        }
        trk_arg
    }
}

foreign_class!(class TrkArg {
    self_type TrkArg;
    constructor TrkArg::new(_: bool, _: bool, _: bool, _: bool) -> TrkArg;
    fn TrkArg::power_on(&self) -> bool;
    fn TrkArg::track_idle(&self) -> bool;
    fn TrkArg::mlok1(&self) -> bool;
    fn TrkArg::prog_busy(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct SndArg(u8);

impl SndArg {
    pub fn parse(snd: u8) -> Self {
        Self(snd & 0x0F)
    }

    pub fn f(&self, f_num: u8) -> bool {
        assert!(
            (5..=8).contains(&f_num),
            "f_num must be within 5 and 8 (inclusive)"
        );
        self.0 & 1 << (f_num - 5) != 0
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(
            (5..=8).contains(&f_num),
            "f_num must be within 5 and 8 (inclusive)"
        );
        let mask = 1 << (f_num - 5);
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn snd(&self) -> u8 {
        self.0
    }
}

foreign_class!(class SndArg {
    self_type SndArg;
    constructor SndArg::parse(_: u8) -> SndArg;
    fn SndArg::f(&self, _: u8) -> bool;
    fn SndArg::set_f(&mut self, _: u8, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct Stat1Arg {
    spurge: bool,
    consist: Consist,
    state: State,
    decoder_type: DecoderType,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Consist {
    LogicalMid,
    LogicalTop,
    LogicalSubMember,
    Free,
}

foreign_enum!(enum Consist {
    LOGICAL_MID = Consist::LogicalMid,
    LOGICAL_TOP = Consist::LogicalTop,
    LOGICAL_SUB_MEMBER = Consist::LogicalSubMember,
    FREE = Consist::Free,
});

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum State {
    InUse,
    Idle,
    Common,
    Free,
}

foreign_enum!(enum State {
    IN_USE = State::InUse,
    IDLE = State::Idle,
    COMMON = State::Common,
    FREE = State::Free,
});

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum DecoderType {
    Dcc28,
    Dcc128,
    Regular28,
    AdrMobile28,
    Step14,
    Speed128,
}

foreign_enum!(enum DecoderType {
    DCC_28 = DecoderType::Dcc28,
    DCC_128 = DecoderType::Dcc128,
    REGULAR_128 = DecoderType::Regular28,
    ADR_MOBILE_28 = DecoderType::AdrMobile28,
    STEP_14 = DecoderType::Step14,
    SPEED_128 = DecoderType::Speed128,
});

impl Stat1Arg {
    pub fn new(spurge: bool, consist: Consist, state: State, decoder_type: DecoderType) -> Self {
        Stat1Arg { spurge, consist, state, decoder_type }
    }

    pub fn parse(stat1: u8) -> Self {
        let spurge = stat1 & 0x80 != 0;

        let consist = match stat1 & 0x48 {
            0x48 => Consist::LogicalMid,
            0x08 => Consist::LogicalTop,
            0x40 => Consist::LogicalSubMember,
            0x00 => Consist::Free,
            _ => panic!("No valid consist is given!"),
        };

        let state = match stat1 & 0x30 {
            0x30 => State::InUse,
            0x20 => State::Idle,
            0x10 => State::Common,
            0x00 => State::Free,
            _ => panic!("No valid state is given!"),
        };

        let decoder_type = match stat1 & 0x07 {
            0x02 => DecoderType::Step14,
            0x01 => DecoderType::AdrMobile28,
            0x00 => DecoderType::Regular28,
            0x03 => DecoderType::Speed128,
            0x07 => DecoderType::Dcc128,
            0x04 => DecoderType::Dcc28,
            _ => panic!("The given decoder type was invalid!"),
        };

        Stat1Arg {
            spurge,
            consist,
            state,
            decoder_type,
        }
    }

    pub fn spurge(&self) -> bool {
        self.spurge
    }

    pub fn consist(&self) -> Consist {
        self.consist
    }

    pub fn state(&self) -> State {
        self.state
    }

    pub fn decoder_type(&self) -> DecoderType {
        self.decoder_type
    }

    pub fn stat1(&self) -> u8 {
        let mut stat1: u8 = if self.spurge { 0x80 } else { 0x00 };

        stat1 |= match self.consist {
            Consist::LogicalMid => 0x48,
            Consist::LogicalTop => 0x08,
            Consist::LogicalSubMember => 0x40,
            Consist::Free => 0x00
        };

        stat1 |= match self.state {
            State::InUse => 0x30,
            State::Idle => 0x20,
            State::Common => 0x10,
            State::Free => 0x00
        };

        stat1 |= match self.decoder_type {
            DecoderType::Dcc28 => 0x04,
            DecoderType::Dcc128 => 0x07,
            DecoderType::Regular28 => 0x00,
            DecoderType::AdrMobile28 => 0x01,
            DecoderType::Step14 => 0x02,
            DecoderType::Speed128 => 0x03
        };

        stat1
    }
}

foreign_class!(class Stat1Arg {
    self_type Stat1Arg;
    constructor Stat1Arg::new(_: bool, _: Consist, _: State, _: DecoderType) -> Stat1Arg;
    fn Stat1Arg::spurge(&self) -> bool;
    fn Stat1Arg::consist(&self) -> Consist;
    fn Stat1Arg::state(&self) -> State;
    fn Stat1Arg::decoder_type(&self) -> DecoderType;
});

#[derive(Debug, Copy, Clone)]
pub struct Stat2Arg {
    has_adv: bool,
    no_id_usage: bool,
    id_encoded_alias: bool,
}

impl Stat2Arg {
    pub fn new(has_adv: bool, no_id_usage: bool, id_encoded_alias: bool) -> Self {
        Stat2Arg{ has_adv, no_id_usage, id_encoded_alias }
    }

    pub fn parse(stat2: u8) -> Self {
        let has_adv = stat2 & 0x01 != 0;

        let no_id_usage = stat2 & 0x04 != 0;

        let id_encoded_alias = stat2 & 0x08 != 0;

        Stat2Arg {
            has_adv,
            no_id_usage,
            id_encoded_alias,
        }
    }

    pub fn has_adv(&self) -> bool {
        self.has_adv
    }

    pub fn no_id_usage(&self) -> bool {
        self.no_id_usage
    }

    pub fn id_encoded_alias(&self) -> bool {
        self.id_encoded_alias
    }

    pub fn stat2(&self) -> u8 {
        let mut stat2 = if self.has_adv { 0x01 } else { 0x00 };
        if self.no_id_usage {
            stat2 |= 0x04;
        }
        if self.id_encoded_alias {
            stat2 |= 0x08;
        }
        stat2
    }
}

foreign_class!(class Stat2Arg {
    self_type Stat2Arg;
    constructor Stat2Arg::new(_: bool, _: bool, _: bool) -> Stat2Arg;
    fn Stat2Arg::has_adv(&self) -> bool;
    fn Stat2Arg::no_id_usage(&self) -> bool;
    fn Stat2Arg::id_encoded_alias(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct LopcArg(u8);

impl LopcArg {
    pub fn parse(lopc: u8) -> Self {
        Self(lopc & !0x40)
    }

    pub fn lopc(&self) -> u8 {
        self.0
    }

    pub fn set_lopc(&mut self, lopc: u8) {
        assert_eq!(lopc & 0x40, 0, "7th least significant bit must be 0");
        self.0 = lopc
    }
}

foreign_class!(class LopcArg {
    self_type LopcArg;
    constructor LopcArg::parse(_: u8) -> LopcArg;
    fn LopcArg::lopc(&self) -> u8;
    fn LopcArg::set_lopc(&mut self, _: u8);
});

#[derive(Debug, Copy, Clone)]
pub struct Ack1Arg(u8);

impl Ack1Arg {
    pub fn parse(ack1: u8) -> Self {
        Self(ack1)
    }

    pub fn ack1(&self) -> u8 {
        self.0
    }

    pub fn success(&self) -> bool {
        self.0 != 0
    }

    pub fn is_busy(&self) -> bool {
        self.0 == 0
    }

    pub fn accepted(&self) -> bool {
        self.0 == 1
    }

    pub fn accepted_blind(&self) -> bool {
        self.0 == 0x40
    }

    pub fn set_code(&mut self, code: u8) {
        self.0 = code
    }
}

foreign_class!(class Ack1Arg {
    self_type Ack1Arg;
    constructor Ack1Arg::parse(_: u8) -> Ack1Arg;
    fn Ack1Arg::ack1(&self) -> u8;
    fn Ack1Arg::success(&self) -> bool;
    fn Ack1Arg::is_busy(&self) -> bool;
    fn Ack1Arg::accepted(&self) -> bool;
    fn Ack1Arg::accepted_blind(&self) -> bool;
    fn Ack1Arg::set_code(&mut self, _: u8);
});

#[derive(Copy, Clone)]
pub struct InArg {
    address: u16,
    source_type: SourceType,
    state: bool,
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum SourceType {
    Aux,
    Switch,
}

foreign_enum!(enum SourceType {
    AUX = SourceType::Aux,
    SWITCH = SourceType::Switch,
});

impl InArg {
    pub fn new(address: u16, source_type: SourceType, state: bool) -> Self {
        InArg { address, source_type, state }
    }

    pub fn parse(in1: u8, in2: u8) -> Self {
        let mut address = in1 as u16;
        address |= (in2 as u16 & 0x0F) << 7;

        let source_type = if in2 & 0x20 == 0 {
            SourceType::Aux
        } else {
            SourceType::Switch
        };

        let state = (in2 & 0x10) != 0;
        Self {
            address,
            source_type,
            state,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn address_ds54(&self) -> u16 {
        self.address << 1
            | if self.source_type() == SourceType::Switch {
            1
        } else {
            0
        }
    }

    pub fn source_type(&self) -> SourceType {
        self.source_type
    }

    pub fn state(&self) -> bool {
        self.state
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x07FF,
            0,
            "address must only use the 11 least significant bits"
        );
        self.address = address;
    }

    pub fn set_address_ds54(&mut self, address_ds54: u16) {
        assert_eq!(
            self.address & 0x0FFF,
            0,
            "address must only use the 12 least significant bits"
        );
        self.set_source_type(if address_ds54 & 1 == 0 {
            SourceType::Aux
        } else {
            SourceType::Switch
        });
        self.set_address(address_ds54 >> 1);
    }

    pub fn set_source_type(&mut self, source_type: SourceType) {
        self.source_type = source_type;
    }

    pub fn set_state(&mut self, state: bool) {
        self.state = state;
    }

    pub fn in1(&self) -> u8 {
        self.address as u8 & 0x7F
    }

    pub fn in2(&self) -> u8 {
        let mut in2 = ((self.address >> 7) as u8) & 0x0F;
        in2 |= match self.source_type {
            SourceType::Aux => 0x00,
            SourceType::Switch => 0x20
        };
        if self.state {
            in2 |= 0x10;
        }
        in2
    }
}

impl Debug for InArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InArg {{ address: {:?} (DS54: {:?}), source_type: {:?}, state: {:?} }}",
            self.address(),
            self.address_ds54(),
            self.source_type(),
            self.state()
        )
    }
}

foreign_class!(class InArg {
    self_type InArg;
    constructor InArg::new(_: u16, _: SourceType, _: bool) -> InArg;
    fn InArg::address(&self) -> u16;
    fn InArg::address_ds54(&self) -> u16;
    fn InArg::source_type(&self) -> SourceType;
    fn InArg::state(&self) -> bool;
    fn InArg::set_address(&mut self, _: u16);
    fn InArg::set_address_ds54(&mut self, _: u16);
    fn InArg::set_source_type(&mut self, _: SourceType);
    fn InArg::set_state(&mut self, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct SnArg {
    address: u16,
    format: bool,
    c: bool,
    t: bool,
}

impl SnArg {
    pub fn new(address: u16, format: bool, c: bool, t: bool) -> Self {
        SnArg { address, format, c, t }
    }

    pub fn parse(sn1: u8, sn2: u8) -> Self {
        let mut address = sn1 as u16;
        address |= (sn2 as u16 & 0x0F) << 7;

        let format = sn2 & 0x20 == 0x20;

        let c = sn2 & 0x40 == 0x40;
        let t = sn2 & 0x80 == 0x80;

        SnArg {
            address,
            format,
            c,
            t,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn format(&self) -> bool {
        self.format
    }

    pub fn c(&self) -> bool {
        self.c
    }

    pub fn t(&self) -> bool {
        self.t
    }

    pub fn set_address(&mut self, address: u16) {
        self.address = address;
    }

    pub fn set_format(&mut self, format: bool) {
        self.format = format;
    }

    pub fn set_c(&mut self, c: bool) {
        self.c = c;
    }

    pub fn set_t(&mut self, t: bool) {
        self.t = t;
    }

    pub fn sn1(&self) -> u8 {
        (self.address as u8) & 0x7F
    }

    pub fn sn2(&self) -> u8 {
        let mut sn2 = (self.address >> 7) as u8 & 0x0F;
        if self.format {
            sn2 |= 0x20;
        }
        if self.c {
            sn2 |= 0x40;
        }
        if self.t {
            sn2 |= 0x80;
        }
        sn2
    }
}

foreign_class!(class SnArg {
    self_type SnArg;
    constructor SnArg::new(_: u16, _: bool, _: bool, _: bool) -> SnArg;
    fn SnArg::address(&self) -> u16;
    fn SnArg::format(&self) -> bool;
    fn SnArg::c(&self) -> bool;
    fn SnArg::t(&self) -> bool;
    fn SnArg::set_address(&mut self, _: u16);
    fn SnArg::set_format(&mut self, _: bool);
    fn SnArg::set_c(&mut self, _: bool);
    fn SnArg::set_t(&mut self, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct IdArg(u8, u8);

impl IdArg {
    pub fn parse(id1: u8, id2: u8) -> Self {
        IdArg(id1 & 0xF7, id2 & 0xF7)
    }

    pub fn id1(&self) -> u8 {
        self.0
    }

    pub fn id2(&self) -> u8 {
        self.1
    }
}

foreign_class!(class IdArg {
    self_type IdArg;
    constructor IdArg::parse(_: u8, _: u8) -> IdArg;
    fn IdArg::id1(&self) -> u8;
    fn IdArg::id2(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct MTypeArg(u8);

impl MTypeArg {
    pub fn parse(m_type: u8) -> Self {
        MTypeArg(m_type)
    }

    pub fn m_type(&self) -> u8 {
        self.0
    }
}

foreign_class!(class MTypeArg {
    self_type MTypeArg;
    constructor MTypeArg::parse(_: u8) -> MTypeArg;
    fn MTypeArg::m_type(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct ZasArg(u8);

impl ZasArg {
    pub fn parse(zone_and_section: u8) -> Self {
        ZasArg(zone_and_section)
    }

    pub fn zas(&self) -> u8 {
        self.0
    }
}

foreign_class!(class ZasArg {
    self_type ZasArg;
    constructor ZasArg::parse(_: u8) -> ZasArg;
    fn ZasArg::zas(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct SenseAddrArg(u16);

impl SenseAddrArg {
    pub fn new(address: u16) -> Self {
        SenseAddrArg(address)
    }

    pub fn parse(addr1: u8, addr2: u8) -> Self {
        let mut address = addr1 as u16;
        address |= (addr2 as u16) << 7;

        SenseAddrArg(address)
    }

    pub fn address(&self) -> u16 {
        self.0
    }

    pub fn addr1(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn addr2(&self) -> u8 {
        (self.0 >> 7) as u8
    }
}

foreign_class!(class SenseAddrArg {
    self_type SenseAddrArg;
    constructor SenseAddrArg::new(_: u16) -> SenseAddrArg;
    constructor SenseAddrArg::parse(_: u8, _: u8) -> SenseAddrArg;
    fn SenseAddrArg::address(&self) -> u16;
    fn SenseAddrArg::addr1(&self) -> u8;
    fn SenseAddrArg::addr2(&self) -> u8;
});

#[derive(Copy, Clone)]
pub struct FunctionArg(u8, u8);

impl FunctionArg {
    pub fn new(group: u8) -> Self {
        FunctionArg(group, 0)
    }

    pub fn parse(group: u8, function: u8) -> Self {
        FunctionArg(group, function)
    }

    pub fn f(&self, f_num: u8) -> bool {
        if f_num > 8 && f_num < 12 && self.0 == 0x07 {
            (self.1 >> (f_num - 9) & 1) != 0
        } else if (f_num == 12 || f_num == 20 || f_num == 28) && self.0 == 0x05 {
            (self.1
                >> (if f_num == 12 {
                0
            } else if f_num == 20 {
                1
            } else {
                2
            })
                & 1)
                != 0
        } else if f_num > 12 && f_num < 20 && self.0 == 0x08 {
            (self.1 >> (f_num - 13) & 1) != 0
        } else if f_num > 20 && f_num < 28 && self.0 == 0x09 {
            (self.1 >> (f_num - 21) & 1) != 0
        } else {
            false
        }
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        let mask = 1 << (f_num - 9);
        if value {
            self.1 |= mask;
        } else {
            self.1 &= !mask;
        }
    }

    pub fn group(&self) -> u8 {
        self.0
    }

    pub fn function(&self) -> u8 {
        self.1
    }
}

impl Debug for FunctionArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DirfArg(f9: {}, f10: {}, f11: {}, f12: {}, f13: {}, f14: {}, f15: {}, f16: {}, f17: {}, f18: {}, f19: {}, f20: {}, f21: {}, f22: {}, f23: {}, f24: {}, f25: {}, f26: {}, f27: {}, f28: {})",
            self.f(9),
            self.f(10),
            self.f(11),
            self.f(12),
            self.f(13),
            self.f(14),
            self.f(15),
            self.f(16),
            self.f(17),
            self.f(18),
            self.f(19),
            self.f(20),
            self.f(21),
            self.f(22),
            self.f(23),
            self.f(24),
            self.f(25),
            self.f(26),
            self.f(27),
            self.f(28),
        )
    }
}

foreign_class!(class FunctionArg {
    self_type FunctionArg;
    constructor FunctionArg::new(_: u8) -> FunctionArg;
    constructor FunctionArg::parse(_: u8, _: u8) -> FunctionArg;
    fn FunctionArg::group(&self) -> u8;
    fn FunctionArg::f(&self, _: u8) -> bool;
    fn FunctionArg::set_f(&mut self, _: u8, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct Pcmd {
    write: bool,
    byte_mode: bool,
    ops_mode: bool,
    ty1: bool, // Programing type select bit
    ty2: bool, // prog type select bit
}

impl Pcmd {
    pub fn new(write: bool, byte_mode: bool, ops_mode: bool, ty1: bool, ty2: bool) -> Self {
        Pcmd{ write, byte_mode, ops_mode, ty1, ty2 }
    }

    pub fn parse(pcmd: u8) -> Self {
        let write = pcmd & 0x20 == 0x20;
        let byte_mode = pcmd & 0x40 == 0x40;
        let ops_mode = pcmd & 0x02 == 0x02;
        let ty1 = pcmd & 0x80 == 0x80;
        let ty2 = pcmd & 0x01 == 0x01;

        Pcmd {
            write,
            byte_mode,
            ops_mode,
            ty1,
            ty2,
        }
    }

    pub fn write(&self) -> bool {
        self.write
    }

    pub fn byte_mode(&self) -> bool {
        self.byte_mode
    }

    pub fn ops_mode(&self) -> bool {
        self.ops_mode
    }

    pub fn ty1(&self) -> bool {
        self.ty1
    }

    pub fn ty2(&self) -> bool {
        self.ty2
    }

    pub fn pcmd(&self) -> u8 {
        let mut pcmd = if self.write { 0x20 } else { 0x00 };
        if self.byte_mode {
            pcmd |= 0x40;
        }
        if self.ops_mode {
            pcmd |= 0x02;
        }
        if self.ty1 {
            pcmd |= 0x80;
        }
        if self.ty2 {
            pcmd |= 0x01;
        }
        pcmd
    }
}

foreign_class!(class Pcmd {
    self_type Pcmd;
    constructor Pcmd::new(_: bool, _: bool, _: bool, _: bool, _: bool) -> Pcmd;
    fn Pcmd::write(&self) -> bool;
    fn Pcmd::byte_mode(&self) -> bool;
    fn Pcmd::ops_mode(&self) -> bool;
    fn Pcmd::ty1(&self) -> bool;
    fn Pcmd::ty2(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct PStat {
    user_aborted: bool,
    no_read_ack: bool,
    no_write_ack: bool,
    programming_track_empty: bool,
}

impl PStat {
    pub fn new(user_aborted: bool, no_read_ack: bool, no_write_ack: bool, programming_track_empty: bool) -> Self {
        PStat { user_aborted, no_read_ack, no_write_ack, programming_track_empty }
    }

    pub fn parse(stat: u8) -> Self {
        let user_aborted = stat & 0x01 == 0x01;
        let no_read_ack = stat & 0x02 == 0x02;
        let no_write_ack = stat & 0x04 == 0x04;
        let programming_track_empty = stat & 0x08 == 0x08;

        PStat {
            user_aborted,
            no_read_ack,
            no_write_ack,
            programming_track_empty,
        }
    }

    pub fn user_aborted(&self) -> bool {
        self.user_aborted
    }

    pub fn no_read_ack(&self) -> bool {
        self.no_read_ack
    }

    pub fn no_write_ack(&self) -> bool {
        self.no_write_ack
    }

    pub fn programming_track_empty(&self) -> bool {
        self.programming_track_empty
    }

    pub fn stat(&self) -> u8 {
        let mut stat = if self.user_aborted { 0x01 } else { 0x00 };
        if self.no_read_ack {
            stat |= 0x02;
        }
        if self.no_write_ack {
            stat |= 0x04;
        }
        if self.programming_track_empty {
            stat |= 0x08;
        }
        stat
    }
}

foreign_class!(class PStat {
    self_type PStat;
    constructor PStat::new(_: bool, _: bool, _: bool, _: bool) -> PStat;
    fn PStat::user_aborted(&self) -> bool;
    fn PStat::no_read_ack(&self) -> bool;
    fn PStat::no_write_ack(&self) -> bool;
    fn PStat::programming_track_empty(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub struct Hopsa(u8);

impl Hopsa {
    pub fn parse(o_mode: u8) -> Self {
        Hopsa(o_mode & 0x7F)
    }

    pub fn service_mode(&self) -> bool {
        self.0 == 0
    }

    pub fn o_mode(&self) -> u8 {
        self.0
    }
}

foreign_class!(class Hopsa {
    self_type Hopsa;
    constructor Hopsa::parse(_: u8) -> Hopsa;
    fn Hopsa::service_mode(&self) -> bool;
    fn Hopsa::o_mode(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct Lopsa(u8);

impl Lopsa {
    pub fn parse(o_mode: u8) -> Self {
        Lopsa(o_mode & 0x7F)
    }

    pub fn service_mode(&self) -> bool {
        self.0 == 0
    }

    pub fn o_mode(&self) -> u8 {
        self.0
    }
}

foreign_class!(class Lopsa {
    self_type Lopsa;
    constructor Lopsa::parse(_: u8) -> Lopsa;
    fn Lopsa::service_mode(&self) -> bool;
    fn Lopsa::o_mode(&self) -> u8;
});

#[derive(Copy, Clone)]
pub struct CvArg(u16);

impl CvArg {
    pub fn new() -> Self {
        CvArg(0)
    }

    pub fn parse(cvh: u8, cvl: u8) -> Self {
        let mut cv_arg = cvl as u16;

        let data_arg = (cvh & 0x02) >> 1;
        let mut high_cv_arg = cvh & 0x01;
        high_cv_arg |= (cvh & 0x30) >> 3;
        high_cv_arg |= (data_arg) << 3;

        cv_arg |= (high_cv_arg as u16) << 7;

        CvArg(cv_arg)
    }

    pub fn data7(&self) -> bool {
        self.0 & 0x0800 != 0
    }

    pub fn cv(&self, cv_num: u8) -> bool {
        assert!(cv_num <= 9, "cv must be lower than or equal to 9");
        self.0 >> cv_num & 1 != 0
    }

    pub fn set_data7(&mut self, value: bool) {
        if value {
            self.0 |= 0x0800;
        } else {
            self.0 &= !0x0800;
        }
    }

    pub fn set_cv(&mut self, cv_num: u8, value: bool) {
        assert!(cv_num <= 9, "cv must be lower than or equal to 9");
        let mask = 1 << cv_num;
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn cvh(&self) -> u8 {
        let mut cvh = (self.0 >> 7) as u8;
        let high_cv = cvh & 0x06 << 3;
        cvh &= 0x01;
        cvh |= high_cv;
        if self.data7() {
            cvh |= 0x02;
        }
        cvh
    }

    pub fn cvl(&self) -> u8 {
        self.0 as u8 & 0x7F
    }
}

impl Debug for CvArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CvArg(data7: {}, cv0: {}, cv1: {}, cv2: {}, cv3: {}, cv4: {}, cv5: {}, cv6: {}, cv7: {}, cv8: {})",
            self.data7(),
            self.cv(0),
            self.cv(1),
            self.cv(2),
            self.cv(3),
            self.cv(4),
            self.cv(5),
            self.cv(6),
            self.cv(7),
            self.cv(8),
        )
    }
}

foreign_class!(class CvArg {
    self_type CvArg;
    constructor CvArg::new() -> CvArg;
    fn CvArg::data7(&self) -> bool;
    fn CvArg::cv(&self, _: u8) -> bool;
    fn CvArg::set_data7(&mut self, _: bool);
    fn CvArg::set_cv(&mut self, _: u8, _: bool);
});

#[derive(Copy, Clone)]
pub struct DataArg(u8);

impl DataArg {
    pub fn new() -> Self {
        DataArg(0)
    }

    pub fn parse(data: u8) -> Self {
        DataArg(data)
    }

    pub fn d(&self, d_num: u8) -> bool {
        assert!(d_num <= 6, "d must be lower than or equal to 6");
        self.0 >> d_num & 1 != 0
    }

    pub fn set_d(&mut self, d_num: u8, value: bool) {
        assert!(d_num <= 6, "d must be lower than or equal to 6");
        let mask = 1 << d_num;
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn data(&self) -> u8 {
        self.0
    }
}

impl Debug for DataArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DataArg(d0: {}, d1: {}, d2: {}, d3: {}, d4: {}, d5: {}, d6: {})",
            self.d(0),
            self.d(1),
            self.d(2),
            self.d(3),
            self.d(4),
            self.d(5),
            self.d(6),
        )
    }
}

foreign_class!(class DataArg {
    self_type DataArg;
    constructor DataArg::new() -> DataArg;
    constructor DataArg::parse(_: u8) -> DataArg;
    fn DataArg::d(&self, _: u8) -> bool;
    fn DataArg::set_d(&mut self, _: u8, _: bool);
});

#[derive(Debug, Copy, Clone)]
pub struct ClkRateArg(u8);

impl ClkRateArg {
    pub fn parse(clk_rate: u8) -> Self {
        ClkRateArg(clk_rate & 0x7F)
    }

    pub fn set_rate(&mut self, clk_rate: u8) {
        assert!(
            clk_rate > 0x7F,
            "Clock rate {:?} is to high. Only values up to 0x7F are allowed",
            clk_rate
        );

        self.0 = clk_rate & 0x7F;
    }

    pub fn clk_rate(&self) -> u8 {
        self.0
    }
}

foreign_class!(class ClkRateArg {
    self_type ClkRateArg;
    constructor ClkRateArg::parse(_: u8) -> ClkRateArg;
    fn ClkRateArg::clk_rate(&self) -> u8;
    fn ClkRateArg::set_rate(&mut self, _: u8);
});

#[derive(Debug, Copy, Clone)]
pub struct FastClock {
    clk_rate: u8,
    frac_minsl: u8,
    frac_minsh: u8,
    duration: Duration,
    clk_cntrl: u8,
}

impl FastClock {
    pub fn parse(clk_rate: u8, frac_minsl: u8, frac_minsh: u8, mins: u8, hours: u8, days: u8, clk_cntrl: u8) -> Self {
        let min = mins % 60 - 0xFF;
        let hour = hours % 60 - 0xFF;

        let secs: u64 = min as u64 * 60 + hour as u64 * 60 * 60 + days as u64 * 24 * 60 * 60;

        let duration = Duration::new(secs, 0);

        FastClock {
            clk_rate: clk_rate & 0x7F,
            frac_minsl,
            frac_minsh,
            duration,
            clk_cntrl,
        }
    }

    pub fn clk_rate(&self) -> u8 {
        self.clk_rate
    }

    pub fn frac_minsl(&self) -> u8 {
        self.frac_minsl
    }

    pub fn frac_minsh(&self) -> u8 {
        self.frac_minsh
    }

    pub fn mins(&self) -> u8 {
        0xFF - (self.duration.as_secs() % 60) as u8
    }

    pub fn hours(&self) -> u8 {
        0xFF - (self.duration.as_secs() / 60 % 60) as u8
    }

    pub fn days(&self) -> u8 {
        0xFF - (self.duration.as_secs() / 60 / 60 % 24) as u8
    }

    pub fn clk_cntrl(&self) -> u8 {
        self.clk_cntrl
    }
}

foreign_class!(class FastClock {
    self_type FastClock;
    constructor FastClock::parse(clk_rate: u8, frac_minsl: u8, frac_minsh: u8, mins: u8, hours: u8, days: u8, clk_cntrl: u8) -> FastClock;
    fn FastClock::clk_rate(&self) -> u8;
    fn FastClock::frac_minsl(&self) -> u8;
    fn FastClock::frac_minsh(&self) -> u8;
    fn FastClock::mins(&self) -> u8;
    fn FastClock::hours(&self) -> u8;
    fn FastClock::days(&self) -> u8;
    fn FastClock::clk_cntrl(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct ImArg {
    reps: u8,
    dhi: u8,
    address: u16,
    function_type: u8,
    function_bits: u8,
    im5: u8
}

impl ImArg {
    pub fn new(reps: u8, dhi: u8, address: u16, function_type: u8, function_bits: u8, im5: u8) -> Self {
        ImArg { reps, dhi, address, function_type, function_bits, im5 }
    }

    pub fn parse(check_byte: u8, reps: u8, dhi: u8, im1: u8, im2 : u8, im3: u8, im4: u8, im5: u8) -> ImArg {
        assert_eq!(check_byte, 0x7F, "Checkbyte of ImmPacket is not 0x7F");

        if reps == 0x34 {
            let address = ((im2 as u16) << 8) | im1 as u16;

            let function_type = if im3 == 0x5E { 0x5E } else if im3 == 0x5F { 0x5F } else { 0x20 };
            let mut function_bits = if function_type == 0x5E || function_type == 0x5F { im4 } else { im3 };

            function_bits = function_bits & 0x7F;

            Self {reps, dhi, address, function_type, function_bits, im5}
        } else {
            let address = im1 as u16;

            let function_type = if im3 == 0x5E { 0x5E } else if im3 == 0x5F { 0x5F } else { 0x20 };
            let mut function_bits = if function_type == 0x5E || function_type == 0x5F { im3 } else { im2 & 0xDF };

            function_bits = function_bits & 0x7F;

            Self {reps, dhi, address, function_type, function_bits, im5}
        }
    }

    pub fn check_byte(&self) -> u8 {
        0x7F
    }

    pub fn reps(&self) -> u8 {
        self.reps
    }

    pub fn dhi(&self) -> u8 {
        self.dhi
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn function_type(&self) -> u8 {
        self.function_type
    }

    pub fn function_bits(&self) -> u8 {
        self.function_bits
    }

    pub fn im1(&self) -> u8 {
        self.address as u8
    }

    pub fn im2(&self) -> u8 {
        return if self.reps == 0x34 {
            (self.address >> 8) as u8
        } else {
            if self.function_type == 0x20 {
                self.function_bits | 0x20
            } else {
                self.function_type
            }
        }
    }

    pub fn im3(&self) -> u8 {
        return if self.reps() == 0x34 {
            if self.function_type == 0x20 {
                self.function_bits | 0x20
            } else {
                self.function_type
            }
        } else {
            if self.function_type == 0x20 {
                0x00
            } else {
                self.function_bits
            }
        }
    }

    pub fn im4(&self) -> u8 {
        if self.reps() == 0x34 {
            if self.function_type != 0x20 {
                return self.function_bits;
            }
        }
        0x00
    }

    pub fn im5(&self) -> u8 {
        self.im5
    }
}

foreign_class!(class ImArg {
    self_type ImArg;
    constructor ImArg::new(reps: u8, dhi: u8, address: u16, function_type: u8, function_bits: u8, im5: u8) -> ImArg;
    constructor ImArg::parse(check_byte: u8, reps: u8, dhi: u8, im1: u8, im2 : u8, im3: u8, im4: u8, im5: u8) -> ImArg;
    fn ImArg::check_byte(&self) -> u8;
    fn ImArg::reps(&self) -> u8;
    fn ImArg::dhi(&self) -> u8;
    fn ImArg::address(&self) -> u16;
    fn ImArg::function_type(&self) -> u8;
    fn ImArg::function_bits(&self) -> u8;
    fn ImArg::im1(&self) -> u8;
    fn ImArg::im2(&self) -> u8;
    fn ImArg::im3(&self) -> u8;
    fn ImArg::im4(&self) -> u8;
    fn ImArg::im5(&self) -> u8;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataTime(FastClock, TrkArg, IdArg);

impl WrSlDataTime {
    pub fn new(fast_clock: FastClock, trk_arg: TrkArg, id_arg: IdArg) -> Self {
        WrSlDataTime(fast_clock, trk_arg, id_arg)
    }

    pub fn parse(clk_rate: u8, frac_minsh: u8, frac_minsl: u8, mins: u8, trk: u8, hours: u8, days: u8, clk_cntr: u8, id1: u8, id2: u8) -> Self {
        WrSlDataTime(FastClock::parse(clk_rate, frac_minsl, frac_minsh, mins, hours, days, clk_cntr),
                     TrkArg::parse(trk),
                     IdArg::parse(id1, id2))
    }

    pub fn fast_clock(&self) -> FastClock {
        self.0
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.1
    }

    pub fn id_arg(&self) -> IdArg {
        self.2
    }
}

foreign_class!(class WrSlDataTime {
    self_type WrSlDataTime;
    constructor WrSlDataTime::new(_: FastClock, _: TrkArg, _: IdArg) -> WrSlDataTime;
    fn WrSlDataTime::fast_clock(&self) -> FastClock;
    fn WrSlDataTime::trk_arg(&self) -> TrkArg;
    fn WrSlDataTime::id_arg(&self) -> IdArg;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataPt(Pcmd, Hopsa, Lopsa, TrkArg, CvArg, DataArg);

impl WrSlDataPt {
    pub fn new(pcmd: Pcmd, hopsa: Hopsa, lopsa: Lopsa, trk_arg: TrkArg, cv_arg: CvArg, data_arg: DataArg) -> Self {
        WrSlDataPt(pcmd, hopsa, lopsa, trk_arg, cv_arg, data_arg)
    }

    pub fn parse(pcmd: u8, _arg3: u8, hopsa: u8, lopsa: u8, trk: u8, cvh: u8, cvl: u8, data7: u8, _arg10: u8, _arg11: u8) -> Self {
        WrSlDataPt(Pcmd::parse(pcmd), Hopsa::parse(hopsa), Lopsa::parse(lopsa), TrkArg::parse(trk), CvArg::parse(cvh, cvl), DataArg::parse(data7))
    }

    pub fn pcmd(&self) -> Pcmd {
        self.0
    }

    pub fn hopsa(&self) -> Hopsa {
        self.1
    }

    pub fn lopsa(&self) -> Lopsa {
        self.2
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.3
    }

    pub fn cv_arg(&self) -> CvArg {
        self.4
    }

    pub fn data_arg(&self) -> DataArg {
        self.5
    }
}

foreign_class!(class WrSlDataPt {
    self_type WrSlDataPt;
    constructor WrSlDataPt::new(_: Pcmd, _: Hopsa, _: Lopsa, _: TrkArg, _: CvArg, _: DataArg) -> WrSlDataPt;
    fn WrSlDataPt::pcmd(&self) -> Pcmd;
    fn WrSlDataPt::hopsa(&self) -> Hopsa;
    fn WrSlDataPt::lopsa(&self) -> Lopsa;
    fn WrSlDataPt::trk_arg(&self) -> TrkArg;
    fn WrSlDataPt::cv_arg(&self) -> CvArg;
    fn WrSlDataPt::data_arg(&self) -> DataArg;
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataGeneral(SlotArg, Stat1Arg, Stat2Arg, AddressArg, SpeedArg, DirfArg, TrkArg, SndArg, IdArg);

impl WrSlDataGeneral {
    pub fn new(slot_arg: SlotArg, stat1_arg: Stat1Arg, stat2_arg: Stat2Arg, address_arg: AddressArg, speed_arg: SpeedArg, dirf_arg: DirfArg, trk_arg: TrkArg, id_arg: IdArg) -> Self {
        WrSlDataGeneral(slot_arg, stat1_arg, stat2_arg, address_arg, speed_arg, dirf_arg, trk_arg, SndArg(0), id_arg)
    }

    pub fn parse(slot: u8, stat1: u8, adr: u8, spd: u8, dirf: u8, trk: u8, stat2: u8, adr2: u8, snd: u8, id1: u8, id2: u8) -> Self {
        WrSlDataGeneral(SlotArg::parse(slot),
                        Stat1Arg::parse(stat1),
                        Stat2Arg::parse(stat2),
                        AddressArg::parse(adr2, adr),
                        SpeedArg::parse(spd),
                        DirfArg::parse(dirf),
                        TrkArg::parse(trk),
                        SndArg::parse(snd),
                        IdArg::parse(id1, id2))
    }

    pub fn slot_arg(&self) -> SlotArg {
        self.0
    }

    pub fn stat1_arg(&self) -> Stat1Arg {
        self.1
    }

    pub fn stat2_arg(&self) -> Stat2Arg {
        self.2
    }

    pub fn address_arg(&self) -> AddressArg {
        self.3
    }

    pub fn speed_arg(&self) -> SpeedArg {
        self.4
    }

    pub fn dirf_arg(&self) -> DirfArg {
        self.5
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.6
    }

    pub fn snd_arg(&self) -> SndArg {
        self.7
    }

    pub fn id_arg(&self) -> IdArg {
        self.8
    }

    pub fn set_snd_arg(&mut self, snd_arg: SndArg) {
        self.7 = snd_arg;
    }
}

foreign_class!(class WrSlDataGeneral {
    self_type WrSlDataGeneral;
    constructor WrSlDataGeneral::new(_: SlotArg, _: Stat1Arg, _: Stat2Arg, _: AddressArg, _: SpeedArg, _: DirfArg, _: TrkArg, _: IdArg) -> WrSlDataGeneral;
    fn WrSlDataGeneral::slot_arg(&self) -> SlotArg;
    fn WrSlDataGeneral::stat1_arg(&self) -> Stat1Arg;
    fn WrSlDataGeneral::stat2_arg(&self) -> Stat2Arg;
    fn WrSlDataGeneral::address_arg(&self) -> AddressArg;
    fn WrSlDataGeneral::speed_arg(&self) -> SpeedArg;
    fn WrSlDataGeneral::dirf_arg(&self) -> DirfArg;
    fn WrSlDataGeneral::trk_arg(&self) -> TrkArg;
    fn WrSlDataGeneral::snd_arg(&self) -> SndArg;
    fn WrSlDataGeneral::id_arg(&self) -> IdArg;
    fn WrSlDataGeneral::set_snd_arg(&mut self, _: SndArg);
});

#[derive(Debug, Copy, Clone)]
pub struct WrSlDataStructure {
    slot_type: u8,
    time_slot: WrSlDataTime,
    pt_slot: WrSlDataPt,
    general_slot: WrSlDataGeneral
}

impl WrSlDataStructure {
    pub fn new(slot_type: u8, time_slot: WrSlDataTime, pt_slot: WrSlDataPt, general_slot: WrSlDataGeneral) -> Self {
        WrSlDataStructure { slot_type, time_slot, pt_slot, general_slot }
    }

    pub fn parse(arg1: u8, arg2: u8, arg3: u8, arg4: u8, arg5: u8, arg6: u8, arg7: u8, arg8: u8, arg9: u8, arg10: u8, arg11: u8) -> Self {
        let slot_type = if arg1 == 0x7C { 0x7C } else if arg1 == 0x7B { 0x7B } else { 0x00 };

        let time_slot = WrSlDataTime::parse(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        let pt_slot = WrSlDataPt::parse(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        let general_slot = WrSlDataGeneral::parse(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

        WrSlDataStructure{ slot_type, time_slot, pt_slot, general_slot }
    }

    pub fn slot_type(&self) -> u8 {
        self.slot_type
    }

    pub fn time_slot(&self) -> WrSlDataTime {
        self.time_slot
    }

    pub fn pt_slot(&self) -> WrSlDataPt {
        self.pt_slot
    }

    pub fn general_slot(&self) -> WrSlDataGeneral {
        self.general_slot
    }

    pub fn to_message(&self) -> Vec<u8> {
        if self.slot_type == 0x7C {
            return vec![0xEF as u8, 0x0E as u8, 0x7C as u8, self.pt_slot.0.pcmd(), 0x00 as u8, self.pt_slot.1.o_mode(), self.pt_slot.2.o_mode(), self.pt_slot.3.trk_arg(), self.pt_slot.4.cvh(), self.pt_slot.4.cvl(), self.pt_slot.5.data(), 0x00 as u8, 0x00 as u8];
        } else if self.slot_type == 0x7B {
            return vec![0xEF as u8, 0x0E as u8, 0x7B as u8, self.time_slot.0.clk_rate(), self.time_slot.0.frac_minsl(), self.time_slot.0.frac_minsh(), self.time_slot.0.mins(), self.time_slot.1.trk_arg(), self.time_slot.0.hours(), self.time_slot.0.days(), self.time_slot.0.clk_cntrl(), self.time_slot.2.id1(), self.time_slot.2.id2()];
        }
        return vec![0xEF as u8, 0x0E as u8, self.general_slot.0.slot(), self.general_slot.1.stat1(), self.general_slot.3.adr1(), self.general_slot.4.spd(), self.general_slot.5.dirf(), self.general_slot.6.trk_arg(), self.general_slot.2.stat2(), self.general_slot.3.adr2(), self.general_slot.7.snd(), self.general_slot.8.id1(), self.general_slot.8.id2()];
    }
}

foreign_class!(class WrSlDataStructure {
    self_type WrSlDataStructure;
    constructor WrSlDataStructure::new(_: u8, _: WrSlDataTime, _: WrSlDataPt, _: WrSlDataGeneral) -> WrSlDataStructure;
    fn WrSlDataStructure::slot_type(&self) -> u8;
    fn WrSlDataStructure::time_slot(&self) -> WrSlDataTime;
    fn WrSlDataStructure::pt_slot(&self) -> WrSlDataPt;
    fn WrSlDataStructure::general_slot(&self) -> WrSlDataGeneral;
});

#[derive(Debug, Copy, Clone)]
pub struct LissyIrReport {
    arg1: u8,
    dir: bool,
    unit: u16,
    address: u16,
    arg6: u8
}

impl LissyIrReport {
    pub fn new(dir: bool, unit: u16, address: u16, arg6: u8) -> Self {
        LissyIrReport{
            arg1:0x00,
            dir,
            unit,
            address,
            arg6
        }
    }

    pub fn parse(arg1: u8, high_unit: u8, low_unit: u8, high_adr: u8, low_adr: u8, arg6: u8) -> Self {
        assert_eq!(arg1, 0x00, "Given message is not a LissyIR report!");

        let dir = high_unit & 0x40 == 0x40;
        let unit = (((high_unit & 0x3F) as u16) << 7) | (low_unit as u16);
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);

        LissyIrReport{arg1, dir, unit, address, arg6}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let mut high_unit = ((self.unit >> 7) as u8) & 0x3F;
        if self.dir {
            high_unit |= 0x40;
        }
        let low_unit = self.unit as u8 & 0x7F;
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = self.address as u8 & 0x7F;
        vec![0xE4, 0x08, self.arg1, high_unit, low_unit, high_adr, low_adr, self.arg6]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn arg6(&self) -> u8 {
        self.arg6
    }

    pub fn dir(&self) -> bool {
        self.dir
    }

    pub fn unit(&self) -> u16 {
        self.unit
    }

    pub fn address(&self) -> u16 {
        self.address
    }
}

foreign_class!(class LissyIrReport {
    self_type LissyIrReport;
    constructor LissyIrReport::new(dir: bool, unit: u16, address: u16, arg6: u8) -> LissyIrReport;
    fn LissyIrReport::arg1(&self) -> u8;
    fn LissyIrReport::arg6(&self) -> u8;
    fn LissyIrReport::dir(&self) -> bool;
    fn LissyIrReport::unit(&self) -> u16;
    fn LissyIrReport::address(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct RFID5Report {
    arg1: u8,
    address: u16,
    rfid0: u8,
    rfid1: u8,
    rfid2: u8,
    rfid3: u8,
    rfid4: u8,
    rfid_hi: u8
}

impl RFID5Report {
    pub fn new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> Self {
        RFID5Report{ arg1:0x41, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid_hi }
    }

    pub fn parse(arg1: u8, high_adr: u8, low_adr: u8, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> Self {
        assert_eq!(arg1, 0x41, "Given message is not a RFID-5 report!");
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);
        RFID5Report{ arg1, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid_hi }
    }

    pub fn to_message(&self) -> Vec<u8> {
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = (self.address as u8) & 0x7F;
        vec![0xE4, 0x0C, self.arg1, high_adr, low_adr, self.rfid0, self.rfid1, self.rfid2, self.rfid3, self.rfid4, self.rfid_hi]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn rfid0(&self) -> u8 {
        self.rfid0
    }

    pub fn rfid1(&self) -> u8 {
        self.rfid1
    }

    pub fn rfid2(&self) -> u8 {
        self.rfid2
    }

    pub fn rfid3(&self) -> u8 {
        self.rfid3
    }

    pub fn rfid4(&self) -> u8 {
        self.rfid4
    }

    pub fn rfid_hi(&self) -> u8 {
        self.rfid_hi
    }
}

foreign_class!(class RFID5Report {
    self_type RFID5Report;
    constructor RFID5Report::new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> RFID5Report;
    fn RFID5Report::arg1(&self) -> u8;
    fn RFID5Report::rfid0(&self) -> u8;
    fn RFID5Report::rfid1(&self) -> u8;
    fn RFID5Report::rfid2(&self) -> u8;
    fn RFID5Report::rfid3(&self) -> u8;
    fn RFID5Report::rfid4(&self) -> u8;
    fn RFID5Report::rfid_hi(&self) -> u8;
    fn RFID5Report::address(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct RFID7Report {
    arg1: u8,
    address: u16,
    rfid0: u8,
    rfid1: u8,
    rfid2: u8,
    rfid3: u8,
    rfid4: u8,
    rfid5: u8,
    rfid6: u8,
    rfid_hi: u8
}

impl RFID7Report {
    pub fn new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> Self {
        RFID7Report{ arg1:0x41, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid5, rfid6, rfid_hi }
    }

    pub fn parse(arg1: u8, high_adr: u8, low_adr: u8, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> Self {
        assert_eq!(arg1, 0x41, "Given message is not a RFID-7 report!");
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);
        RFID7Report{arg1, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid5, rfid6, rfid_hi}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = (self.address as u8) & 0x7F;
        vec![0xE4, 0x0E, self.arg1, high_adr, low_adr, self.rfid0, self.rfid1, self.rfid2, self.rfid3, self.rfid4, self.rfid5, self.rfid6, self.rfid_hi]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn rfid0(&self) -> u8 {
        self.rfid0
    }

    pub fn rfid1(&self) -> u8 {
        self.rfid1
    }

    pub fn rfid2(&self) -> u8 {
        self.rfid2
    }

    pub fn rfid3(&self) -> u8 {
        self.rfid3
    }

    pub fn rfid4(&self) -> u8 {
        self.rfid4
    }

    pub fn rfid5(&self) -> u8 {
        self.rfid5
    }

    pub fn rfid6(&self) -> u8 {
        self.rfid6
    }

    pub fn rfid_hi(&self) -> u8 {
        self.rfid_hi
    }
}

foreign_class!(class RFID7Report {
    self_type RFID7Report;
    constructor RFID7Report::new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> RFID7Report;
    fn RFID7Report::arg1(&self) -> u8;
    fn RFID7Report::rfid0(&self) -> u8;
    fn RFID7Report::rfid1(&self) -> u8;
    fn RFID7Report::rfid2(&self) -> u8;
    fn RFID7Report::rfid3(&self) -> u8;
    fn RFID7Report::rfid4(&self) -> u8;
    fn RFID7Report::rfid5(&self) -> u8;
    fn RFID7Report::rfid6(&self) -> u8;
    fn RFID7Report::rfid_hi(&self) -> u8;
    fn RFID7Report::address(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct WheelcntReport {
    arg1: u8,
    unit: u16,
    direction: bool,
    count: u16,
    arg6: u8
}

impl WheelcntReport {
    pub fn new(unit: u16, direction: bool, count: u16, arg6: u8) -> Self {
        WheelcntReport{ arg1:0x40, unit, direction, count, arg6 }
    }

    pub fn parse(arg1: u8, high_unit: u8, low_unit: u8, high_count: u8, low_count: u8, arg6: u8) -> Self {
        assert_eq!(arg1, 0x40, "Given message is not a wheelcnt report!");
        let count = ((high_count as u16) << 7) | (low_count as u16);
        let direction = high_unit & 0x40 == 0x40;
        let unit = (((high_unit & 0x3F) as u16) << 7) | (low_unit as u16);
        WheelcntReport{arg1, unit, direction, count, arg6}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let mut high_unit = ((self.unit >> 7) as u8) & 0x3F;
        if self.direction {
            high_unit |= 0x40;
        }
        let low_unit = self.unit as u8 & 0x7F;
        let high_count = ((self.count >> 7) as u8) & 0x7F;
        let low_count = self.count as u8 & 0x7F;
        vec![0xE4, 0x08, self.arg1, high_unit, low_unit, high_count, low_count, self.arg6]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn arg6(&self) -> u8 {
        self.arg6
    }

    pub fn unit(&self) -> u16 {
        self.unit
    }

    pub fn count(&self) -> u16 {
        self.count
    }

    pub fn direction(&self) -> bool {
        self.direction
    }
}

foreign_class!(class WheelcntReport {
    self_type WheelcntReport;
    constructor WheelcntReport::new(unit: u16, direction: bool, count: u16, arg6: u8) -> WheelcntReport;
    fn WheelcntReport::arg1(&self) -> u8;
    fn WheelcntReport::arg6(&self) -> u8;
    fn WheelcntReport::unit(&self) -> u16;
    fn WheelcntReport::count(&self) -> u16;
    fn WheelcntReport::direction(&self) -> bool;
});

#[derive(Debug, Copy, Clone)]
pub enum RepStructure {
    LissyIrReport(LissyIrReport),
    RFID5Report(RFID5Report),
    RFID7Report(RFID7Report),
    WheelcntReport(WheelcntReport)
}

impl RepStructure {
    pub fn parse(count: u8, args: &[u8]) -> Self {
        return if args[0] == 0x00 {
            Self::LissyIrReport(LissyIrReport::parse(args[0], args[1], args[2], args[3], args[4], args[5]))
        } else if args[0] == 0x40 {
            Self::WheelcntReport(WheelcntReport::parse(args[0], args[1], args[2], args[3], args[4], args[5]))
        } else if args[0] == 0x41 && count == 0x0C {
            Self::RFID5Report(RFID5Report::parse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]))
        } else {
            Self::RFID7Report(RFID7Report::parse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]))
        }
    }
}

#[derive(Debug, Copy, Clone)]
pub struct DstArg(u16);

impl DstArg {
    pub fn new(dst: u16) -> Self {
        DstArg(dst)
    }

    pub fn parse(dst_low: u8, dst_high: u8) -> Self {
        let dst = ((dst_high as u16) << 7) | (dst_low as u16);
        DstArg(dst)
    }

    pub fn dst(&self) -> u16 {
        self.0
    }

    pub fn dst_low(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn dst_high(&self) -> u8 {
        (self.0 >> 7) as u8 & 0x7F
    }
}

foreign_class!(class DstArg {
    self_type DstArg;
    constructor DstArg::new(dst: u16) -> DstArg;
    fn DstArg::dst(&self) -> u16;
});

#[derive(Debug, Copy, Clone)]
pub struct PxctData {
    pxc: u8,
    d1: u8,
    d2: u8,
    d3: u8,
    d4: u8,
    d5: u8,
    d6: u8,
    d7: u8,
    d8: u8
}

impl PxctData {
    pub fn new(pxc: u8, d1: u8, d2: u8, d3: u8, d4: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> Self {
        PxctData { pxc, d1, d2, d3, d4, d5, d6, d7, d8 }
    }

    pub fn parse(pxct1: u8, d1: u8, d2: u8, d3: u8, d4: u8, pxct2: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> Self {
        let pxc = ((pxct1 & 0x70) >> 4) | ((pxct2 & 0x70) >> 1);

        PxctData{pxc, d1: d1 | ((pxct1 & 0x01) << 7), d2: d2 | ((pxct1 & 0x02) << 6), d3: d3 | ((pxct1 & 0x04) << 5), d4: d4 | ((pxct1 & 0x08) << 4), d5: d5 | ((pxct2 & 0x01) << 7), d6: d6 | ((pxct2 & 0x02) << 6), d7: d7 | ((pxct2 & 0x04) << 5), d8: d8 | ((pxct2 & 0x08) << 4)}
    }

    pub fn pxc(&self) -> u8 {
        self.pxc
    }

    pub fn pxct1(&self) -> u8 {
        let mut pxct1 = self.pxc & 0x07 << 4;

        if self.d1 & 0x40 == 0x40 {
            pxct1 |= 0x01;
        }
        if self.d2 & 0x40 == 0x40 {
            pxct1 |= 0x02;
        }
        if self.d3 & 0x40 == 0x40 {
            pxct1 |= 0x04;
        }
        if self.d4 & 0x40 == 0x40 {
            pxct1 |= 0x08;
        }

        pxct1
    }

    pub fn pxct2(&self) -> u8 {
        let mut pxct1 = self.pxc & 0x78 << 1;

        if self.d5 & 0x40 == 0x40 {
            pxct1 |= 0x01;
        }
        if self.d6 & 0x40 == 0x40 {
            pxct1 |= 0x02;
        }
        if self.d7 & 0x40 == 0x40 {
            pxct1 |= 0x04;
        }
        if self.d8 & 0x40 == 0x40 {
            pxct1 |= 0x08;
        }

        pxct1
    }

    pub fn d1(&self) -> u8 {
        self.d1 & 0x3F
    }

    pub fn d2(&self) -> u8 {
        self.d2 & 0x3F
    }

    pub fn d3(&self) -> u8 {
        self.d3 & 0x3F
    }

    pub fn d4(&self) -> u8 {
        self.d4 & 0x3F
    }

    pub fn d5(&self) -> u8 {
        self.d5 & 0x3F
    }

    pub fn d6(&self) -> u8 {
        self.d6 & 0x3F
    }

    pub fn d7(&self) -> u8 {
        self.d7 & 0x3F
    }

    pub fn d8(&self) -> u8 {
        self.d8 & 0x3F
    }
}

foreign_class!(class PxctData {
    self_type PxctData;
    constructor PxctData::new(pxc: u8, d1: u8, d2: u8, d3: u8, d4: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> PxctData;
    fn PxctData::pxc(&self) -> u8;
    fn PxctData::d1(&self) -> u8;
    fn PxctData::d2(&self) -> u8;
    fn PxctData::d3(&self) -> u8;
    fn PxctData::d4(&self) -> u8;
    fn PxctData::d5(&self) -> u8;
    fn PxctData::d6(&self) -> u8;
    fn PxctData::d7(&self) -> u8;
    fn PxctData::d8(&self) -> u8;
});