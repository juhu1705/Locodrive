use crate::jni_c_header::*;
use std::fmt::{Debug, Formatter, Display};
use std::time::Duration;
use std::sync::{Arc, Mutex, Condvar};

use std::thread;
use std::thread::JoinHandle;

use std::mem;

use std::io::prelude::*;
use std::io;
use std::io::Write as IoWrite;
use std::fmt::Write as FmtWrite;
use std::result::Result;
use std::env;

use std::error::Error;

use serialport::{DataBits, FlowControl, Parity, StopBits, SerialPort};

#[derive(Debug)]
pub enum MessageParseError {
    UnknownOpcode(u8),
    UnexpectedEnd,
    InvalidChecksum,
    IoError(io::Error),
    Update(io::Error)
}

impl Display for MessageParseError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnknownOpcode(opc) => write!(f, "unknown opcode: {:x}", opc),
            Self::UnexpectedEnd => write!(f, "unexpected end of stream"),
            Self::InvalidChecksum => write!(f, "invalid checksum"),
            Self::IoError(err) => write!(f, "io error: {}", err),
            Self::Update(err) => write!(f, "io error: {}", err),
        }
    }
}

impl Error for MessageParseError {}

impl MessageParseError {
    fn msg(&self) -> String {
        let mut f = String::new();
        match self {
            Self::UnknownOpcode(opc) => write!(&mut f, "unknown opcode: {:x}", opc).unwrap_or(()),
            Self::UnexpectedEnd => write!(&mut f, "unexpected end of stream").unwrap_or(()),
            Self::InvalidChecksum => write!(&mut f, "invalid checksum").unwrap_or(()),
            Self::IoError(err) => write!(&mut f, "io error: {}", err).unwrap_or(()),
            Self::Update(err) => write!(&mut f, "io error: {}", err).unwrap_or(()),
        };
        f
    }

    fn error_type(&self) -> u8 {
        return match self {
            Self::UnknownOpcode(_opc) => 0,
            Self::UnexpectedEnd => 1,
            Self::InvalidChecksum => 2,
            Self::IoError(_err) => 3,
            Self::Update(_err) => 4,
        }
    }

    fn get_unknown_opc(&self) -> u8 {
        match self {
            Self::UnknownOpcode(opc) => *opc,
            _ => { panic!("No unexpected opc!") },
        }
    }
}

foreign_class!(
    /// A class representing a rust error, when sending to or reading from the loco net fails
    class MessageParseError {
        self_type MessageParseError;
        private constructor = empty;
        /// @return The message of this error
        fn MessageParseError::msg(&self) -> String; alias toString;
        /// @return The error type of this error. (1 - unknown op code, 2 - unexpected end, 3 - invalid checksum, 4 - io error, 5 - update (only for rust intern use should not be thrown))
        fn MessageParseError::error_type(&self) -> u8; alias getErrorType;
        /// @return The unknown op code only for unknown op code errors. Please do not invoke this method for other errors.
        fn MessageParseError::get_unknown_opc(&self) -> u8; alias getUnknownOpc;
        foreign_code r#"
    /**
     * Checks whether this error is equal to another object.
     * @param o The object to compare to
     * @return If this error is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.toString().equals(((MessageParseError) o).toString());
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
    }
);

#[derive(Debug, Copy, Clone, Eq)]
pub struct AddressArg(u16);

impl AddressArg {
    pub fn new(adr: u16) -> Self {
        Self(adr)
    }

    pub fn parse(adr2: u8, adr: u8) -> Self {
        let mut address = adr as u16;
        address |= (adr2 as u16) << 7;
        Self(address)
    }

    pub fn address(&self) -> u16 {
        self.0
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x3FFF,
            0,
            "address must only use the 14 least significant bits"
        );
        self.0 = address;
    }

    pub fn adr1(&self) -> u8 {
        (self.0 & 0x007F) as u8
    }

    pub fn adr2(&self) -> u8 {
        ((self.0 >> 7) & 0x007F) as u8
    }

    pub fn equals(&self, other: AddressArg) -> bool {
        self.0 == other.0
    }

    pub fn to_string(&self) -> String {
        format!("adr: {}", self.0)
    }
}

impl PartialEq for AddressArg {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Display for AddressArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "adr: {}", self.0)
    }
}

foreign_class!(
    /// This arg represents a loco net address of 14 byte length.
    #[derive(Clone)]
    class AddressArg {
        self_type AddressArg;
        /// Creates a new loco net address. Please consider to keep in range of 14 bytes.
        /// @param address The loco net address
        constructor AddressArg::new(address: u16) -> AddressArg;
        /// @return The 14 byte loco net address
        fn AddressArg::address(&self) -> u16; alias address;
        /// Sets a new 14 byte loco net address to this arg
        /// @param address The 14 byte loco net address
        fn AddressArg::set_address(&mut self, address: u16); alias setAddress;
        /// Checks whether this address is equal to another. To addresses are equal, when their 14 byte addresses are equal.
        /// @param other The other address to check equality with
        /// @return If this address is equal to the other address given
        fn AddressArg::eq(&self, other: &AddressArg) -> bool; alias equals;
        /// @return A string of the format: 'adr: 14 byte address'
        fn AddressArg::to_string(&self) -> String; alias toString;
        foreign_code r#"
    /**
     * Checks whether this address is equal to another object.
     * @param o The object to compare to
     * @return If this address is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((AddressArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.address());
    }
"#;
    }
);

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SwitchDirection {
    Straight,
    Curved,
}

foreign_enum!(
    /// Indicates the state oh a switch
    enum SwitchDirection {
        /// The switch is straight (1)
        STRAIGHT = SwitchDirection::Straight,
        /// The switch is curved (0)
        CURVED = SwitchDirection::Curved,
    }
);

#[derive(Debug, Copy, Clone, Eq)]
pub struct SwitchArg {
    address: u16,
    direction: SwitchDirection,
    state: bool,
}

impl SwitchArg {
    pub fn new(address: u16, direction: SwitchDirection, state: bool) -> Self {
        Self{address, direction, state}
    }

    pub fn parse(sw1: u8, sw2: u8) -> Self {
        let mut address = sw1 as u16;
        address |= (sw2 as u16 & 0x0F) << 7;

        let direction = if sw2 & 0x20 == 0 {
            SwitchDirection::Curved
        } else {
            SwitchDirection::Straight
        };

        let state = (sw2 & 0x10) != 0;
        Self {
            address,
            direction,
            state,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }
    pub fn direction(&self) -> SwitchDirection {
        self.direction
    }
    pub fn state(&self) -> bool {
        self.state
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x07FF,
            0,
            "address must only use the 11 least significant bits"
        );
        self.address = address;
    }
    pub fn set_direction(&mut self, direction: SwitchDirection) {
        self.direction = direction;
    }
    pub fn set_state(&mut self, state: bool) {
        self.state = state;
    }

    pub fn sw1(&self) -> u8 {
        (self.address & 0x007F) as u8
    }

    pub fn sw2(&self) -> u8 {
        let mut sw2 = ((self.address >> 7) & 0x000F) as u8;

        sw2 |= match self.direction {
            SwitchDirection::Curved => 0x00,
            SwitchDirection::Straight => 0x20
        };

        if self.state {
            sw2 |= 0x10;
        }

        sw2
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl PartialEq for SwitchArg {
    fn eq(&self, other: &Self) -> bool {
        self.address == other.address && self.state == other.state && self.direction == other.direction
    }
}

impl Display for SwitchArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "sw: {}, {}, {:?}", self.address, self.state, self.direction)
    }
}

foreign_class!(
    /// Represents a switch loco net message.
    class SwitchArg {
        self_type SwitchArg;
        /// Creates a new switch message
        /// @param address The switch address
        /// @param direction The switch direction
        /// @param state The switch state
        constructor SwitchArg::new(address: u16, direction: SwitchDirection, state: bool) -> SwitchArg;
        /// @return The switch address
        fn SwitchArg::address(&self) -> u16;
        /// @return The switch direction
        fn SwitchArg::direction(&self) -> SwitchDirection;
        /// @return The switch state
        fn SwitchArg::state(&self) -> bool;
        /// Sets the switch address
        /// @param address The switch address
        fn SwitchArg::set_address(&mut self, address: u16); alias setAddress;
        /// Sets the switch direction
        /// @param direction The switch direction
        fn SwitchArg::set_direction(&mut self, direction: SwitchDirection); alias setDirection;
        /// Sets the switch state
        /// @param state The switch state
        fn SwitchArg::set_state(&mut self, state: bool); alias setState;
        /// @return A string in the format "sw: address, direction, state"
        fn SwitchArg::to_string(&self) -> String; alias toString;
        /// @param other Another switch arg to compare
        /// @return If the other switch arg is equals to this
        fn SwitchArg::eq(&self, other: &SwitchArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this switch arg is equal to another object.
     * @param o The object to compare to
     * @return If this switch arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SwitchArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.address(), this.direction(), this.state());
    }
"#;
    }
);

#[derive(Debug, Copy, Clone, Eq)]
pub struct SlotArg(u8);

impl SlotArg {
    pub fn new(slot: u16) -> Self {Self((slot as u8) & 0x7F)}

    pub fn parse(slot: u8) -> Self {
        Self(slot & 0x7F)
    }

    pub fn slot(&self) -> u8 {
        self.0
    }

    pub fn set_slot(&mut self, slot: u8) {
        assert_eq!(
            slot & 0x7F,
            0,
            "number must only use the 7 least significant bits"
        );
        self.0 = slot;
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl PartialEq for SlotArg {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Display for SlotArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "slot: {}", self.0)
    }
}

foreign_class!(
/// This class represents a slot arg, defined by a slot
class SlotArg {
    self_type SlotArg;
        /// Creates a slot with the given slot number
        /// @param slot The slots number (Only 7 least significant bits)
    constructor SlotArg::new(slot: u16) -> SlotArg;
        /// @return The slot of this arg
    fn SlotArg::slot(&self) -> u8;
        /// Sets the slot to the given number
        /// @param slot The slot to set
    fn SlotArg::set_slot(&mut self, slot: u8); alias setSlot;
        /// Checks whether this slot arg is equal to another object.
        /// @param other The slot arg to compare to
        /// @return If this slot arg is equal to the given object
    fn SlotArg::eq(&self, other: &SlotArg) -> bool; alias equals;
        /// @return A string in the format "slot: slot"
    fn SlotArg::to_string(&self) -> String; alias toString;
    foreign_code r#"
    /**
     * Checks whether this slot arg is equal to another object.
     * @param o The object to compare to
     * @return If this slot arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.slot());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SpeedArg {
    Stop,
    EmergencyStop,
    Drive(u8),
}

impl SpeedArg {
    pub fn parse(spd: u8) -> Self {
        match spd {
            0x00 => Self::Stop,
            0x01 => Self::EmergencyStop,
            _ => Self::Drive(spd - 1),
        }
    }

    pub fn new(spd: u16) -> Self {
        match spd {
            0x00 => Self::Stop,
            _ => Self::Drive(spd as u8)
        }
    }

    pub fn new_emergency() -> Self {
        Self::EmergencyStop
    }

    pub fn spd(&self) -> u8 {
        match *self {
            SpeedArg::Stop => 0x00,
            SpeedArg::EmergencyStop => 0x01,
            SpeedArg::Drive(spd) => spd + 1
        }
    }

    pub fn get_spd(&self) -> u8 {
        match *self {
            SpeedArg::Stop => 0x00,
            SpeedArg::EmergencyStop => 0x00,
            SpeedArg::Drive(spd) => spd,
        }
    }

    pub fn is_emergency_stop(&self) -> bool {
        match self {
            SpeedArg::EmergencyStop => true,
            _ => false
        }
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SpeedArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            SpeedArg::Stop => write!(f, "speed: stop"),
            SpeedArg::EmergencyStop => write!(f, "speed: emergency stop"),
            SpeedArg::Drive(spd) => write!(f, "speed: {}", spd)
        }
    }
}

foreign_class!(
    /// This class represents a train speed
    class SpeedArg {
    self_type SpeedArg;
        /// Sets the speed to the given spd. 0 is a normal stop. To set an emergency stop use SpeedArg()
        /// @param spd The speed to set this speed arg to
    constructor SpeedArg::new(spd: u16) -> SpeedArg;
        /// Creates a new SpeedArg with the spd set to emergency stop.
    constructor SpeedArg::new_emergency() -> SpeedArg;
        /// @return The speed of this arg with a value reserved for the emergency stop. 0 - Stop, 1 - Emergency Stop, other - Speed: other-1
    fn SpeedArg::spd(&self) -> u8; alias calculatedSpeed;
        /// @return The speed of this arg. All values are the actual speed, an emergency stop and stop value are both represented as 0.
    fn SpeedArg::get_spd(&self) -> u8; alias spd;
        /// @return If this speed arg represents an emergency stop for this train
    fn SpeedArg::is_emergency_stop(&self) -> bool; alias isEmergencyStop;
        /// @return A string in the format "speed: value" value = stop|emergency stop|speed
    fn SpeedArg::to_string(&self) -> String; alias toString;
        /// Checks whether this speed arg is equal to another speed arg
        /// @param other The speed arg to compare with
        /// @return If this speed arg is equal to the given speed arg
    fn SpeedArg::eq(&self, other: &SpeedArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this speed arg is equal to another object.
     * @param o The object to compare to
     * @return If this speed arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.calculatedSpeed());
    }
"#;
});

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DirfArg(u8);

impl DirfArg {
    pub fn new(dir: bool, f0: bool, f1: bool, f2: bool, f3: bool, f4: bool) -> Self {
        let mut dirf = if dir { 0x20 } else { 0x00 };
        if f0 {
            dirf |= 0x10
        }
        if f1 {
            dirf |= 0x01
        }
        if f2 {
            dirf |= 0x02
        }
        if f3 {
            dirf |= 0x04
        }
        if f4 {
            dirf |= 0x08
        }
        Self(dirf & 0x3F)
    }

    pub fn parse(dirf: u8) -> Self {
        Self(dirf & 0x3F)
    }

    pub fn dir(&self) -> bool {
        self.0 & 0x20 != 0
    }

    pub fn f(&self, f_num: u8) -> bool {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        self.0 >> (if f_num == 0 { 4 } else { f_num - 1 }) & 1 != 0
    }

    pub fn set_dir(&mut self, value: bool) {
        if value {
            self.0 |= 0x20;
        } else {
            self.0 &= !0x20
        }
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(f_num <= 4, "f must be lower than or equal to 4");
        let mask = 1 << if f_num == 0 { 4 } else { f_num - 1 };
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn dirf(&self) -> u8 {
        self.0
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Debug for DirfArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "dirf: (dir: {}, f0: {}, f1: {}, f2: {}, f3: {}, f4: {})",
            self.dir(),
            self.f(0),
            self.f(1),
            self.f(2),
            self.f(3),
            self.f(4)
        )
    }
}

impl Display for DirfArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "dirf: (dir: {}, f0: {}, f1: {}, f2: {}, f3: {}, f4: {})",
            self.dir(),
            self.f(0),
            self.f(1),
            self.f(2),
            self.f(3),
            self.f(4)
        )
    }
}

foreign_class!(
    /// This class represents an direction and function arg
    class DirfArg {
        self_type DirfArg;
        /// Creates a new direction and function arg
        /// @param dir The direction to set
        /// @param f0 The function 0
        /// @param f1 The function 1
        /// @param f2 The function 2
        /// @param f3 The function 3
        /// @param f4 The function 4
        constructor DirfArg::new(dir: bool, f0: bool, f1: bool, f2: bool, f3: bool, f4: bool) -> DirfArg;
        /// Creates a concentrated function and direction arg
        /// @param dirf The function and direction arg to set
        constructor DirfArg::parse(dirf: u8) -> DirfArg;
        /// @return The set direction. true = forward, false = backward
        fn DirfArg::dir(&self) -> bool;
        /// @param fNum The function number to read (0 - 4)
        /// @return The functions value
        fn DirfArg::f(&self, fNum: u8) -> bool;
        /// Sets the direction of this arg
        /// @param dir The direction to set
        fn DirfArg::set_dir(&mut self, dir: bool); alias setDir;
        /// Sets the value f to the function number fNum (0-4)
        fn DirfArg::set_f(&mut self, fNum: u8, f: bool); alias setF;
        /// @return A string in the format "dirf: (dir: dir, f0: f0 - f4: f4)"
        fn DirfArg::to_string(&self) -> String; alias toString;
        /// Checks whether this dirf arg is equal to another dirf arg
        /// @param other The dirf arg to compare to
        /// @return If this dirf arg is equal to the other dirf arg
        fn DirfArg::eq(&self, other: &DirfArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this dirf arg is equal to another object.
     * @param o The object to compare to
     * @return If this dirf arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.dir(), this.f((short) 0), this.f((short) 1), this.f((short) 2), this.f((short) 3), this.f((short) 4));
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct TrkArg {
    power: bool,
    idle: bool,
    mlok1: bool,
    prog_busy: bool,
}

impl TrkArg {
    pub fn new(power: bool, idle: bool, mlok1: bool, prog_busy: bool) -> Self {
        TrkArg {power, idle, mlok1, prog_busy}
    }

    pub fn parse(trk_arg: u8) -> Self {
        let power = trk_arg & 0x01 == 0x01;
        let idle = trk_arg & 0x02 == 0x00;
        let mlok1 = trk_arg & 0x04 == 0x04;
        let prog_busy = trk_arg & 0x08 == 0x08;
        TrkArg {
            power,
            idle,
            mlok1,
            prog_busy,
        }
    }

    pub fn power_on(&self) -> bool {
        self.power
    }

    pub fn track_idle(&self) -> bool {
        self.idle
    }

    pub fn mlok1(&self) -> bool {
        self.mlok1
    }

    pub fn prog_busy(&self) -> bool {
        self.prog_busy
    }

    pub fn trk_arg(&self) -> u8 {
        let mut trk_arg = if self.power { 0x01 } else { 0x00 };
        if !self.idle {
            trk_arg |= 0x02;
        }
        if self.mlok1 {
            trk_arg |= 0x04;
        }
        if self.prog_busy {
            trk_arg |= 0x08;
        }
        trk_arg
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for TrkArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "trk_arg: (power: {}, idle: {}, mlok1: {}, prog_busy: {})",
            self.power,
            self.idle,
            self.mlok1,
            self.prog_busy
        )
    }
}

foreign_class!(
    /// This class holds the track parameters
    class TrkArg {
        self_type TrkArg;
        /// Creates a new track arg
        /// @param power True = DCC packets are on in master and global power is up
        /// @param idle Ture = The track is paused (emergency stop)
        /// @param mlok1 True = This master implements LocoNet 1.1 capability, False = Master is DT200
        /// @param progBusy True = Programming track in this master is busy
        constructor TrkArg::new(power: bool, idle: bool, mlok1: bool, progBusy: bool) -> TrkArg;
        /// @return If dcc packets can be send to track and if the track has energy
        fn TrkArg::power_on(&self) -> bool; alias powerOn;
        /// @return If the track is paused by something like an emergency stop
        fn TrkArg::track_idle(&self) -> bool; alias trackIdle;
        /// @return If this master implements LocoNet 1.1 capability (true) or this master is DT200 (false)
        fn TrkArg::mlok1(&self) -> bool;
        /// @return If the programming track is in state busy
        fn TrkArg::prog_busy(&self) -> bool; alias progBusy;
        /// @return A string in the format "trk_arg: (power: power, idle: idle, mlok1: mlok1, prog_busy: prog_busy)"
        fn TrkArg::to_string(&self) -> String; alias toString;
        /// Checks whether this trk arg is equal to another trk arg
        /// @param other The trk arg to compare to
        /// @return If this trk arg is equal to the other trk arg
        fn TrkArg::eq(&self, other: &TrkArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this trk arg is equal to another object.
     * @param o The object to compare to
     * @return If this trk arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((TrkArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.powerOn(), this.trackIdle(), this.mlok1(), this.progBusy());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SndArg(u8);

impl SndArg {
    pub fn parse(snd: u8) -> Self {
        Self(snd & 0x0F)
    }
    pub fn new(f5: bool, f6: bool, f7: bool, f8: bool) -> Self{
        let mut snd = if f5 { 0x01 } else { 0x00 } as u8;
        if f6 {
            snd |= 0x02
        }
        if f7 {
            snd |= 0x04
        }
        if f8 {
            snd |= 0x08
        }
        Self(snd)
    }

    pub fn f(&self, f_num: u8) -> bool {
        assert!(
            (5..=8).contains(&f_num),
            "f_num must be within 5 and 8 (inclusive)"
        );
        self.0 & 1 << (f_num - 5) != 0
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        assert!(
            (5..=8).contains(&f_num),
            "f_num must be within 5 and 8 (inclusive)"
        );
        let mask = 1 << (f_num - 5);
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn snd(&self) -> u8 {
        self.0
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SndArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "snd: (f5: {}, f6: {}, f7: {}, f8: {})",
            self.f(5),
            self.f(6),
            self.f(7),
            self.f(8)
        )
    }
}


foreign_class!(
    /// This arg holds the trains sound function parameters f5 to f8
    class SndArg {
        self_type SndArg;
        /// Sets a new snd arg by parsing the least significant four bits as functions f8 to f5
        /// @param snd The snd function values as short. The least significant 4 bits are the function values
        constructor SndArg::parse(snd: u8) -> SndArg;
        /// Sets a new snd arg by giving the functions values
        /// @param f5 The f5 function value
        /// @param f6 The f6 function value
        /// @param f7 The f7 function value
        /// @param f8 The f8 function value
        constructor SndArg::new(f5: bool, f6: bool, f7: bool, f8: bool) -> SndArg;
        /// Calculates the function value of position fNum. Only values between 5 and 8 (inclusive) are allowed
        /// @param fNum The position of the value to read (5-8)
        /// @return The value of the position
        fn SndArg::f(&self, fNum: u8) -> bool;
        /// Sets the function value at the position fNum. For fNum only values between 5 and 8 (inclusive) are allowed
        /// @param fNum The position to set the value at
        /// @param f The value for the position
        fn SndArg::set_f(&mut self, fNum: u8, f: bool); alias setF;
        /// @return A string in the format "snd: (f5: f5, f6: f6, f7: f7, f8: f8)"
        fn SndArg::to_string(&self) -> String; alias toString;
        /// Checks whether this snd arg is equal to another snd arg
        /// @param other The snd arg to compare to
        /// @return If this snd arg is equal to the other snd arg
        fn SndArg::eq(&self, other: &SndArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this snd arg is equal to another object.
     * @param o The object to compare to
     * @return If this trk snd is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SndArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.f((short) 5), this.f((short) 6), this.f((short) 7), this.f((short) 8));
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Consist {
    LogicalMid,
    LogicalTop,
    LogicalSubMember,
    Free,
}

foreign_enum!(
    /// The linking status of the slot. Any up consisted slots should be unlinked before usage!
    enum Consist {
        /// Slot linked up and downwards
        LOGICAL_MID = Consist::LogicalMid,
        /// Slot linked downwards
        LOGICAL_TOP = Consist::LogicalTop,
        /// Slot linked upwards
        LOGICAL_SUB_MEMBER = Consist::LogicalSubMember,
        /// Slot free for locomotive, no consist indirection or linking
        FREE = Consist::Free,
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum State {
    InUse,
    Idle,
    Common,
    Free,
}

foreign_enum!(
    /// The state of the slots loco address
    enum State {
        /// Address in slot refreshed and busy
        IN_USE = State::InUse,
        /// Address in slot not refreshed
        IDLE = State::Idle,
        /// Address in slot refreshed, slot not busy
        COMMON = State::Common,
        /// No valid slot data, slot is free
        FREE = State::Free,
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum DecoderType {
    Dcc28,
    Dcc128,
    Regular28,
    AdrMobile28,
    Step14,
    Speed128,
}

foreign_enum!(
    /// The decoder types encoding of this slot
    enum DecoderType {
        /// Allow advanced dcc with 28 speed steps
        DCC_28 = DecoderType::Dcc28,
        /// Allow advanced dcc with 128 speed steps
        DCC_128 = DecoderType::Dcc128,
        /// 28 speed steps with 3 byte pkt in regular mode
        REGULAR_28 = DecoderType::Regular28,
        /// 28 speed steps. Trinary packets for mobile address
        ADR_MOBILE_28 = DecoderType::AdrMobile28,
        /// 14 speed steps. No special packets
        STEP_14 = DecoderType::Step14,
        /// 128 speed steps. No special packets
        SPEED_128 = DecoderType::Speed128,
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Stat1Arg {
    spurge: bool,
    consist: Consist,
    state: State,
    decoder_type: DecoderType,
}

impl Stat1Arg {
    pub fn new(spurge: bool, consist: Consist, state: State, decoder_type: DecoderType) -> Self {
        Stat1Arg { spurge, consist, state, decoder_type }
    }

    pub fn parse(stat1: u8) -> Self {
        let spurge = stat1 & 0x80 != 0;

        let consist = match stat1 & 0x48 {
            0x48 => Consist::LogicalMid,
            0x08 => Consist::LogicalTop,
            0x40 => Consist::LogicalSubMember,
            0x00 => Consist::Free,
            _ => panic!("No valid consist is given!"),
        };

        let state = match stat1 & 0x30 {
            0x30 => State::InUse,
            0x20 => State::Idle,
            0x10 => State::Common,
            0x00 => State::Free,
            _ => panic!("No valid state is given!"),
        };

        let decoder_type = match stat1 & 0x07 {
            0x02 => DecoderType::Step14,
            0x01 => DecoderType::AdrMobile28,
            0x00 => DecoderType::Regular28,
            0x03 => DecoderType::Speed128,
            0x07 => DecoderType::Dcc128,
            0x04 => DecoderType::Dcc28,
            _ => panic!("The given decoder type was invalid!"),
        };

        Stat1Arg {
            spurge,
            consist,
            state,
            decoder_type,
        }
    }

    pub fn spurge(&self) -> bool {
        self.spurge
    }

    pub fn consist(&self) -> Consist {
        self.consist
    }

    pub fn state(&self) -> State {
        self.state
    }

    pub fn decoder_type(&self) -> DecoderType {
        self.decoder_type
    }

    pub fn stat1(&self) -> u8 {
        let mut stat1: u8 = if self.spurge { 0x80 } else { 0x00 };

        stat1 |= match self.consist {
            Consist::LogicalMid => 0x48,
            Consist::LogicalTop => 0x08,
            Consist::LogicalSubMember => 0x40,
            Consist::Free => 0x00
        };

        stat1 |= match self.state {
            State::InUse => 0x30,
            State::Idle => 0x20,
            State::Common => 0x10,
            State::Free => 0x00
        };

        stat1 |= match self.decoder_type {
            DecoderType::Dcc28 => 0x04,
            DecoderType::Dcc128 => 0x07,
            DecoderType::Regular28 => 0x00,
            DecoderType::AdrMobile28 => 0x01,
            DecoderType::Step14 => 0x02,
            DecoderType::Speed128 => 0x03
        };

        stat1
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Stat1Arg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "stat1: (spurge: {}, consist: {:?}, state: {:?}, decoder_type: {:?})",
            self.spurge,
            self.consist,
            self.state,
            self.decoder_type
        )
    }
}

foreign_class!(
    /// Holds status information of a slot
    class Stat1Arg {
        self_type Stat1Arg;
        /// Set the status information for a new slot1 argument
        /// @param spurge Internal use only. Represents the slot purge en state
        /// @param consist The consist state of this slot
        /// @param state The loco address state of this slot
        /// @param decoder The decoder type of this slot
        constructor Stat1Arg::new(spurge: bool, consist: Consist, state: State, decoder: DecoderType) -> Stat1Arg;
        /// @return The slots purge en state. Internal loco net use only.
        fn Stat1Arg::spurge(&self) -> bool;
        /// @return The slots consist state
        fn Stat1Arg::consist(&self) -> Consist;
        /// @return The slots loco address state
        fn Stat1Arg::state(&self) -> State;
        /// @return The slots decoder type
        fn Stat1Arg::decoder_type(&self) -> DecoderType; alias decoderType;
        /// @return A string in the format "stat1: (spurge: spurge, consist: consist, state: state, decoder_type: decoder_type)"
        fn Stat1Arg::to_string(&self) -> String; alias toString;
        /// Checks whether this stat1 arg is equal to another stat1 arg
        /// @param other The stat1 arg to compare to
        /// @return If this stat1 arg is equal to the other stat1 arg
        fn Stat1Arg::eq(&self, other: &Stat1Arg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this stat1 arg is equal to another object.
     * @param o The object to compare to
     * @return If this stat1 arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Stat1Arg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.spurge(), this.consist(), this.state(), this.decoderType());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Stat2Arg {
    has_adv: bool,
    no_id_usage: bool,
    id_encoded_alias: bool,
}

impl Stat2Arg {
    pub fn new(has_adv: bool, no_id_usage: bool, id_encoded_alias: bool) -> Self {
        Stat2Arg{ has_adv, no_id_usage, id_encoded_alias }
    }

    pub fn parse(stat2: u8) -> Self {
        let has_adv = stat2 & 0x01 != 0;

        let no_id_usage = stat2 & 0x04 != 0;

        let id_encoded_alias = stat2 & 0x08 != 0;

        Stat2Arg {
            has_adv,
            no_id_usage,
            id_encoded_alias,
        }
    }

    pub fn has_adv(&self) -> bool {
        self.has_adv
    }

    pub fn no_id_usage(&self) -> bool {
        self.no_id_usage
    }

    pub fn id_encoded_alias(&self) -> bool {
        self.id_encoded_alias
    }

    pub fn stat2(&self) -> u8 {
        let mut stat2 = if self.has_adv { 0x01 } else { 0x00 };
        if self.no_id_usage {
            stat2 |= 0x04;
        }
        if self.id_encoded_alias {
            stat2 |= 0x08;
        }
        stat2
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Stat2Arg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "stat2: (has_adv: {}, no_id_usage: {}, id_encoded_alias: {})",
            self.has_adv,
            self.no_id_usage,
            self.id_encoded_alias
        )
    }
}


foreign_class!(
    /// Holds status information for the slot
    class Stat2Arg {
        self_type Stat2Arg;
        /// Creates new status information for the slot
        /// @param hasAdv If this slot has suppressed adv consist
        /// @param noIdUsage If this slots expansion ID 1/2 is not in ID usage
        /// @param idEncodedAlias True = Expansion in ID 1/2. False = This slot is an encoded alias
        constructor Stat2Arg::new(hasAdv: bool, noIdUsage: bool, idEncodedAlias: bool) -> Stat2Arg;
        /// @return If this slot has suppressed adv consist
        fn Stat2Arg::has_adv(&self) -> bool; alias hasAdv;
        /// @return If this slots expansion ID 1/2 is not in ID usage
        fn Stat2Arg::no_id_usage(&self) -> bool; alias noIdUsage;
        /// @return True = Expansion in ID 1/2, False = This slot is an encoded alias
        fn Stat2Arg::id_encoded_alias(&self) -> bool; alias idEncodedAlias;
        /// @return A string in the format "stat2: (has_adv: has_adv, no_id_usage: no_id_usage, id_encoded_alias: id_encoded_alias)"
        fn Stat2Arg::to_string(&self) -> String; alias toString;
        /// Checks whether this stat2 arg is equal to another stat2 arg
        /// @param other The stat2 arg to compare to
        /// @return If this stat2 arg is equal to the other stat2 arg
        fn Stat2Arg::eq(&self, other: &Stat2Arg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this stat2 arg is equal to another object.
     * @param o The object to compare to
     * @return If this stat2 arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Stat2Arg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.hasAdv(), this.noIdUsage(), this.idEncodedAlias());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LopcArg(u8);

impl LopcArg {
    pub fn parse(lopc: u8) -> Self {
        Self(lopc & !0x40)
    }

    pub fn lopc(&self) -> u8 {
        self.0
    }

    pub fn set_lopc(&mut self, lopc: u8) {
        self.0 = lopc & !0x40
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LopcArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "lopc: {}",
            self.0,
        )
    }
}

foreign_class!(
    /// Copy of the opcode with 7th bit set to 0
    class LopcArg {
        self_type LopcArg;
        /// Creates an opcode copy with the given opcode. The seventh bit will be set to zero.
        /// @param lopc The opcode to set
        constructor LopcArg::parse(lopc: u8) -> LopcArg;
        /// @return The opcode with the seventh bit set to zero
        fn LopcArg::lopc(&self) -> u8;
        /// Sets the opcode copy to the given lopc argument.
        /// @param lopc The param to set. The seventh bit will be set to zero
        fn LopcArg::set_lopc(&mut self, lopc: u8); alias setLopc;
        /// @return A string in the format "lopc: lopc"
        fn LopcArg::to_string(&self) -> String; alias toString;
        /// Checks whether this lopc arg is equal to another lopc arg
        /// @param other The lopc arg to compare to
        /// @return If this lopc arg is equal to the other lopc arg
        fn LopcArg::eq(&self, other: &LopcArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this lopc arg is equal to another object.
     * @param o The object to compare to
     * @return If this lopc arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LopcArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.lopc());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Ack1Arg(u8);

impl Ack1Arg {
    pub fn parse(ack1: u8) -> Self {
        Self(ack1)
    }

    pub fn ack1(&self) -> u8 {
        self.0
    }

    pub fn success(&self) -> bool {
        self.0 != 0
    }

    pub fn failed(&self) -> bool {
        self.0 == 0
    }

    pub fn accepted(&self) -> bool {
        self.0 == 1
    }

    pub fn accepted_blind(&self) -> bool {
        self.0 == 0x40
    }

    pub fn set_code(&mut self, code: u8) {
        self.0 = code
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Ack1Arg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if self.failed() {
            write!(
                f,
                "ack1: (failed, ack: {})",
                self.0,
            )
        } else if self.accepted() {
            write!(
                f,
                "ack1: (accepted, ack: {})",
                self.0,
            )
        } else if self.accepted_blind() {
            write!(
                f,
                "ack1: (accepted_blind, ack: {})",
                self.0,
            )
        } else {
            write!(
                f,
                "ack1: (success, ack: {})",
                self.0,
            )
        }
    }
}

foreign_class!(
    /// This is a response message. This message follows immediately the message the response is send for
    class Ack1Arg {
        self_type Ack1Arg;
        /// Creates a new response with the given response value
        /// @param ack1 The response value.
        /// ack1 = 0: failed
        /// ack1 != 0: success
        /// ack1 = 1: accepted
        /// ack1 = 0x40: accepted_blind
        constructor Ack1Arg::parse(ack1: u8) -> Ack1Arg;
        /// @return The response value
        /// ack1 = 0: failed
        /// ack1 != 0: success
        /// ack1 = 1: accepted
        /// ack1 = 0x40: accepted_blind
        fn Ack1Arg::ack1(&self) -> u8;
        /// @return If the leading request was successful
        fn Ack1Arg::success(&self) -> bool;
        /// @return If the leading request has failed
        fn Ack1Arg::failed(&self) -> bool;
        /// @return If the leading request was accepted
        fn Ack1Arg::accepted(&self) -> bool;
        /// @return If the leading request was accepted bling
        fn Ack1Arg::accepted_blind(&self) -> bool; alias acceptedBlind;
        /// Sets the response value to the given code.
        /// @param code The code to set the response value to
        /// ack1 = 0: failed
        /// ack1 != 0: success
        /// ack1 = 1: accepted
        /// ack1 = 0x40: accepted_blind
        fn Ack1Arg::set_code(&mut self, code: u8); alias setCode;
        /// @return A string in the format "ack1: (status, ack: ack)"
        fn Ack1Arg::to_string(&self) -> String; alias toString;
        /// Checks whether this ack1 arg is equal to another ack1 arg
        /// @param other The ack1 arg to compare to
        /// @return If this ack1 arg is equal to the other ack1 arg
        fn Ack1Arg::eq(&self, other: &Ack1Arg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this ack1 arg is equal to another object.
     * @param o The object to compare to
     * @return If this ack1 arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Ack1Arg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.ack1());
    }
"#;
});

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SourceType {
    Ds54Aux,
    Switch,
}

foreign_enum!(
    /// The inputs source type
    enum SourceType {
        /// DS45 for in args and aux for sn args
        DS54_AUX = SourceType::Ds54Aux,
        /// Input from a switch
        SWITCH = SourceType::Switch,
});

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SensorLevel {
    High,
    Low,
}

foreign_enum!(
    /// The sensors level
    enum SensorLevel {
        /// High sensor level
        HIGH = SensorLevel::High,
        /// Low sensor level
        LOW = SensorLevel::Low,
});

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct InArg {
    address: u16,
    input_source: SourceType,
    sensor_level: SensorLevel,
    control_bit: bool,
}

impl InArg {
    pub fn new(address: u16, input_source: SourceType, sensor_level: SensorLevel, control_bit: bool) -> Self {
        InArg { address: address & 0x07FF, input_source, sensor_level, control_bit }
    }

    pub fn parse(in1: u8, in2: u8) -> Self {
        let mut address = in1 as u16;
        address |= (in2 as u16 & 0x0F) << 7;

        let input_source = if in2 & 0x20 == 0 {
            SourceType::Ds54Aux
        } else {
            SourceType::Switch
        };

        let sensor_level = if (in2 & 0x10) != 0 {
            SensorLevel::High
        } else { SensorLevel::Low };
        let control_bit = (in2 & 0x40) != 0;
        Self {
            address,
            input_source,
            sensor_level,
            control_bit,
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn address_ds54(&self) -> u16 {
        (self.address << 1)
            | if self.input_source == SourceType::Switch {
            1
        } else {
            0
        }
    }

    pub fn input_source(&self) -> SourceType {
        self.input_source
    }

    pub fn sensor_level(&self) -> SensorLevel {
        self.sensor_level
    }

    pub fn control_bit(&self) -> bool {
        self.control_bit
    }

    pub fn set_address(&mut self, address: u16) {
        assert_eq!(
            address & 0x07FF,
            0,
            "address must only use the 11 least significant bits"
        );
        self.address = address;
    }

    pub fn set_address_ds54(&mut self, address_ds54: u16) {
        assert_eq!(
            self.address & 0x0FFF,
            0,
            "address must only use the 12 least significant bits"
        );
        self.input_source = if address_ds54 & 1 == 0 {
            SourceType::Ds54Aux
        } else {
            SourceType::Switch
        };
        self.set_address(address_ds54 >> 1);
    }

    pub fn set_input_source(&mut self, input_source: SourceType) {
        self.input_source = input_source;
    }

    pub fn set_sensor_level(&mut self, sensor_level: SensorLevel) {
        self.sensor_level = sensor_level;
    }

    pub fn set_control_bit(&mut self, control_bit: bool) {
        self.control_bit = control_bit;
    }

    pub fn in1(&self) -> u8 {
        self.address as u8 & 0x7F
    }

    pub fn in2(&self) -> u8 {
        let mut in2 = ((self.address >> 7) as u8) & 0x0F;
        in2 |= match self.input_source {
            SourceType::Ds54Aux => 0x00,
            SourceType::Switch => 0x20
        };
        in2 |= match self.sensor_level {
            SensorLevel::High => 0x10,
            SensorLevel::Low => 0x00
        };
        if self.control_bit {
            in2 |= 0x40;
        }
        in2
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for InArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "in: (address: {}, input_source: {:?}, sensor_level: {:?}, control_bit: {})",
            self.address,
            self.input_source,
            self.sensor_level,
            self.control_bit
        )
    }
}

impl Debug for InArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "in_arg: (address: {}, input_source: {:?}, sensor_level: {:?}, control_bit: {})",
            self.address,
            self.input_source,
            self.sensor_level,
            self.control_bit
        )
    }
}

foreign_class!(
    /// This class represents general sensor input
    class InArg {
        self_type InArg;
        /// Creates new sensor input
        /// @param address 11 bit address (least significant bits)
        /// @param inputSource The input source of the sensor
        /// @param sensorLevel The sensors level (Low / High)
        /// @param controlBit Preserved for future use
        constructor InArg::new(address: u16, inputSource: SourceType, sensorLevel: SensorLevel, controlBit: bool) -> InArg;
        /// @return The address of this in arg
        fn InArg::address(&self) -> u16;
        /// @return This sensors input source
        fn InArg::input_source(&self) -> SourceType; alias inputSource;
        /// @return The sensors level
        fn InArg::sensor_level(&self) -> SensorLevel; alias sensorLevel;
        /// @return The sensors message control bit which is reserved for future use
        fn InArg::control_bit(&self) -> bool; alias controlBit;
        /// Sets the address to the given 11 bit address value
        /// @param address 11 bit long address
        fn InArg::set_address(&mut self, address: u16); alias setAddress;
        /// Sets the input source to the given value
        /// @param inputSource The input source of this sensor
        fn InArg::set_input_source(&mut self, inputSource: SourceType); alias setInputSource;
        /// Sets the sensors level to the given value
        /// @param sensorLevel The sensor level of this sensor
        fn InArg::set_sensor_level(&mut self, sensorLevel: SensorLevel); alias setSensorLevel;
        /// Sets the control bit to the given value
        /// @param controlBit The control bit of this sensor, preserved for future use!
        fn InArg::set_control_bit(&mut self, controlBit: bool); alias setControlBit;
        /// @return A string in the format "in: (address: address, input_source: input_source, sensor_level: sensor_level, control_bit: control_bit)"
        fn InArg::to_string(&self) -> String; alias toString;
        /// Checks whether this in arg is equal to another in arg
        /// @param other The in arg to compare to
        /// @return If this in arg is equal to the other in arg
        fn InArg::eq(&self, other: &InArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this in arg is equal to another object.
     * @param o The object to compare to
     * @return If this in arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((InArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.address(), this.inputSource(), this.sensorLevel(), this.controlBit());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq)]
pub struct SnArg {
    address: u16,
    format: bool,
    c: bool,
    t: bool,
    input_source: SourceType,
    sensor_level: SensorLevel,
}

impl SnArg {
    pub fn new_c_t(address: u16, c: bool, t: bool) -> Self {
        SnArg { address: address & 0x07FF, format: false, c, t, input_source: SourceType::Ds54Aux, sensor_level: SensorLevel::Low }
    }

    pub fn new_f(address: u16, input_source: SourceType, sensor_level: SensorLevel) -> Self {
        SnArg { address: address & 0x07FF, format: true, c: false, t: false, input_source, sensor_level }
    }

    pub fn parse(sn1: u8, sn2: u8) -> Self {
        let mut address = sn1 as u16;
        address |= (sn2 as u16 & 0x0F) << 7;

        let format = sn2 & 0x40 == 0x40;

        let c = sn2 & 0x10 == 0x10;
        let t = sn2 & 0x20 == 0x20;

        let input_source = if c {
            SourceType::Switch
        } else { SourceType::Ds54Aux };

        let sensor_level = if t {
            SensorLevel::High
        } else { SensorLevel::Low };

        SnArg {
            address,
            format,
            c,
            t,
            input_source,
            sensor_level
        }
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn format(&self) -> bool {
        self.format
    }

    pub fn c_u8(&self) -> Result<u8, String> {
        if !self.format {
            Ok(self.c as u8)
        } else { Err("Wrong sn format".to_owned()) }
    }

    pub fn t_u8(&self) -> Result<u8, String> {
        if !self.format { Ok(self.t as u8) } else { Err("Wrong sn format".to_owned()) }
    }

    pub fn input_source(&self) -> Result<SourceType, String> {
        if self.format { Ok(self.input_source) } else { Err("Wrong sn format".to_owned()) }
    }

    pub fn sensor_level(&self) -> Result<SensorLevel, String> {
        if self.format { Ok(self.sensor_level) } else { Err("Wrong sn format".to_owned()) }
    }

    pub fn set_address(&mut self, address: u16) {
        self.address = address & 0x07FF;
    }

    pub fn set_format(&mut self, format: bool) {
        self.format = format;
    }

    pub fn set_c(&mut self, c: bool) -> Result<(), String> {
        if self.format { return Err("Wrong sn format".to_owned()); }

        self.c = c;
        Ok(())
    }

    pub fn set_t(&mut self, t: bool) -> Result<(), String> {
        if self.format { return Err("Wrong sn format".to_owned()); }

        self.t = t;
        Ok(())
    }

    pub fn set_input_source(&mut self, input_source: SourceType) -> Result<(), String> {
        if !self.format { return Err("Wrong sn format".to_owned()); }

        self.input_source = input_source;
        Ok(())
    }

    pub fn set_sensor_level(&mut self, sensor_level: SensorLevel) -> Result<(), String> {
        if !self.format { return Err("Wrong sn format".to_owned()); }

        self.sensor_level = sensor_level;
        Ok(())
    }

    pub fn sn1(&self) -> u8 {
        (self.address as u8) & 0x7F
    }

    pub fn sn2(&self) -> u8 {
        let mut sn2 = (self.address >> 7) as u8 & 0x0F;
        if self.format {
            sn2 |= 0x40 |
                match self.input_source { SourceType::Ds54Aux => 0x00, SourceType::Switch => 0x20 } |
                match self.sensor_level { SensorLevel::High => 0x10, SensorLevel::Low => 0x00 }
        } else {
            if self.c {
                sn2 |= 0x20;
            }
            if self.t {
                sn2 |= 0x10;
            }
        }

        sn2
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl PartialEq for SnArg {
    fn eq(&self, other: &Self) -> bool {
        if !(self.format == other.format && self.address == other.address) {
            return false;
        }

        if self.format {
            self.input_source == other.input_source && self.sensor_level == other.sensor_level
        } else {
            self.t == other.t && self.c == other.c
        }
    }
}

impl Display for SnArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if self.format {
            write!(
                f,
                "sn: (address: {}, input_source: {:?}, sensor_level: {:?})",
                self.address,
                self.input_source,
                self.sensor_level,
            )
        } else {
            write!(
                f,
                "sn: (address: {}, c: {:?}, t: {:?})",
                self.address,
                self.c,
                self.t,
            )
        }
    }
}

foreign_class!(
    /// This class represents turnout sensor input
    class SnArg {
        self_type SnArg;
        /// Creates new turnout sensor input with close output and thrown output on off information
        /// @param address 11 bit turnout sensors address
        /// @param c If the output is closed (false = off, true = on)
        /// @param t If the output is thrown (false = off, true = on)
        constructor SnArg::new_c_t(address: u16, c: bool, t: bool) -> SnArg;
        /// Creates new turnout sensor input with input source and sensor level information
        /// @param address 11 bit turnout sensors address
        /// @param inputSource The input source of the sensor
        /// @param sensorLevel The sensors level (Low / High)
        constructor SnArg::new_f(address: u16, inputSource: SourceType, sensorLevel: SensorLevel) -> SnArg;
        /// @return The sensors 11 bit address
        fn SnArg::address(&self) -> u16;
        /// @return The format of this sn message. true = input_source-sensor_level format, false = c-t format
        fn SnArg::format(&self) -> bool;
        /// @return If the output is closed
        /// @throws Exception If the format of this sn arg is true
        private fn SnArg::c_u8(&self) -> Result<u8, String>;
        /// @return If the output is thrown
        /// @throws Exception If the format of this sn arg is true
        private fn SnArg::t_u8(&self) -> Result<u8, String>;
        /// @return This sensors input source
        /// @throws Exception If the format of this sn arg is false
        fn SnArg::input_source(&self) -> Result<SourceType, String>; alias inputSource;
        /// @return This sensors level
        /// @throws Exception If the format of this sn arg is false
        fn SnArg::sensor_level(&self) -> Result<SensorLevel, String>; alias sensorLevel;
        /// Sets the address to the new 11 least significant bits of the given address
        /// @param address The value to set the address to
        fn SnArg::set_address(&mut self, address: u16); alias setAddress;
        /// Sets the format to the given format. Changing this may cause unexpected behaviour
        /// @param format The format to set
        fn SnArg::set_format(&mut self, format: bool); alias setFormat;
        /// Sets if the output of this sensor is closed
        /// @param c If the output of this sensor is closed
        /// @throws Exception If the format of this sn arg is true
        fn SnArg::set_c(&mut self, c: bool) -> Result<(), String>; alias setC;
        /// Sets if the output of this sensor is thrown
        /// @param t If the output of this sensor is thrown
        /// @throws Exception If the format of this sn arg is true
        fn SnArg::set_t(&mut self, t: bool) -> Result<(), String>; alias setT;
        /// Sets the input source to the given value
        /// @param inputSource The input source of this sensor
        /// @throws Exception If the format of this sn arg is false
        fn SnArg::set_input_source(&mut self, inputSource: SourceType) -> Result<(), String>; alias setInputSource;
        /// Sets the sensors level to the given value
        /// @param sensorLevel The sensor level of this sensor
        /// @throws Exception If the format of this sn arg is false
        fn SnArg::set_sensor_level(&mut self, sensorLevel: SensorLevel) -> Result<(), String>; alias setSensorLevel;
        /// @return A string in the format "sn: (address: address, input_source: input_source, sensor_level: sensor_level)" when the format of this sn arg is true else "sn: (address: address, c: c, t: t)"
        fn SnArg::to_string(&self) -> String; alias toString;
        /// Checks whether this sn arg is equal to another sn arg
        /// @param other The sn arg to compare to
        /// @return If this sn arg is equal to the other sn arg
        fn SnArg::eq(&self, other: &SnArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this sn arg is equal to another object.
     * @param o The object to compare to
     * @return If this sn arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SnArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        if(this.format()) {
            try {
                return java.util.Objects.hash(this.address(), this.format(), this.inputSource(), this.sensorLevel());
            } catch (Exception ignored) {
                // Never reached
            }
        } else {
            try {
                return java.util.Objects.hash(this.address(), this.format(), this.c(), this.t());
            } catch (Exception ignored) {
                // Never reached
            }
        }
        return java.util.Objects.hash(this.toString());
    }

    /**
     * @return If closed output is on.
     * @throws Exception If the format is true
     */
    public boolean c() throws Exception {
        return this.c_u8() != 0;
    }

    /**
     * @return If thrown output is on.
     * @throws Exception If the format is true
     */
    public boolean t() throws Exception {
        return this.t_u8() != 0;
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct IdArg(u16);

impl IdArg {
    pub fn new(id: u16) -> Self {
        IdArg(id & 0x3FFF)
    }

    pub fn parse(id1: u8, id2: u8) -> Self {
        IdArg((((id2 & 0x7F) as u16) << 7) | ((id1 & 0x7F) as u16))
    }

    pub fn id(&self) -> u16 {
        self.0
    }

    pub fn id1(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn id2(&self) -> u8 {
        (self.0 >> 7) as u8 & 0x7F
    }

    pub fn set_id(&mut self, id: u16) {
        self.0 = id & 0x3FFF
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for IdArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "id: {}",
            self.0
        )
    }
}

foreign_class!(
    /// Represents an id. This is the PC id if stat2 arg is an encoded alias
    class IdArg {
        self_type IdArg;
        /// Creates a new id with the least significant 14 bits of the given id
        /// @param id The id to set
        constructor IdArg::new(id: u16) -> IdArg;
        /// @return The id hold by this id arg
        fn IdArg::id(&self) -> u16;
        /// Sets the id of this arg to the least significant 14 bits of the given id
        /// @param id The id to set
        fn IdArg::set_id(&mut self, id: u16); alias setId;
        /// @return A string in the format "id: id"
        fn IdArg::to_string(&self) -> String; alias toString;
        /// Checks whether this id arg is equal to another id arg
        /// @param other The id arg to compare to
        /// @return If this id arg is equal to the other id arg
        fn IdArg::eq(&self, other: &IdArg) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this id arg is equal to another object.
     * @param o The object to compare to
     * @return If this id arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((IdArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.id());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct MultiSenseArg{ m_type: u8, present: bool, board_address: u8, zone: u8 }

impl MultiSenseArg {

    pub fn new(m_type: u8, present: bool, board_address: u8, zone: u8) -> Self {
        Self {
            m_type: m_type & 0x07,
            present,
            board_address,
            zone
        }
    }

    pub fn parse(m_high: u8, zas: u8) -> Self {
        let m_type = 0xE0 & m_high >> 5;
        let present = 0x10 & m_high == 0x10;
        let board_address = ((0x0F & m_high) << 4) | ((zas & 0xF0) >> 4);
        let zone = 0x0F & zas;

        MultiSenseArg {
            m_type,
            present,
            board_address,
            zone
        }
    }

    pub fn m_type(&self) -> u8 {
        self.m_type
    }

    pub fn present(&self) -> bool {
        self.present
    }

    pub fn board_address(&self) -> u8 {
        self.board_address
    }

    pub fn zone(&self) -> u8 {
        self.zone
    }

    pub fn zas(&self) -> u8 {
        self.zone | ((self.board_address & 0x0F) << 4)
    }

    pub fn m_high(&self) -> u8 {
        ((self.board_address & 0xF0) >> 4) | ((self.m_type & 0x07) << 5) | if self.present { 0x10 } else { 0x00 }
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for MultiSenseArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "multi_sense_arg: (m_type: {}, present: {}, board_address: {}, zone: {})",
            self.m_type,
            self.present,
            self.board_address,
            self.zone
        )
    }
}

foreign_class!(
    /// The type arg for the multi sense message
    class MultiSenseArg {
        self_type MultiSenseArg;
        /// Creates a new MTypeArg with mType as type
        /// @param mType The multi sense message type (3 bit)
        /// @param present ?If the sending device is present?
        /// @param boardAddress The boards address
        /// @param zone The multi sense zone
        constructor MultiSenseArg::new(mType: u8, present: bool, boardAddress: u8, zone: u8) -> MultiSenseArg;
        /// @return The multi sense message type
        fn MultiSenseArg::m_type(&self) -> u8; alias mType;
        /// @return ?If the sender is present?
        fn MultiSenseArg::present(&self) -> bool;
        /// @return The boards address
        fn MultiSenseArg::board_address(&self) -> u8; alias boardAddress;
        /// @return The zone
        fn MultiSenseArg::zone(&self) -> u8;
        /// @return A string in the format "multi_sense_arg: (m_type: m_type, present: present, board_address: board_address, zone: zone)"
        fn MultiSenseArg::to_string(&self) -> String; alias toString;
        /// Checks whether this multi sense arg is equal to another multi sense arg
        /// @param other The multi sense arg to compare to
        /// @return If this multi sense arg is equal to the other multi sense arg
        fn MultiSenseArg::eq(&self, other: &MultiSenseArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this multi sense arg is equal to another object.
     * @param o The object to compare to
     * @return If this multi sense arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((MultiSenseArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.mType(), this.zone(), this.present(), this.boardAddress());
    }
"#;
});

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct FunctionArg(u8, u8);

impl FunctionArg {
    pub fn new(group: u8) -> Self {
        FunctionArg(group, 0)
    }

    pub fn c_new(group: u16) -> Self {
        FunctionArg(group as u8, 0)
    }

    pub fn c_parse(group: u16, function: u16) -> Self {
        FunctionArg(group as u8, function as u8)
    }

    pub fn parse(group: u8, function: u8) -> Self {
        FunctionArg(group, function)
    }

    pub fn f(&self, f_num: u8) -> bool {
        if f_num > 8 && f_num < 12 && self.0 == 0x07 {
            (self.1 >> (f_num - 5)) & 1 != 0
        } else if (f_num == 12 || f_num == 20 || f_num == 28) && self.0 == 0x05 {
            (self.1
                >> (if f_num == 12 {
                4
            } else if f_num == 20 {
                5
            } else {
                6
            })) & 1
                != 0
        } else if f_num > 12 && f_num < 20 && self.0 == 0x08 {
            (self.1 >> (f_num - 13)) & 1 != 0
        } else if f_num > 20 && f_num < 28 && self.0 == 0x09 {
            (self.1 >> (f_num - 21)) & 1 != 0
        } else {
            false
        }
    }

    pub fn set_f(&mut self, f_num: u8, value: bool) {
        let mask = if f_num > 8 && f_num < 12 && self.0 == 0x07 {
            1 << (f_num - 5)
        } else if (f_num == 12 || f_num == 20 || f_num == 28) && self.0 == 0x05 {
            1 << (if f_num == 12 {
                0
            } else if f_num == 20 {
                1
            } else {
                2
            })
        } else if f_num > 12 && f_num < 20 && self.0 == 0x08 {
            1 << (f_num - 13)
        } else if f_num > 20 && f_num < 28 && self.0 == 0x09 {
            1 << (f_num - 21)
        } else {
            0x00
        };

        if value {
            self.1 |= mask;
        } else {
            self.1 &= !mask;
        }
    }

    pub fn group(&self) -> u8 {
        self.0
    }

    pub fn function(&self) -> u8 {
        self.1
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for FunctionArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "function_arg: (f9: {}, f10: {}, f11: {}, f12: {}, f13: {}, f14: {}, f15: {}, f16: {}, f17: {}, f18: {}, f19: {}, f20: {}, f21: {}, f22: {}, f23: {}, f24: {}, f25: {}, f26: {}, f27: {}, f28: {})",
            self.f(9),
            self.f(10),
            self.f(11),
            self.f(12),
            self.f(13),
            self.f(14),
            self.f(15),
            self.f(16),
            self.f(17),
            self.f(18),
            self.f(19),
            self.f(20),
            self.f(21),
            self.f(22),
            self.f(23),
            self.f(24),
            self.f(25),
            self.f(26),
            self.f(27),
            self.f(28),
        )
    }
}

impl Debug for FunctionArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "function_arg: (f9: {}, f10: {}, f11: {}, f12: {}, f13: {}, f14: {}, f15: {}, f16: {}, f17: {}, f18: {}, f19: {}, f20: {}, f21: {}, f22: {}, f23: {}, f24: {}, f25: {}, f26: {}, f27: {}, f28: {})",
            self.f(9),
            self.f(10),
            self.f(11),
            self.f(12),
            self.f(13),
            self.f(14),
            self.f(15),
            self.f(16),
            self.f(17),
            self.f(18),
            self.f(19),
            self.f(20),
            self.f(21),
            self.f(22),
            self.f(23),
            self.f(24),
            self.f(25),
            self.f(26),
            self.f(27),
            self.f(28),
        )
    }
}

foreign_class!(
    /// This arg can hold function values from 9 to 28, but as they where grouped only a few a time.
    /// If the group is 0x07: f9 - f11 are available
    /// If the group is 0x05: f12 + f20 + f28 are available
    /// If the group is 0x08: f13 - f19 are available
    /// If the group is 0x09: f21 - f27 are available
    class FunctionArg {
        self_type FunctionArg;
        /// Creates a new function arg
        /// @param group The group to decide availability of the specific function args (see class description)
        constructor FunctionArg::c_new(group: u16) -> FunctionArg;
        /// Creates a new function arg
        /// @param group The group to decide availability of the specific function args (see class description)
        /// @param f The function value to set (8 bit)
        constructor FunctionArg::c_parse(group: u16, f: u16) -> FunctionArg;
        /// @return The function group
        fn FunctionArg::group(&self) -> u8;
        /// @return Available function values for set group (see class description) or standard false if no value is available
        fn FunctionArg::f(&self, fNum: u8) -> bool;
        /// Sets the specific function value to the given value. If the function value is not within the group bounds nothing will change
        /// @param fNum The function number to set the value to
        /// @param f The functions value
        fn FunctionArg::set_f(&mut self, fNum: u8, f: bool); alias setF;
        /// @return A string in the format "function_arg: (f9 - f28)"
        fn FunctionArg::to_string(&self) -> String; alias toString;
        /// Checks whether this function arg is equal to another function arg
        /// @param other The function arg to compare to
        /// @return If this function arg is equal to the other function arg
        fn FunctionArg::eq(&self, other: &FunctionArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this function arg is equal to another object.
     * @param o The object to compare to
     * @return If this function arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((FunctionArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Pcmd {
    write: bool,
    byte_mode: bool,
    ops_mode: bool,
    ty0: bool, // Programing type select bit
    ty1: bool, // prog type select bit
}

impl Pcmd {
    pub fn new(write: bool, byte_mode: bool, ops_mode: bool, ty0: bool, ty1: bool) -> Self {
        Pcmd{ write, byte_mode, ops_mode, ty0, ty1 }
    }

    pub fn parse(pcmd: u8) -> Self {
        let write = pcmd & 0x20 == 0x20;
        let byte_mode = pcmd & 0x40 == 0x40;
        let ops_mode = pcmd & 0x02 == 0x02;
        let ty0 = pcmd & 0x80 == 0x80;
        let ty1 = pcmd & 0x01 == 0x01;

        Pcmd {
            write,
            byte_mode,
            ops_mode,
            ty0,
            ty1,
        }
    }

    pub fn write(&self) -> bool {
        self.write
    }

    pub fn byte_mode(&self) -> bool {
        self.byte_mode
    }

    pub fn ops_mode(&self) -> bool {
        self.ops_mode
    }

    pub fn ty0(&self) -> bool {
        self.ty0
    }

    pub fn ty1(&self) -> bool {
        self.ty1
    }

    pub fn set_write(&mut self, write: bool) {
        self.write = write
    }

    pub fn set_byte_mode(&mut self, byte_mode: bool) {
        self.byte_mode = byte_mode
    }

    pub fn set_ops_mode(&mut self, ops_mode: bool) {
        self.ops_mode = ops_mode
    }

    pub fn set_ty0(&mut self, ty0: bool) {
        self.ty0 = ty0
    }

    pub fn set_ty1(&mut self, ty1: bool) {
        self.ty1 = ty1
    }

    pub fn pcmd(&self) -> u8 {
        let mut pcmd = if self.write { 0x20 } else { 0x00 };
        if self.byte_mode {
            pcmd |= 0x40;
        }
        if self.ops_mode {
            pcmd |= 0x02;
        }
        if self.ty0 {
            pcmd |= 0x80;
        }
        if self.ty1 {
            pcmd |= 0x01;
        }
        pcmd
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Pcmd {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "pcmd: (write: {}, byte_mode: {}, ops_mode: {}, ty0: {}, ty1: {})",
            self.write,
            self.byte_mode,
            self.ops_mode,
            self.ty0,
            self.ty1
        )
    }
}

foreign_class!(
    /// This args hold programmer command data.
    class Pcmd {
        self_type Pcmd;
        /// Creates new programmer command data. Every data set to false means current operation will be aborted.
        /// @param write If this operation is for writing or else reading
        /// @param byteMode If it is a byte or else bit operation
        /// @param opsMode If this operation is on main line or programmer track
        /// @param ty0 Programming type select bit 0
        /// @param ty1 Programming type select bit 1
        constructor Pcmd::new(write: bool, byteMode: bool, opsMode: bool, ty0: bool, ty1: bool) -> Pcmd;
        /// @return If this operation is for writing or else reading
        fn Pcmd::write(&self) -> bool;
        /// @return If this operation is a byte or else bit operation
        fn Pcmd::byte_mode(&self) -> bool; alias byteMode;
        /// @return If this operation is on main line or programming track
        fn Pcmd::ops_mode(&self) -> bool; alias opsMode;
        /// @return Programming type select bit 0
        fn Pcmd::ty0(&self) -> bool;
        /// @return Programming type select bit 1
        fn Pcmd::ty1(&self) -> bool;
        /// Sets the write or read mode
        /// @param write If this operation is for writing or else reading
        fn Pcmd::set_write(&mut self, write: bool); alias setWrite;
        /// Sets to byte or bit mode
        /// @param byteMode If it is a byte or else bit operation
        fn Pcmd::set_byte_mode(&mut self, byteMode: bool); alias setByteMode;
        /// Sets the ops mode
        /// @param opsMode If this operation is on main line or programmer track
        fn Pcmd::set_ops_mode(&mut self, opsMode: bool); alias setOpsMode;
        /// Sets the programming type select bit 0
        /// @param ty0 Programming type select bit 0
        fn Pcmd::set_ty0(&mut self, ty0: bool); alias setTy0;
        /// Sets the programming type select bit 1
        /// @param ty1 Programming type select bit 1
        fn Pcmd::set_ty1(&mut self, ty1: bool); alias setTy1;
        /// @return A string in the format "pcmd: (write: write, byte_mode: byte_mode, ops_mode: ops_mode, ty0: ty0, ty1: ty1)"
        fn Pcmd::to_string(&self) -> String; alias toString;
        /// Checks whether this pcmd arg is equal to another pcmd arg
        /// @param other The pcmd arg to compare to
        /// @return If this pcmd arg is equal to the other pcmd arg
        fn Pcmd::eq(&self, other: &Pcmd) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this pcmd arg is equal to another object.
     * @param o The object to compare to
     * @return If this pcmd arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Pcmd) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.write(), this.byteMode(), this.opsMode(), this.ty0(), this.ty1());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct PStat {
    user_aborted: bool,
    no_read_ack: bool,
    no_write_ack: bool,
    programming_track_empty: bool,
}

impl PStat {
    pub fn new(user_aborted: bool, no_read_ack: bool, no_write_ack: bool, programming_track_empty: bool) -> Self {
        PStat { user_aborted, no_read_ack, no_write_ack, programming_track_empty }
    }

    pub fn parse(stat: u8) -> Self {
        let user_aborted = stat & 0x01 == 0x01;
        let no_read_ack = stat & 0x02 == 0x02;
        let no_write_ack = stat & 0x04 == 0x04;
        let programming_track_empty = stat & 0x08 == 0x08;

        PStat {
            user_aborted,
            no_read_ack,
            no_write_ack,
            programming_track_empty,
        }
    }

    pub fn user_aborted(&self) -> bool {
        self.user_aborted
    }

    pub fn no_read_ack(&self) -> bool {
        self.no_read_ack
    }

    pub fn no_write_ack(&self) -> bool {
        self.no_write_ack
    }

    pub fn programming_track_empty(&self) -> bool {
        self.programming_track_empty
    }

    pub fn stat(&self) -> u8 {
        let mut stat = if self.user_aborted { 0x01 } else { 0x00 };
        if self.no_read_ack {
            stat |= 0x02;
        }
        if self.no_write_ack {
            stat |= 0x04;
        }
        if self.programming_track_empty {
            stat |= 0x08;
        }
        stat
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for PStat {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "p_stat: (user_aborted: {}, no_read_ack: {}, no_write_ack: {}, programming_track_empty: {})",
            self.user_aborted,
            self.no_read_ack,
            self.no_write_ack,
            self.programming_track_empty
        )
    }
}

foreign_class!(
    /// Programmer error flags data
    class PStat {
        self_type PStat;
        /// Creates a new programming error data flag
        /// @param userAborted Received a abort message for operation and end the command
        /// @param noReadAck Did not received a valid read acknowledgement from the receiver
        /// @param noWriteAck Did not received a valid write acknowledgement from the receiver
        /// @param programmingTrackEmpty Programming track is empty
        constructor PStat::new(userAborted: bool, noReadAck: bool, noWriteAck: bool, programmingTrackEmpty: bool) -> PStat;
        /// @return If the command was aborted from the user.
        fn PStat::user_aborted(&self) -> bool; alias userAborted;
        /// @return If no read acknowledgment was received.
        fn PStat::no_read_ack(&self) -> bool; alias noReadAck;
        /// @return If no write acknowledgment was received.
        fn PStat::no_write_ack(&self) -> bool; alias noWriteAck;
        /// @return If the programming track was empty and therefore the operation failed
        fn PStat::programming_track_empty(&self) -> bool; alias programmingTrackEmpty;
        /// @return A string in the format "p_stat: (user_aborted: user_aborted, no_read_ack: no_read_ack, no_write_ack: no_write_ack, programming_track_empty: programming_track_empty)"
        fn PStat::to_string(&self) -> String; alias toString;
        /// Checks whether this pstat arg is equal to another pstat arg
        /// @param other The pstat arg to compare to
        /// @return If this pstat arg is equal to the other pstat arg
        fn PStat::eq(&self, other: &PStat) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this pstat arg is equal to another object.
     * @param o The object to compare to
     * @return If this pstat arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((PStat) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.userAborted(), this.noReadAck(), this.noWriteAck(), this.programmingTrackEmpty());
    }
"#;
});

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CvDataArg(u16, u8);

impl CvDataArg {
    pub fn new() -> Self {
        CvDataArg(0, 0)
    }

    pub fn parse(cvh: u8, cvl: u8, data7: u8) -> Self {
        let mut cv_arg = cvl as u16;
        let data = ((cvh & 0x02) << 6) | data7;

        let mut high_cv_arg = cvh & 0x01;
        high_cv_arg |= (cvh & 0x30) >> 3;

        cv_arg |= (high_cv_arg as u16) << 7;

        CvDataArg(cv_arg, data)
    }

    pub fn data(&self, d_num: u8) -> bool {
        (self.1 >> d_num) & 0x01 != 0
    }

    pub fn cv(&self, cv_num: u8) -> bool {
        self.0 >> cv_num & 1 != 0
    }

    pub fn set_data(&mut self, d_num: u8, value: bool) {
        let mask = 1 << d_num;

        if value {
            self.1 |= mask;
        } else {
            self.1 &= !mask;
        }
    }

    pub fn set_cv(&mut self, cv_num: u8, value: bool) {
        let mask = (1 << cv_num) & 0x03FF;
        if value {
            self.0 |= mask;
        } else {
            self.0 &= !mask;
        }
    }

    pub fn cvh(&self) -> u8 {
        let mut cvh = (self.0 >> 7) as u8;
        let high_cv = cvh & 0x06 << 3;
        cvh &= 0x01;
        cvh |= high_cv;
        if self.data(7) {
            cvh |= 0x02;
        }
        cvh
    }

    pub fn cvl(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn data7(&self) -> u8 {
        self.1 & 0x7F
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for CvDataArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "cv_data_arg: (data: (d0: {}, d1: {}, d2: {}, d3: {}, d4: {}, d5: {}, d6: {}, d7: {}), cv:(cv0: {}, cv1: {}, cv2: {}, cv3: {}, cv4: {}, cv5: {}, cv6: {}, cv7: {}, cv8: {}, cv9: {}))",
            self.data(0),
            self.data(1),
            self.data(2),
            self.data(3),
            self.data(4),
            self.data(5),
            self.data(6),
            self.data(7),
            self.cv(0),
            self.cv(1),
            self.cv(2),
            self.cv(3),
            self.cv(4),
            self.cv(5),
            self.cv(6),
            self.cv(7),
            self.cv(8),
            self.cv(9)
        )
    }
}

impl Debug for CvDataArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "cv_data_arg: (data: (d0: {}, d1: {}, d2: {}, d3: {}, d4: {}, d5: {}, d6: {}, d7: {}), cv:(cv0: {}, cv1: {}, cv2: {}, cv3: {}, cv4: {}, cv5: {}, cv6: {}, cv7: {}, cv8: {}, cv9: {}))",
            self.data(0),
            self.data(1),
            self.data(2),
            self.data(3),
            self.data(4),
            self.data(5),
            self.data(6),
            self.data(7),
            self.cv(0),
            self.cv(1),
            self.cv(2),
            self.cv(3),
            self.cv(4),
            self.cv(5),
            self.cv(6),
            self.cv(7),
            self.cv(8),
            self.cv(9)
        )
    }
}

foreign_class!(
    /// Holds the programming cv values and the data return values
    class CvDataArg {
        self_type CvDataArg;
        /// Constructs an empty cv data arg. To set the values use the setter methods for cv and data
        constructor CvDataArg::new() -> CvDataArg;
        /// @param dNum The data value index to check
        /// @return The data value with the given index or false. Allowed values are 0 - 7
        fn CvDataArg::data(&self, dNum: u8) -> bool;
        /// @param cvNum The cv value index to check
        /// @return The cv value at the cvNum position. Allowed values are 0 - 9
        fn CvDataArg::cv(&self, cvNum: u8) -> bool;
        /// Sets the data value at the position to the given data value
        /// @param dNum The data values index position (0 - 7)
        /// @param d The value to set
        fn CvDataArg::set_data(&mut self, dNum: u8, d: bool); alias setData;
        /// Sets the cv value at the position to the given cv value
        /// @param cvNum The cv values index position (0 - 7)
        /// @param cv The value to set
        fn CvDataArg::set_cv(&mut self, cvNum: u8, cv: bool); alias setCv;
        /// @return A string in the format "cv_data_arg: (data: (d0-d7), cv: (cv0-cv9))"
        fn CvDataArg::to_string(&self) -> String; alias toString;
        /// Checks whether this cv data arg is equal to another cv data arg
        /// @param other The cv data arg to compare to
        /// @return If this cv data arg is equal to the other cv data arg
        fn CvDataArg::eq(&self, other: &CvDataArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this cv data arg is equal to another object.
     * @param o The object to compare to
     * @return If this cv data arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((CvDataArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct FastClock {
    clk_rate: u8,
    frac_minsl: u8,
    frac_minsh: u8,
    duration: Duration,
    clk_cntrl: u8,
}

impl FastClock {
    pub fn parse(clk_rate: u8, frac_minsl: u8, frac_minsh: u8, mins: u8, hours: u8, days: u8, clk_cntrl: u8) -> Self {
        let min = mins % 60 - 0xFF;
        let hour = hours % 60 - 0xFF;

        let secs: u64 = min as u64 * 60 + hour as u64 * 60 * 60 + days as u64 * 24 * 60 * 60;

        let duration = Duration::new(secs, 0);

        FastClock {
            clk_rate: clk_rate & 0x7F,
            frac_minsl,
            frac_minsh,
            duration,
            clk_cntrl,
        }
    }

    pub fn clk_rate(&self) -> u8 {
        self.clk_rate
    }

    pub fn frac_minsl(&self) -> u8 {
        self.frac_minsl
    }

    pub fn frac_minsh(&self) -> u8 {
        self.frac_minsh
    }

    pub fn mins(&self) -> u8 {
        0xFF - (self.duration.as_secs() % 60) as u8
    }

    pub fn hours(&self) -> u8 {
        0xFF - (self.duration.as_secs() / 60 % 60) as u8
    }

    pub fn days(&self) -> u8 {
        0xFF - (self.duration.as_secs() / 60 / 60 % 24) as u8
    }

    pub fn clk_cntrl(&self) -> u8 {
        self.clk_cntrl
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for FastClock {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "fast_clock: (clk_rate: {}, clk_minsl: {}, clk_minsh: {}, duration_secs: {}, clk_cntrl: {})",
            self.clk_rate,
            self.frac_minsl,
            self.frac_minsh,
            self.duration.as_secs(),
            self.clk_cntrl,
        )
    }
}

foreign_class!(
    /// The loco net system clock information
    class FastClock {
        self_type FastClock;
        /// Creates new system clock information
        /// @param clkRate The system clocks rate. 0 = Freeze clock, 1 = normal (1:1 rate), x = x:1 rate (x = 0 - 128)
        /// @param fracMinsl sub minute counter depending on the clock generator (reset on valid clk sync request, internal use only)
        /// @param fracMinsh sub minute counter depending on the clock generator (reset on valid clk sync request, internal use only)
        /// @param mins The minutes of the clock
        /// @param hours The hours of the clock
        /// @param days The days of the clock
        /// @param clkCntrl (0x10 | x) for valid clk information (x and 0xEF) for invalid clk information.
        constructor FastClock::parse(clkRate: u8, fracMinsl: u8, fracMinsh: u8, mins: u8, hours: u8, days: u8, clkCntrl: u8) -> FastClock;
        /// @return The system clocks rate. 0 = Freeze clock, 1 = normal (1:1 rate), x = x:1 rate (x = 0 - 128)
        fn FastClock::clk_rate(&self) -> u8; alias clkRate;
        /// @return sub minute counter depending on the clock generator (reset on valid clk sync request, internal use only)
        fn FastClock::frac_minsl(&self) -> u8; alias fracMinsl;
        /// @return sub minute counter depending on the clock generator (reset on valid clk sync request, internal use only)
        fn FastClock::frac_minsh(&self) -> u8; alias fracMinsh;
        /// @return The minutes of the clock
        fn FastClock::mins(&self) -> u8;
        /// @return The hours of the clock
        fn FastClock::hours(&self) -> u8;
        /// @return The days of the clock
        fn FastClock::days(&self) -> u8;
        /// @return The clocks cntrol byte. Valid clock information if x and 0x10 = 0x10
        fn FastClock::clk_cntrl(&self) -> u8; alias clkCntrl;
        /// @return A string in the format "fast_clock_arg: (clk_rate: clk_rate, clk_minsl: clk_minsl, clk_minsh: clk_minsh, duration_secs: duration.as_secs(), clk_cntrl: clk_cntrl)"
        fn FastClock::to_string(&self) -> String; alias toString;
        /// Checks whether this fast clock arg is equal to another fast clock arg
        /// @param other The fast clock arg to compare to
        /// @return If this fast clock arg is equal to the other fast clock arg
        fn FastClock::eq(&self, other: &FastClock) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this fast clock arg is equal to another object.
     * @param o The object to compare to
     * @return If this fast clock arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((FastClock) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct ImArg {
    reps: u8,
    dhi: u8,
    address: u16,
    function_type: u8,
    function_bits: u8,
    im5: u8
}

impl ImArg {
    pub fn new(reps: u8, dhi: u8, address: u16, function_type: u8, function_bits: u8, im5: u8) -> Self {
        ImArg { reps, dhi, address, function_type, function_bits, im5 }
    }

    pub fn parse(check_byte: u8, reps: u8, dhi: u8, im1: u8, im2 : u8, im3: u8, im4: u8, im5: u8) -> ImArg {
        assert_eq!(check_byte, 0x7F, "Check byte of ImmPacket is not 0x7F");

        if reps == 0x44 || (reps == 0x34 && im4 == 0x00) {
            let address = ((im2 as u16) << 8) | im1 as u16;

            let function_type = if im3 == 0x5E { 0x5E } else if im3 == 0x5F { 0x5F } else { 0x20 };
            let mut function_bits = if function_type == 0x5E || function_type == 0x5F { im4 } else { im3 };

            function_bits = function_bits & 0x7F;

            Self {reps, dhi, address, function_type, function_bits, im5}
        } else {
            let address = im1 as u16;

            let function_type = if im3 == 0x5E { 0x5E } else if im3 == 0x5F { 0x5F } else { 0x20 };
            let mut function_bits = if function_type == 0x5E || function_type == 0x5F { im3 } else { im2 & 0xDF };

            function_bits = function_bits & 0x7F;

            Self {reps, dhi, address, function_type, function_bits, im5}
        }
    }

    pub fn check_byte(&self) -> u8 {
        0x7F
    }

    pub fn reps(&self) -> u8 {
        self.reps
    }

    pub fn dhi(&self) -> u8 {
        self.dhi
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn function_type(&self) -> u8 {
        self.function_type
    }

    pub fn function_bits(&self) -> u8 {
        self.function_bits
    }

    pub fn f(&self, f_num: u8) -> bool {
        let dist = if self.function_type == 0x5E { 21 } else if self.function_type == 0x5F { 13 } else { 9 } as u8;

        (self.function_bits >> (f_num - dist)) & 0x01 == 0x01
    }

    pub fn set_f(&mut self, f_num: u8, f: bool) {
        let dist = if self.function_type == 0x5E { 21 } else if self.function_type == 0x5F { 13 } else { 9 } as u8;

        let mask = 0x01 << (f_num - dist);

        if f {
            self.function_bits |= mask;
        } else {
            self.function_bits &= !mask;
        }
    }

    pub fn im1(&self) -> u8 {
        self.address as u8
    }

    pub fn im2(&self) -> u8 {
        return if self.reps == 0x34 {
            (self.address >> 8) as u8
        } else {
            if self.function_type == 0x20 {
                self.function_bits | 0x20
            } else {
                self.function_type
            }
        }
    }

    pub fn im3(&self) -> u8 {
        return if self.reps() == 0x34 {
            if self.function_type == 0x20 {
                self.function_bits | 0x20
            } else {
                self.function_type
            }
        } else {
            if self.function_type == 0x20 {
                0x00
            } else {
                self.function_bits
            }
        }
    }

    pub fn im4(&self) -> u8 {
        if self.reps() == 0x34 {
            if self.function_type != 0x20 {
                return self.function_bits;
            }
        }
        0x00
    }

    pub fn im5(&self) -> u8 {
        self.im5
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for ImArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "im_arg: (reps: {}, dhi: {}, address: {}, function_type: {}, function_bits: {})",
            self.reps,
            self.dhi,
            self.address,
            self.function_type,
            self.function_bits
        )
    }
}

foreign_class!(
    /// Digitrax high function sending argument
    class ImArg {
        self_type ImArg;
        /// Creates a new im arg
        /// @param reps The representation of the address. (function 9 - 12: 0x24 for short, 0x34 for long; else: 0x34 for short, 0x44 for long)
        /// @param dhi high bits and control bits
        /// @param address The function holders address
        /// @param functionType The functions type (9-12:0x20, 13-20:0x5E, 21-28:0x5F)
        /// @param functionBits The function bits
        /// @param im5 For future use, set to 0
        constructor ImArg::new(reps: u8, dhi: u8, address: u16, functionType: u8, functionBits: u8, im5: u8) -> ImArg;
        /// @return The representation of the address. (function 9 - 12: 0x24 for short, 0x34 for long; else: 0x34 for short, 0x44 for long)
        fn ImArg::reps(&self) -> u8;
        /// @return high bits and control bits
        fn ImArg::dhi(&self) -> u8;
        /// @return The function holders address
        fn ImArg::address(&self) -> u16;
        /// @return The functions type (9-12:0x20, 13-20:0x5E, 21-28:0x5F)
        fn ImArg::function_type(&self) -> u8; alias functionType;
        /// @return The function bits
        fn ImArg::function_bits(&self) -> u8; alias functionBits;
        /// @return For future use, now 0x00
        fn ImArg::im5(&self) -> u8;
        /// @param fNum Index to get the value for
        /// @return The functions value at the given index
        fn ImArg::f(&self, fNum: u8) -> bool;
        /// Sets the functions value at the given index to the given value
        /// @param fNum The index to set the value at
        /// @param f The given value
        fn ImArg::set_f(&mut self, fNum: u8, f: bool); alias setF;
        /// @return A string in the format "im_arg: (reps: reps, dhi: dhi, address: address, function_type: function_type, function_bits: function_bits)"
        fn ImArg::to_string(&self) -> String; alias toString;
        /// Checks whether this im arg is equal to another im arg
        /// @param other The im arg to compare to
        /// @return If this im arg is equal to the other im arg
        fn ImArg::eq(&self, other: &ImArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this im arg is equal to another object.
     * @param o The object to compare to
     * @return If this im arg is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((ImArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString(), this.im5());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct WrSlDataTime(FastClock, TrkArg, IdArg);

impl WrSlDataTime {
    pub fn new(fast_clock: &FastClock, trk_arg: &TrkArg, id_arg: &IdArg) -> Self {
        WrSlDataTime(*fast_clock, *trk_arg, *id_arg)
    }

    pub fn parse(clk_rate: u8, frac_minsh: u8, frac_minsl: u8, mins: u8, trk: u8, hours: u8, days: u8, clk_cntr: u8, id1: u8, id2: u8) -> Self {
        WrSlDataTime(FastClock::parse(clk_rate, frac_minsl, frac_minsh, mins, hours, days, clk_cntr),
                     TrkArg::parse(trk),
                     IdArg::parse(id1, id2))
    }

    pub fn fast_clock(&self) -> FastClock {
        self.0
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.1
    }

    pub fn id_arg(&self) -> IdArg {
        self.2
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for WrSlDataTime {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "wr_sl_data_time: ({}, {}, {})",
            self.0,
            self.1,
            self.2
        )
    }
}

foreign_class!(
    /// Represents a Write slot data message for time synchronisation
    class WrSlDataTime {
        self_type WrSlDataTime;
        /// Creates a time synchronisation write slot data method
        /// @param fastClock The fast clock to use
        /// @param trkArg The trk params to use
        /// @param idArg The id of the device last setting the clock. id = 0: no set happens. id: 7F 7x are reserved for PC access
        constructor WrSlDataTime::new(fastClock: &FastClock, trkArg: &TrkArg, idArg: &IdArg) -> WrSlDataTime;
        /// @return The fast clock in use
        fn WrSlDataTime::fast_clock(&self) -> FastClock; alias fastClock;
        /// @return The track params
        fn WrSlDataTime::trk_arg(&self) -> TrkArg; alias trkArg;
        /// @return The device id last setting the clock or 0. For PC access 7F 7x is reserved
        fn WrSlDataTime::id_arg(&self) -> IdArg; alias idArg;
        /// @return A string in the format "wr_sl_data_time: (fast_clock: {}, track: {}, id: {})"
        fn WrSlDataTime::to_string(&self) -> String; alias toString;
        /// Checks whether this WrSlDataTime is equal to another WrSlDataTime
        /// @param other The WrSlDataTime to compare to
        /// @return If this WrSlDataTime is equal to the other WrSlDataTime
        fn WrSlDataTime::eq(&self, other: &WrSlDataTime) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((WrSlDataTime) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.fastClock(), this.idArg(), this.trkArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct WrSlDataPt(Pcmd, AddressArg, TrkArg, CvDataArg);

impl WrSlDataPt {
    pub fn new(pcmd: &Pcmd, opsa: &AddressArg, trk_arg: &TrkArg, cv_data_arg: &CvDataArg) -> Self {
        WrSlDataPt(*pcmd, *opsa, *trk_arg, *cv_data_arg)
    }

    pub fn parse(pcmd: u8, _arg3: u8, hopsa: u8, lopsa: u8, trk: u8, cvh: u8, cvl: u8, data7: u8, _arg10: u8, _arg11: u8) -> Self {
        WrSlDataPt(Pcmd::parse(pcmd), AddressArg::parse(hopsa, lopsa), TrkArg::parse(trk), CvDataArg::parse(cvh, cvl, data7))
    }

    pub fn pcmd(&self) -> Pcmd {
        self.0
    }

    pub fn opsa(&self) -> AddressArg {
        self.1
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.2
    }

    pub fn cv_data_arg(&self) -> CvDataArg {
        self.3
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for WrSlDataPt {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "wr_sl_data_pt: ({}, {}, {}, {})",
            self.0,
            self.1,
            self.2,
            self.3
        )
    }
}

foreign_class!(
    /// Write slot data to programm on programming track
    class WrSlDataPt {
        self_type WrSlDataPt;
        /// Creates a new write slot data programming track object
        /// @param pcmd The programmer command or 0 to abort current operation
        /// @param opsa The operation mode programming
        /// @param trkArg The track arg
        /// @param cvDataArg The data and cv args for this programming command
        constructor WrSlDataPt::new(pcmd: &Pcmd, opsa: &AddressArg, trkArg: &TrkArg, cvDataArg: &CvDataArg) -> WrSlDataPt;
        /// @return The programmer command or 0 to abort current operation
        fn WrSlDataPt::pcmd(&self) -> Pcmd;
        /// @return The operation mode programming
        fn WrSlDataPt::opsa(&self) -> AddressArg;
        /// @return The track arg
        fn WrSlDataPt::trk_arg(&self) -> TrkArg; alias trkArg;
        /// @return The data and cv args for this programming command
        fn WrSlDataPt::cv_data_arg(&self) -> CvDataArg; alias cvDataArg;
        /// @return A string in the format "wr_sl_data_pt: (pcmd, opsa, trk_arg, cv_data_arg)"
        fn WrSlDataPt::to_string(&self) -> String; alias toString;
        /// Checks whether this WrSlDataPt is equal to another WrSlDataPt
        /// @param other The WrSlDataPt to compare to
        /// @return If this WrSlDataPt is equal to the other WrSlDataPt
        fn WrSlDataPt::eq(&self, other: &WrSlDataPt) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((WrSlDataPt) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.pcmd(), this.opsa(), this.trkArg(), this.cvDataArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct WrSlDataGeneral(SlotArg, Stat1Arg, Stat2Arg, AddressArg, SpeedArg, DirfArg, TrkArg, SndArg, IdArg);

impl WrSlDataGeneral {
    pub fn new(slot_arg: &SlotArg, stat1_arg: &Stat1Arg, stat2_arg: &Stat2Arg, address_arg: &AddressArg, speed_arg: &SpeedArg, dirf_arg: &DirfArg, trk_arg: &TrkArg, id_arg: &IdArg) -> Self {
        WrSlDataGeneral(*slot_arg, *stat1_arg, *stat2_arg, *address_arg, *speed_arg, *dirf_arg, *trk_arg, SndArg(0), *id_arg)
    }

    pub fn parse(slot: u8, stat1: u8, adr: u8, spd: u8, dirf: u8, trk: u8, stat2: u8, adr2: u8, snd: u8, id1: u8, id2: u8) -> Self {
        WrSlDataGeneral(SlotArg::parse(slot),
                        Stat1Arg::parse(stat1),
                        Stat2Arg::parse(stat2),
                        AddressArg::parse(adr2, adr),
                        SpeedArg::parse(spd),
                        DirfArg::parse(dirf),
                        TrkArg::parse(trk),
                        SndArg::parse(snd),
                        IdArg::parse(id1, id2))
    }

    pub fn slot_arg(&self) -> SlotArg {
        self.0
    }

    pub fn stat1_arg(&self) -> Stat1Arg {
        self.1
    }

    pub fn stat2_arg(&self) -> Stat2Arg {
        self.2
    }

    pub fn address_arg(&self) -> AddressArg {
        self.3
    }

    pub fn speed_arg(&self) -> SpeedArg {
        self.4
    }

    pub fn dirf_arg(&self) -> DirfArg {
        self.5
    }

    pub fn trk_arg(&self) -> TrkArg {
        self.6
    }

    pub fn snd_arg(&self) -> SndArg {
        self.7
    }

    pub fn id_arg(&self) -> IdArg {
        self.8
    }

    pub fn set_snd_arg(&mut self, snd_arg: SndArg) {
        self.7 = snd_arg;
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for WrSlDataGeneral {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "wr_sl_data_general: ({}, {}, {}, {}, {}, {}, {}, {}, {})",
            self.0,
            self.1,
            self.2,
            self.3,
            self.4,
            self.5,
            self.6,
            self.7,
            self.8
        )
    }
}

foreign_class!(
    /// Write slot data
    class WrSlDataGeneral {
        self_type WrSlDataGeneral;
        /// Creates a new write slot data arg
        /// @param slot The slot to write to
        /// @param stat1 The status for speed steps
        /// @param stat2 Slot information
        /// @param address The locomotive address
        /// @param speed The locomotives speed
        /// @param dirf The locomotives direction and functions
        /// @param trk The track
        /// @param id The id of the last setting device
        constructor WrSlDataGeneral::new(slot: &SlotArg, stat1: &Stat1Arg, stat2: &Stat2Arg, address: &AddressArg, speed: &SpeedArg, dirf: &DirfArg, trk: &TrkArg, id: &IdArg) -> WrSlDataGeneral;
        /// @return The slot to write to
        fn WrSlDataGeneral::slot_arg(&self) -> SlotArg; alias slotArg;
        /// @return The status for speed steps
        fn WrSlDataGeneral::stat1_arg(&self) -> Stat1Arg; alias stat1Arg;
        /// @return Slot information
        fn WrSlDataGeneral::stat2_arg(&self) -> Stat2Arg; alias stat2Arg;
        /// @return The locomotive address
        fn WrSlDataGeneral::address_arg(&self) -> AddressArg; alias addressArg;
        /// @return The locomotives speed
        fn WrSlDataGeneral::speed_arg(&self) -> SpeedArg; alias speedArg;
        /// @return The locomotives direction and functions
        fn WrSlDataGeneral::dirf_arg(&self) -> DirfArg; alias dirfArg;
        /// @return The track
        fn WrSlDataGeneral::trk_arg(&self) -> TrkArg; alias trkArg;
        /// @return The slot sound
        fn WrSlDataGeneral::snd_arg(&self) -> SndArg; alias sndArg;
        /// @return The id of the last setting device
        fn WrSlDataGeneral::id_arg(&self) -> IdArg; alias idArg;
        /// Sets the slot sound
        /// @param snd The slots sound to set
        fn WrSlDataGeneral::set_snd_arg(&mut self, snd: SndArg); alias setSndArg;
        /// @return A string in the format "wr_sl_data_general: (args)"
        fn WrSlDataGeneral::to_string(&self) -> String; alias toString;
        /// Checks whether this WrSlDataGeneral is equal to another WrSlDataGeneral
        /// @param other The WrSlDataGeneral to compare to
        /// @return If this WrSlDataGeneral is equal to the other WrSlDataGeneral
        fn WrSlDataGeneral::eq(&self, other: &WrSlDataGeneral) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((WrSlDataGeneral) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.slotArg(), this.stat1Arg(), this.stat2Arg(), this.addressArg(), this.speedArg(), this.dirfArg(), this.trkArg(), this.sndArg(), this.idArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct WrSlDataStructure {
    slot_type: u8,
    time_slot: WrSlDataTime,
    pt_slot: WrSlDataPt,
    general_slot: WrSlDataGeneral
}

impl WrSlDataStructure {
    pub fn new(slot_type: u8, time_slot: &WrSlDataTime, pt_slot: &WrSlDataPt, general_slot: &WrSlDataGeneral) -> Self {
        WrSlDataStructure { slot_type, time_slot:*time_slot, pt_slot:*pt_slot, general_slot:*general_slot }
    }

    pub fn parse(arg1: u8, arg2: u8, arg3: u8, arg4: u8, arg5: u8, arg6: u8, arg7: u8, arg8: u8, arg9: u8, arg10: u8, arg11: u8) -> Self {
        let slot_type = if arg1 == 0x7C { 0x7C } else if arg1 == 0x7B { 0x7B } else { 0x00 };

        let time_slot = WrSlDataTime::parse(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        let pt_slot = WrSlDataPt::parse(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        let general_slot = WrSlDataGeneral::parse(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

        WrSlDataStructure{ slot_type, time_slot, pt_slot, general_slot }
    }

    pub fn slot_type(&self) -> u8 {
        self.slot_type
    }

    pub fn time_slot(&self) -> WrSlDataTime {
        self.time_slot
    }

    pub fn pt_slot(&self) -> WrSlDataPt {
        self.pt_slot
    }

    pub fn general_slot(&self) -> WrSlDataGeneral {
        self.general_slot
    }

    pub fn to_message(&self) -> Vec<u8> {
        if self.slot_type == 0x7C {
            return vec![0xEF as u8, 0x0E as u8, 0x7C as u8, self.pt_slot.0.pcmd(), 0x00 as u8, self.pt_slot.1.adr2(), self.pt_slot.1.adr1(), self.pt_slot.2.trk_arg(), self.pt_slot.3.cvh(), self.pt_slot.3.cvl(), self.pt_slot.3.data7(), 0x00 as u8, 0x00 as u8];
        } else if self.slot_type == 0x7B {
            return vec![0xEF as u8, 0x0E as u8, 0x7B as u8, self.time_slot.0.clk_rate(), self.time_slot.0.frac_minsl(), self.time_slot.0.frac_minsh(), self.time_slot.0.mins(), self.time_slot.1.trk_arg(), self.time_slot.0.hours(), self.time_slot.0.days(), self.time_slot.0.clk_cntrl(), self.time_slot.2.id1(), self.time_slot.2.id2()];
        }
        return vec![0xEF as u8, 0x0E as u8, self.general_slot.0.slot(), self.general_slot.1.stat1(), self.general_slot.3.adr1(), self.general_slot.4.spd(), self.general_slot.5.dirf(), self.general_slot.6.trk_arg(), self.general_slot.2.stat2(), self.general_slot.3.adr2(), self.general_slot.7.snd(), self.general_slot.8.id1(), self.general_slot.8.id2()];
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for WrSlDataStructure {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "wr_sl_data_structure: (slot_type: {}, {}, {}, {})",
            self.slot_type,
            self.general_slot,
            self.pt_slot,
            self.time_slot,
        )
    }
}

foreign_class!(
    /// A write slot data structure
    class WrSlDataStructure {
        self_type WrSlDataStructure;
        /// Creates a new write slot data structure
        /// @param slot_type 0x7C = pt_slot, 0x7B = time_slot, else general slot
        /// @param general_slot The general slot to use
        /// @param pt_slot The pt slot to use
        /// @param time_slot The time slot to use
        constructor WrSlDataStructure::new(slot_type: u8, general_slot: &WrSlDataTime, pt_slot: &WrSlDataPt, time_slot: &WrSlDataGeneral) -> WrSlDataStructure;
        /// @return The slots type (0x7C = pt_slot, 0x7B = time_slot, else general slot)
        fn WrSlDataStructure::slot_type(&self) -> u8; alias slotType;
        /// @return The time slot write structure
        fn WrSlDataStructure::time_slot(&self) -> WrSlDataTime; alias timeSlot;
        /// @return The pt slot write structure
        fn WrSlDataStructure::pt_slot(&self) -> WrSlDataPt; alias ptSlot;
        /// @return The general slot write structure
        fn WrSlDataStructure::general_slot(&self) -> WrSlDataGeneral; alias generalSlot;
        /// @return A string in the format "wr_sl_data_structure: (type: type, general_slot, pt_slot, time_slot)"
        fn WrSlDataStructure::to_string(&self) -> String; alias toString;
        /// Checks whether this WrSlDataStructure is equal to another WrSlDataStructure
        /// @param other The WrSlDataStructure to compare to
        /// @return If this WrSlDataStructure is equal to the other WrSlDataStructure
        fn WrSlDataStructure::eq(&self, other: &WrSlDataStructure) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((WrSlDataStructure) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LissyIrReport {
    arg1: u8,
    dir: bool,
    unit: u16,
    address: u16,
    arg6: u8
}

impl LissyIrReport {
    pub fn new(dir: bool, unit: u16, address: u16, arg6: u8) -> Self {
        LissyIrReport{
            arg1:0x00,
            dir,
            unit,
            address,
            arg6
        }
    }

    pub fn parse(arg1: u8, high_unit: u8, low_unit: u8, high_adr: u8, low_adr: u8, arg6: u8) -> Self {
        assert_eq!(arg1, 0x00, "Given message is not a LissyIR report!");

        let dir = high_unit & 0x40 == 0x40;
        let unit = (((high_unit & 0x3F) as u16) << 7) | (low_unit as u16);
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);

        LissyIrReport{arg1, dir, unit, address, arg6}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let mut high_unit = ((self.unit >> 7) as u8) & 0x3F;
        if self.dir {
            high_unit |= 0x40;
        }
        let low_unit = self.unit as u8 & 0x7F;
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = self.address as u8 & 0x7F;
        vec![0xE4, 0x08, self.arg1, high_unit, low_unit, high_adr, low_adr, self.arg6]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn arg6(&self) -> u8 {
        self.arg6
    }

    pub fn dir(&self) -> bool {
        self.dir
    }

    pub fn unit(&self) -> u16 {
        self.unit
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LissyIrReport {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "lissy_ir_report: (arg1: {}, dir: {}, unit: {}, address: {}, arg6: {})",
            self.arg1,
            self.dir,
            self.unit,
            self.address,
            self.arg6
        )
    }
}

foreign_class!(
    /// Lissy IR report
    class LissyIrReport {
        self_type LissyIrReport;
        /// Creates a new lissy IR report
        /// @param dir The direction
        /// @param unit Reports unit
        /// @param address The address
        /// @param arg6 Reserved for future use
        constructor LissyIrReport::new(dir: bool, unit: u16, address: u16, arg6: u8) -> LissyIrReport;
        /// @return Standard 0x00
        fn LissyIrReport::arg1(&self) -> u8;
        /// @return Reserved for future use
        fn LissyIrReport::arg6(&self) -> u8;
        /// @return The direction
        fn LissyIrReport::dir(&self) -> bool;
        /// @return The reports unit
        fn LissyIrReport::unit(&self) -> u16;
        /// @return The address used
        fn LissyIrReport::address(&self) -> u16;
        /// @return A string in the format "lissy_ir_report: (arg1: {}, dir: {}, unit: {}, address: {}, arg6: {})"
        fn LissyIrReport::to_string(&self) -> String; alias toString;
        /// Checks whether this LissyIrReport is equal to another LissyIrReport
        /// @param other The LissyIrReport to compare to
        /// @return If this LissyIrReport is equal to the other LissyIrReport
        fn LissyIrReport::eq(&self, other: &LissyIrReport) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LissyIrReport) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct RFID5Report {
    arg1: u8,
    address: u16,
    rfid0: u8,
    rfid1: u8,
    rfid2: u8,
    rfid3: u8,
    rfid4: u8,
    rfid_hi: u8
}

impl RFID5Report {
    pub fn new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> Self {
        RFID5Report{ arg1:0x41, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid_hi }
    }

    pub fn parse(arg1: u8, high_adr: u8, low_adr: u8, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid_hi: u8) -> Self {
        assert_eq!(arg1, 0x41, "Given message is not a RFID-5 report!");
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);
        RFID5Report{ arg1, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid_hi }
    }

    pub fn to_message(&self) -> Vec<u8> {
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = (self.address as u8) & 0x7F;
        vec![0xE4, 0x0C, self.arg1, high_adr, low_adr, self.rfid0, self.rfid1, self.rfid2, self.rfid3, self.rfid4, self.rfid_hi]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn rfid0(&self) -> u8 {
        self.rfid0
    }

    pub fn rfid1(&self) -> u8 {
        self.rfid1
    }

    pub fn rfid2(&self) -> u8 {
        self.rfid2
    }

    pub fn rfid3(&self) -> u8 {
        self.rfid3
    }

    pub fn rfid4(&self) -> u8 {
        self.rfid4
    }

    pub fn rfid_hi(&self) -> u8 {
        self.rfid_hi
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for RFID5Report {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "rfid5_report: (arg1: {}, address: {}, rfid0: {}, rfid1: {}, rfid2: {}, rfid3: {}, rfid4: {}, rfid_hi: {})",
            self.arg1,
            self.address,
            self.rfid0,
            self.rfid1,
            self.rfid2,
            self.rfid3,
            self.rfid4,
            self.rfid_hi
        )
    }
}

foreign_class!(
    /// A rfid5 report
    class RFID5Report {
        self_type RFID5Report;
        /// Creates a new rfid5 report
        /// @param address The address to use
        /// @param rfid0 rfid0 arg
        /// @param rfid1 rfid1 arg
        /// @param rfid2 rfid2 arg
        /// @param rfid3 rfid3 arg
        /// @param rfid4 rfid4 arg
        /// @param rfidHi rfid high arg
        constructor RFID5Report::new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfidHi: u8) -> RFID5Report;
        /// @return Standard 0x41
        fn RFID5Report::arg1(&self) -> u8;
        /// @return rfid0
        fn RFID5Report::rfid0(&self) -> u8;
        /// @return rfid1
        fn RFID5Report::rfid1(&self) -> u8;
        /// @return rfid2
        fn RFID5Report::rfid2(&self) -> u8;
        /// @return rfid3
        fn RFID5Report::rfid3(&self) -> u8;
        /// @return rfid4
        fn RFID5Report::rfid4(&self) -> u8;
        /// @return rfid high
        fn RFID5Report::rfid_hi(&self) -> u8; alias rfidHi;
        /// @return The address to use
        fn RFID5Report::address(&self) -> u16;
        /// @return A string in the format "rfid5_report: (arg1: {}, address: {}, rfid0: {}, rfid1: {}, rfid2: {}, rfid3: {}, rfid4: {}, rfid_hi: {})"
        fn RFID5Report::to_string(&self) -> String; alias toString;
        /// Checks whether this RFID5Report is equal to another RFID5Report
        /// @param other The RFID5Report to compare to
        /// @return If this RFID5Report is equal to the other RFID5Report
        fn RFID5Report::eq(&self, other: &RFID5Report) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((RFID5Report) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct RFID7Report {
    arg1: u8,
    address: u16,
    rfid0: u8,
    rfid1: u8,
    rfid2: u8,
    rfid3: u8,
    rfid4: u8,
    rfid5: u8,
    rfid6: u8,
    rfid_hi: u8
}

impl RFID7Report {
    pub fn new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> Self {
        RFID7Report{ arg1:0x41, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid5, rfid6, rfid_hi }
    }

    pub fn parse(arg1: u8, high_adr: u8, low_adr: u8, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfid_hi: u8) -> Self {
        assert_eq!(arg1, 0x41, "Given message is not a RFID-7 report!");
        let address = (((high_adr & 0x7F) as u16) << 7) | (low_adr as u16);
        RFID7Report{arg1, address, rfid0, rfid1, rfid2, rfid3, rfid4, rfid5, rfid6, rfid_hi}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let high_adr = ((self.address >> 7) as u8) & 0x7F;
        let low_adr = (self.address as u8) & 0x7F;
        vec![0xE4, 0x0E, self.arg1, high_adr, low_adr, self.rfid0, self.rfid1, self.rfid2, self.rfid3, self.rfid4, self.rfid5, self.rfid6, self.rfid_hi]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn address(&self) -> u16 {
        self.address
    }

    pub fn rfid0(&self) -> u8 {
        self.rfid0
    }

    pub fn rfid1(&self) -> u8 {
        self.rfid1
    }

    pub fn rfid2(&self) -> u8 {
        self.rfid2
    }

    pub fn rfid3(&self) -> u8 {
        self.rfid3
    }

    pub fn rfid4(&self) -> u8 {
        self.rfid4
    }

    pub fn rfid5(&self) -> u8 {
        self.rfid5
    }

    pub fn rfid6(&self) -> u8 {
        self.rfid6
    }

    pub fn rfid_hi(&self) -> u8 {
        self.rfid_hi
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for RFID7Report {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "rfid5_report: (arg1: {}, address: {}, rfid0: {}, rfid1: {}, rfid2: {}, rfid3: {}, rfid4: {}, rfid5: {}, rfid6: {}, rfid_hi: {})",
            self.arg1,
            self.address,
            self.rfid0,
            self.rfid1,
            self.rfid2,
            self.rfid3,
            self.rfid4,
            self.rfid5,
            self.rfid6,
            self.rfid_hi
        )
    }
}

foreign_class!(
    /// Loco net rfid-7 report
    class RFID7Report {
        self_type RFID7Report;
        /// Creates a new rfid7 report
        /// @param address The address to use
        /// @param rfid0 rfid0 arg
        /// @param rfid1 rfid1 arg
        /// @param rfid2 rfid2 arg
        /// @param rfid3 rfid3 arg
        /// @param rfid4 rfid4 arg
        /// @param rfid5 rfid5 arg
        /// @param rfid6 rfid6 arg
        /// @param rfidHi rfid high arg
        constructor RFID7Report::new(address: u16, rfid0: u8, rfid1: u8, rfid2: u8, rfid3: u8, rfid4: u8, rfid5: u8, rfid6: u8, rfidHi: u8) -> RFID7Report;
        /// @return Standard 0x41
        fn RFID7Report::arg1(&self) -> u8;
        /// @return rfid0
        fn RFID7Report::rfid0(&self) -> u8;
        /// @return rfid1
        fn RFID7Report::rfid1(&self) -> u8;
        /// @return rfid2
        fn RFID7Report::rfid2(&self) -> u8;
        /// @return rfid3
        fn RFID7Report::rfid3(&self) -> u8;
        /// @return rfid4
        fn RFID7Report::rfid4(&self) -> u8;
        /// @return rfid5
        fn RFID7Report::rfid5(&self) -> u8;
        /// @return rfid6
        fn RFID7Report::rfid6(&self) -> u8;
        /// @return rfid high
        fn RFID7Report::rfid_hi(&self) -> u8; alias rfidHi;
        /// @return The address to use
        fn RFID7Report::address(&self) -> u16;
        /// @return A string in the format "rfid7_report: (arg1: {}, address: {}, rfid0: {}, rfid1: {}, rfid2: {}, rfid3: {}, rfid4: {}, rfid5: {}, rfid6: {}, rfid_hi: {})"
        fn RFID7Report::to_string(&self) -> String; alias toString;
        /// Checks whether this RFID7Report is equal to another RFID7Report
        /// @param other The RFID7Report to compare to
        /// @return If this RFID7Report is equal to the other RFID7Report
        fn RFID7Report::eq(&self, other: &RFID7Report) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((RFID7Report) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct WheelcntReport {
    arg1: u8,
    unit: u16,
    direction: bool,
    count: u16,
    arg6: u8
}

impl WheelcntReport {
    pub fn new(unit: u16, direction: bool, count: u16, arg6: u8) -> Self {
        WheelcntReport{ arg1:0x40, unit, direction, count, arg6 }
    }

    pub fn parse(arg1: u8, high_unit: u8, low_unit: u8, high_count: u8, low_count: u8, arg6: u8) -> Self {
        assert_eq!(arg1, 0x40, "Given message is not a wheelcnt report!");
        let count = ((high_count as u16) << 7) | (low_count as u16);
        let direction = high_unit & 0x40 == 0x40;
        let unit = (((high_unit & 0x3F) as u16) << 7) | (low_unit as u16);
        WheelcntReport{arg1, unit, direction, count, arg6}
    }

    pub fn to_message(&self) -> Vec<u8> {
        let mut high_unit = ((self.unit >> 7) as u8) & 0x3F;
        if self.direction {
            high_unit |= 0x40;
        }
        let low_unit = self.unit as u8 & 0x7F;
        let high_count = ((self.count >> 7) as u8) & 0x7F;
        let low_count = self.count as u8 & 0x7F;
        vec![0xE4, 0x08, self.arg1, high_unit, low_unit, high_count, low_count, self.arg6]
    }

    pub fn arg1(&self) -> u8 {
        self.arg1
    }

    pub fn arg6(&self) -> u8 {
        self.arg6
    }

    pub fn unit(&self) -> u16 {
        self.unit
    }

    pub fn count(&self) -> u16 {
        self.count
    }

    pub fn direction(&self) -> bool {
        self.direction
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for WheelcntReport {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "wheel_count_report: (arg1: {}, unit: {}, count: {}, direction: {}, arg6: {})",
            self.arg1,
            self.unit,
            self.count,
            self.direction,
            self.arg6
        )
    }
}

foreign_class!(
    /// A wheel counter report
    class WheelcntReport {
        self_type WheelcntReport;
        /// Creates a wheel counter report
        /// @param unit The reports unit
        /// @param direction The reports direction
        /// @param count The wheel count arg
        /// @param arg6 Reserved for future use
        constructor WheelcntReport::new(unit: u16, direction: bool, count: u16, arg6: u8) -> WheelcntReport;
        /// @return Standard 0x40
        fn WheelcntReport::arg1(&self) -> u8;
        /// @return Reserved for future use
        fn WheelcntReport::arg6(&self) -> u8;
        /// @return The reports unit
        fn WheelcntReport::unit(&self) -> u16;
        /// @return The reports wheel count arg
        fn WheelcntReport::count(&self) -> u16;
        /// @return The set direction
        fn WheelcntReport::direction(&self) -> bool;
        /// @return A string in the format "wheel_count_report: (arg1: {}, unit: {}, count: {}, direction: {}, arg6: {})"
        fn WheelcntReport::to_string(&self) -> String; alias toString;
        /// Checks whether this WheelcntReport is equal to another WheelcntReport
        /// @param other The WheelcntReport to compare to
        /// @return If this WheelcntReport is equal to the other WheelcntReport
        fn WheelcntReport::eq(&self, other: &WheelcntReport) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((WheelcntReport) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum RepStructure {
    LissyIrReport(LissyIrReport),
    RFID5Report(RFID5Report),
    RFID7Report(RFID7Report),
    WheelcntReport(WheelcntReport)
}

impl RepStructure {
    pub fn new_lissy_ir(rep: LissyIrReport) -> Self {
        RepStructure::LissyIrReport(rep)
    }

    pub fn new_rfid_5(rep: RFID5Report, _b1: bool) -> Self {
        RepStructure::RFID5Report(rep)
    }

    pub fn new_rfid_7(rep: RFID7Report, _b1: bool, _b2: bool) -> Self {
        RepStructure::RFID7Report(rep)
    }

    pub fn new_wheelcnt(rep: WheelcntReport, _b1: bool, _b2: bool, _b3: bool) -> Self {
        RepStructure::WheelcntReport(rep)
    }

    pub fn parse(count: u8, args: &[u8]) -> Self {
        return if args[0] == 0x00 {
            Self::LissyIrReport(LissyIrReport::parse(args[0], args[1], args[2], args[3], args[4], args[5]))
        } else if args[0] == 0x40 {
            Self::WheelcntReport(WheelcntReport::parse(args[0], args[1], args[2], args[3], args[4], args[5]))
        } else if args[0] == 0x41 && count == 0x0C {
            Self::RFID5Report(RFID5Report::parse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]))
        } else {
            Self::RFID7Report(RFID7Report::parse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]))
        }
    }

    pub fn get_type(&self) -> u8 {
        match self {
            Self::LissyIrReport(_) => 0,
            Self::RFID5Report(_) => 1,
            Self::RFID7Report(_) => 2,
            Self::WheelcntReport(_) => 3,
        }
    }

    pub fn get_lissy_ir_report(&self) -> LissyIrReport {
        match self {
            Self::LissyIrReport(rep) => *rep,
            Self::RFID5Report(_) => panic!("This information is not available!"),
            Self::RFID7Report(_) => panic!("This information is not available!"),
            Self::WheelcntReport(_) => panic!("This information is not available!"),
        }
    }

    pub fn get_rfid5_report(&self) -> RFID5Report {
        match self {
            Self::LissyIrReport(_) => panic!("This information is not available!"),
            Self::RFID5Report(rep) => *rep,
            Self::RFID7Report(_) => panic!("This information is not available!"),
            Self::WheelcntReport(_) => panic!("This information is not available!"),
        }
    }

    pub fn get_rfid7_report(&self) -> RFID7Report {
        match self {
            Self::LissyIrReport(_) => panic!("This information is not available!"),
            Self::RFID5Report(_) => panic!("This information is not available!"),
            Self::RFID7Report(rep) => *rep,
            Self::WheelcntReport(_) => panic!("This information is not available!"),
        }
    }

    pub fn get_wheelcnt_report(&self) -> WheelcntReport {
        match self {
            Self::LissyIrReport(_) => panic!("This information is not available!"),
            Self::RFID5Report(_) => panic!("This information is not available!"),
            Self::RFID7Report(_) => panic!("This information is not available!"),
            Self::WheelcntReport(rep) => *rep,
        }
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for RepStructure {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LissyIrReport(rep) => write!(f, "{}", rep),
            Self::RFID5Report(rep) => write!(f, "{}", rep),
            Self::RFID7Report(rep) => write!(f, "{}", rep),
            Self::WheelcntReport(rep) => write!(f, "{}", rep),
        }
    }
}

foreign_class!(
    /// Holds a loco net report matching one possible report structure. Please check the type via getType()
    class RepStructure {
        self_type RepStructure;
        /// Creates a report structure with a lissy ir report
        /// @param rep The report to use
        constructor RepStructure::new_lissy_ir(rep: LissyIrReport) -> RepStructure;
        /// Creates a new rfid-5 report
        /// @param rep The report to use
        /// @param b1 jni placeholder, set like you want
        constructor RepStructure::new_rfid_5(rep: RFID5Report, b1: bool) -> RepStructure;
        /// Creates a new rfid-7 report
        /// @param rep The report to use
        /// @param b1 jni placeholder, set like you want
        /// @param b2 jni placeholder, set like you want
        constructor RepStructure::new_rfid_7(rep: RFID7Report, b1: bool, b2: bool) -> RepStructure;
        /// Creates a new wheel count report
        /// @param rep The report to use
        /// @param b1 jni placeholder, set like you want
        /// @param b2 jni placeholder, set like you want
        /// @param b3 jni placeholder, set like you want
        constructor RepStructure::new_wheelcnt(rep: WheelcntReport, b1: bool, b2: bool, b3: bool) -> RepStructure;
        /// @return A wheel count report if type is 3, else panic
        fn RepStructure::get_wheelcnt_report(&self) -> WheelcntReport; alias getWheelcntReport;
        /// @return A rfid-7 report if type is 2, else panic
        fn RepStructure::get_rfid7_report(&self) -> RFID7Report; alias getRfid7Report;
        /// @return A rfid-5 report if type is 1, else panic
        fn RepStructure::get_rfid5_report(&self) -> RFID5Report; alias getRfid5Report;
        /// @return A lissy-ir report if type is 0, else panic
        fn RepStructure::get_lissy_ir_report(&self) -> LissyIrReport; alias getLissyIrReport;
        /// @return The reports type: 0 - lissy-ir, 1 - rfid-5, 2 - rfid-7, 3 - wheel count
        fn RepStructure::get_type(&self) -> u8; alias getType;
        /// @return The string of the report
        fn RepStructure::to_string(&self) -> String; alias toString;
        /// Checks whether this RepStructure is equal to another RepStructure
        /// @param other The RepStructure to compare to
        /// @return If this RepStructure is equal to the other RepStructure
        fn RepStructure::eq(&self, other: &RepStructure) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((RepStructure) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct DstArg(u16);

impl DstArg {
    pub fn new(dst: u16) -> Self {
        DstArg(dst)
    }

    pub fn parse(dst_low: u8, dst_high: u8) -> Self {
        let dst = ((dst_high as u16) << 7) | (dst_low as u16);
        DstArg(dst)
    }

    pub fn dst(&self) -> u16 {
        self.0
    }

    pub fn dst_low(&self) -> u8 {
        self.0 as u8 & 0x7F
    }

    pub fn dst_high(&self) -> u8 {
        (self.0 >> 7) as u8 & 0x7F
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for DstArg {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "dst: {}", self.0)
    }
}

foreign_class!(
    /// The peer x-fers dst arg
    class DstArg {
        self_type DstArg;
        /// Creates a new dst arg
        /// @param dst The dst to set
        constructor DstArg::new(dst: u16) -> DstArg;
        /// @return The dst
        fn DstArg::dst(&self) -> u16;
        /// @return A string in the format "dst: {}"
        fn DstArg::to_string(&self) -> String; alias toString;
        /// Checks whether this DstArg is equal to another DstArg
        /// @param other The DstArg to compare to
        /// @return If this DstArg is equal to the other DstArg
        fn DstArg::eq(&self, other: &DstArg) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((DstArg) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.dst());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct PxctData {
    pxc: u8,
    d1: u8,
    d2: u8,
    d3: u8,
    d4: u8,
    d5: u8,
    d6: u8,
    d7: u8,
    d8: u8
}

impl PxctData {
    pub fn new(pxc: u8, d1: u8, d2: u8, d3: u8, d4: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> Self {
        PxctData { pxc, d1, d2, d3, d4, d5, d6, d7, d8 }
    }

    pub fn parse(pxct1: u8, d1: u8, d2: u8, d3: u8, d4: u8, pxct2: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> Self {
        let pxc = ((pxct1 & 0x70) >> 4) | ((pxct2 & 0x70) >> 1);

        PxctData{pxc, d1: d1 | ((pxct1 & 0x01) << 7), d2: d2 | ((pxct1 & 0x02) << 6), d3: d3 | ((pxct1 & 0x04) << 5), d4: d4 | ((pxct1 & 0x08) << 4), d5: d5 | ((pxct2 & 0x01) << 7), d6: d6 | ((pxct2 & 0x02) << 6), d7: d7 | ((pxct2 & 0x04) << 5), d8: d8 | ((pxct2 & 0x08) << 4)}
    }

    pub fn pxc(&self) -> u8 {
        self.pxc
    }

    pub fn pxct1(&self) -> u8 {
        let mut pxct1 = self.pxc & 0x07 << 4;

        if self.d1 & 0x40 == 0x40 {
            pxct1 |= 0x01;
        }
        if self.d2 & 0x40 == 0x40 {
            pxct1 |= 0x02;
        }
        if self.d3 & 0x40 == 0x40 {
            pxct1 |= 0x04;
        }
        if self.d4 & 0x40 == 0x40 {
            pxct1 |= 0x08;
        }

        pxct1
    }

    pub fn pxct2(&self) -> u8 {
        let mut pxct1 = self.pxc & 0x78 << 1;

        if self.d5 & 0x40 == 0x40 {
            pxct1 |= 0x01;
        }
        if self.d6 & 0x40 == 0x40 {
            pxct1 |= 0x02;
        }
        if self.d7 & 0x40 == 0x40 {
            pxct1 |= 0x04;
        }
        if self.d8 & 0x40 == 0x40 {
            pxct1 |= 0x08;
        }

        pxct1
    }

    pub fn d1(&self) -> u8 {
        self.d1 & 0x3F
    }

    pub fn d2(&self) -> u8 {
        self.d2 & 0x3F
    }

    pub fn d3(&self) -> u8 {
        self.d3 & 0x3F
    }

    pub fn d4(&self) -> u8 {
        self.d4 & 0x3F
    }

    pub fn d5(&self) -> u8 {
        self.d5 & 0x3F
    }

    pub fn d6(&self) -> u8 {
        self.d6 & 0x3F
    }

    pub fn d7(&self) -> u8 {
        self.d7 & 0x3F
    }

    pub fn d8(&self) -> u8 {
        self.d8 & 0x3F
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for PxctData {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "pxct_data: (pxc: {}, d1: {}, d2: {}, d3: {}, d4: {}, d5: {}, d6: {}, d7: {}, d8: {})",
            self.pxc,
            self.d1,
            self.d2,
            self.d3,
            self.d4,
            self.d5,
            self.d6,
            self.d7,
            self.d8,
        )
    }
}

foreign_class!(
    /// Holds the peer xfer message data
    class PxctData {
        self_type PxctData;
        /// Creates new peer xfer data
        /// @param pxc Peer xfer data
        /// @param d1 The data to transfer (8 bytes total)
        /// @param d2 The data to transfer (8 bytes total)
        /// @param d3 The data to transfer (8 bytes total)
        /// @param d4 The data to transfer (8 bytes total)
        /// @param d5 The data to transfer (8 bytes total)
        /// @param d6 The data to transfer (8 bytes total)
        /// @param d7 The data to transfer (8 bytes total)
        /// @param d8 The data to transfer (8 bytes total)
        constructor PxctData::new(pxc: u8, d1: u8, d2: u8, d3: u8, d4: u8, d5: u8, d6: u8, d7: u8, d8: u8) -> PxctData;
        /// @return The peer xfer data
        fn PxctData::pxc(&self) -> u8;
        /// @return The first byte to transfer
        fn PxctData::d1(&self) -> u8;
        /// @return The second byte to transfer
        fn PxctData::d2(&self) -> u8;
        /// @return The third byte to transfer
        fn PxctData::d3(&self) -> u8;
        /// @return The fourth byte to transfer
        fn PxctData::d4(&self) -> u8;
        /// @return The fifth byte to transfer
        fn PxctData::d5(&self) -> u8;
        /// @return The sixth byte to transfer
        fn PxctData::d6(&self) -> u8;
        /// @return The seventh byte to transfer
        fn PxctData::d7(&self) -> u8;
        /// @return The eighth byte to transfer
        fn PxctData::d8(&self) -> u8;
        /// @return A string in the format "pxct_data: (pxc: {}, d1: {}, d2: {}, d3: {}, d4: {}, d5: {}, d6: {}, d7: {}, d8: {})"
        fn PxctData::to_string(&self) -> String; alias toString;
        /// Checks whether this PxctData is equal to another PxctData
        /// @param other The PxctData to compare to
        /// @return If this PxctData is equal to the other PxctData
        fn PxctData::eq(&self, other: &PxctData) -> bool; alias equals;
    foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((PxctData) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.pxc(), this.d1(), this.d2(), this.d3(), this.d4(), this.d5(), this.d6(), this.d7(), this.d8());
    }
"#;
});

pub trait LocoNetMessage {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool;
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Idle();

impl LocoNetMessage for Idle {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x85 as u8])
    }
}

impl Idle {
    pub fn new() -> Self {
        Idle()
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Idle {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Idle")
    }
}

foreign_class!(
    /// Loco Nets idle method (Force idle state, B'cast emergency stop)
    class Idle {
        self_type Idle;
        /// Creates a new Idle object
        constructor Idle::new() -> Idle;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn Idle::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "Idle"
        fn Idle::to_string(&self) -> String; alias toString;
        /// Checks whether this Idle is equal to another Idle
        /// @param other The Idle to compare to
        /// @return If this Idle is equal to the other Idle
        fn Idle::eq(&self, other: &Idle) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Idle) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct GpOn();

impl LocoNetMessage for GpOn {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x83 as u8])
    }
}

impl Display for GpOn {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "GpOn")
    }
}

impl GpOn {
    pub fn new() -> Self {
        GpOn()
    }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

foreign_class!(
    /// Loco nets on method (Power on request)
    class GpOn {
        self_type GpOn;
        /// Creates a new loco net on method
        constructor GpOn::new() -> GpOn;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn GpOn::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "GpOn"
        fn GpOn::to_string(&self) -> String; alias toString;
        /// Checks whether this GpOn is equal to another GpOn
        /// @param other The GpOn to compare to
        /// @return If this GpOn is equal to the other GpOn
        fn GpOn::eq(&self, other: &GpOn) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((GpOn) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct GpOff();

impl LocoNetMessage for GpOff {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x82 as u8])
    }
}

impl GpOff {
    pub fn new() -> Self { GpOff() }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for GpOff {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "GpOff")
    }
}

foreign_class!(
    /// Loco nets off method (Power off request)
    class GpOff {
        self_type GpOff;
        /// Creates a new loco net off method
        constructor GpOff::new() -> GpOff;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn GpOff::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "GpOff"
        fn GpOff::to_string(&self) -> String; alias toString;
        /// Checks whether this GpOff is equal to another GpOff
        /// @param other The GpOff to compare to
        /// @return If this GpOff is equal to the other GpOff
        fn GpOff::eq(&self, other: &GpOff) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((GpOff) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Busy();

impl LocoNetMessage for Busy {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0x81 as u8])
    }
}

impl Busy {
    pub fn new() -> Self { Busy() }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Busy {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Busy")
    }
}

foreign_class!(
    /// Loco nets busy method (Masters busy code)
    class Busy {
        self_type Busy;
        /// Creates a new busy message
        constructor Busy::new() -> Busy;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn Busy::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "Busy"
        fn Busy::to_string(&self) -> String; alias toString;
        /// Checks whether this Busy is equal to another Busy
        /// @param other The Busy to compare to
        /// @return If this Busy is equal to the other Busy
        fn Busy::eq(&self, other: &Busy) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Busy) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LocoAdr(AddressArg);

impl LocoNetMessage for LocoAdr {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBF as u8, self.0.adr2(), self.0.adr1()])
    }
}

impl LocoAdr {
    pub fn new(address: &AddressArg) -> Self { LocoAdr(*address) }

    pub fn address_from_int(address: u16) -> Self { LocoAdr(AddressArg::new(address))}

    pub fn get_address(&self) -> AddressArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LocoAdr {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "LocoAdr({})", self.0)
    }
}

foreign_class!(
    /// Requests a slot for the given address. Answer: LongAck if failed, SL_RD_DATA if success
    class LocoAdr {
        self_type LocoAdr;
        /// @param address The address to request a slot for.
        constructor LocoAdr::new(address: &AddressArg) -> LocoAdr;
        /// @param address The address to request a slot for. Automatically creates the needed address arg.
        constructor LocoAdr::address_from_int(address: u16) -> LocoAdr;
        /// @return The loco address to request a slot for
        fn LocoAdr::get_address(&self) -> AddressArg; alias getAddress;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn LocoAdr::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "LocoAdr(address)"
        fn LocoAdr::to_string(&self) -> String; alias toString;
        /// Checks whether this LocoAdr is equal to another LocoAdr
        /// @param other The LocoAdr to compare to
        /// @return If this LocoAdr is equal to the other LocoAdr
        fn LocoAdr::eq(&self, other: &LocoAdr) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LocoAdr) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getAddress());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SwAck(SwitchArg);

impl LocoNetMessage for SwAck {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBD as u8, self.0.sw1(), self.0.sw2()])
    }
}

impl SwAck {
    pub fn new(sw: &SwitchArg) -> Self { SwAck(*sw) }
    pub fn get_switch(&self) -> SwitchArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SwAck {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SwAck({})", self.0)
    }
}

foreign_class!(
    /// Request switch acknowledge function
    class SwAck {
        self_type SwAck;
        /// @param sw The switch to request acknowledgement for
        constructor SwAck::new(sw: &SwitchArg) -> SwAck;
        /// @return The switch to request acknowledgement for
        fn SwAck::get_switch(&self) -> SwitchArg; alias getSwitch;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn SwAck::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SwAck(switch)"
        fn SwAck::to_string(&self) -> String; alias toString;
        /// Checks whether this SwAck is equal to another SwAck
        /// @param other The SwAck to compare to
        /// @return If this SwAck is equal to the other SwAck
        fn SwAck::eq(&self, other: &SwAck) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SwAck) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSwitch());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SwState(SwitchArg);

impl LocoNetMessage for SwState {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBC as u8, self.0.sw1(), self.0.sw2()])
    }
}

impl SwState {
    pub fn new(sw: &SwitchArg) -> Self { SwState(*sw) }
    pub fn get_switch(&self) -> SwitchArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SwState {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SwState({})", self.0)
    }
}

foreign_class!(
    /// Request state of switch
    class SwState {
        self_type SwState;
        /// @param sw The switch to request state for
        constructor SwState::new(sw: &SwitchArg) -> SwState;
        /// @return The switch to request state for
        fn SwState::get_switch(&self) -> SwitchArg; alias getSwitch;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn SwState::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SwState(switch)"
        fn SwState::to_string(&self) -> String; alias toString;
        /// Checks whether this SwState is equal to another SwState
        /// @param other The SwState to compare to
        /// @return If this SwState is equal to the other SwState
        fn SwState::eq(&self, other: &SwState) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SwState) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSwitch());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct RqSlData(SlotArg);

impl LocoNetMessage for RqSlData {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBB as u8, self.0.slot(), 0x00 as u8])
    }
}

impl RqSlData {
    pub fn new(slot: &SlotArg) -> Self { RqSlData(*slot) }
    pub fn get_slot(&self) -> SlotArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for RqSlData {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "RqSlData({})", self.0)
    }
}

foreign_class!(
    /// Request slot data or status block
    class RqSlData {
        self_type RqSlData;
        /// @param slot The slot to request data for
        constructor RqSlData::new(slot: &SlotArg) -> RqSlData;
        /// @return The slot to request data for
        fn RqSlData::get_slot(&self) -> SlotArg; alias getSlot;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn RqSlData::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SwState(switch)"
        fn RqSlData::to_string(&self) -> String; alias toString;
        /// Checks whether this RqSlData is equal to another RqSlData
        /// @param other The RqSlData to compare to
        /// @return If this RqSlData is equal to the other RqSlData
        fn RqSlData::eq(&self, other: &RqSlData) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((RqSlData) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct MoveSlots(SlotArg, SlotArg);

impl LocoNetMessage for MoveSlots {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xBA as u8, self.0.slot(), self.1.slot()])
    }
}

impl MoveSlots {
    pub fn new(slot_from: &SlotArg, slot_to: &SlotArg) -> Self {
        MoveSlots(*slot_from, *slot_to)
    }
    pub fn get_slot_from(&self) -> SlotArg { self.0 }
    pub fn get_slot_to(&self) -> SlotArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for MoveSlots {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MoveSlots(from: {}, to: {})", self.0, self.1)
    }
}

foreign_class!(
    /// Move slot data from source to destination
    class MoveSlots {
        self_type MoveSlots;
        /// Moves the slot data from source to destination
        /// @param slotFrom The source slot
        /// @param slotTo The destination slot
        constructor MoveSlots::new(slotFrom: &SlotArg, slotTo: &SlotArg) -> MoveSlots;
        /// @return The source slot
        fn MoveSlots::get_slot_from(&self) -> SlotArg; alias getSlotFrom;
        /// @return The destination slot
        fn MoveSlots::get_slot_to(&self) -> SlotArg; alias getSlotTo;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn MoveSlots::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "MoveSlots(from, to)"
        fn MoveSlots::to_string(&self) -> String; alias toString;
        /// Checks whether this MoveSlots is equal to another MoveSlots
        /// @param other The MoveSlots to compare to
        /// @return If this MoveSlots is equal to the other MoveSlots
        fn MoveSlots::eq(&self, other: &MoveSlots) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((MoveSlots) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlotFrom(), this.getSlotTo());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LinkSlots(SlotArg, SlotArg);

impl LocoNetMessage for LinkSlots {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB9 as u8, self.0.slot(), self.1.slot()])
    }
}

impl LinkSlots {
    pub fn new(slot1: &SlotArg, slot2: &SlotArg) -> Self {
        LinkSlots(*slot1, *slot2)
    }
    pub fn get_slot1(&self) -> SlotArg { self.0 }
    pub fn get_slot2(&self) -> SlotArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LinkSlots {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "LinkSlots({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Link slot1 to slot2
    class LinkSlots {
        self_type LinkSlots;
        /// Link slot1 to slot2
        /// @param slot1 The slot to link
        /// @param slot2 The slot to link to
        constructor LinkSlots::new(slot1: &SlotArg, slot2: &SlotArg) -> LinkSlots;
        /// @return The slot to link
        fn LinkSlots::get_slot1(&self) -> SlotArg; alias getSlot1;
        /// @return The slot to link to
        fn LinkSlots::get_slot2(&self) -> SlotArg; alias getSlot2;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn LinkSlots::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "LinkSlots(slot1, slot2)"
        fn LinkSlots::to_string(&self) -> String; alias toString;
        /// Checks whether this LinkSlots is equal to another LinkSlots
        /// @param other The LinkSlots to compare to
        /// @return If this LinkSlots is equal to the other LinkSlots
        fn LinkSlots::eq(&self, other: &LinkSlots) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LinkSlots) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot1(), this.getSlot2());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct UnlinkSlots(SlotArg, SlotArg);

impl LocoNetMessage for UnlinkSlots {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB8 as u8, self.0.slot(), self.1.slot()])
    }
}

impl UnlinkSlots {
    pub fn new(slot1: &SlotArg, slot2: &SlotArg) -> Self {
        UnlinkSlots(*slot1, *slot2)
    }
    pub fn get_slot1(&self) -> SlotArg { self.0 }
    pub fn get_slot2(&self) -> SlotArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for UnlinkSlots {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnlinkSlots({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Unlink slot1 from slot2
    class UnlinkSlots {
        self_type UnlinkSlots;
        /// Unlink slot1 from slot2
        /// @param slot1 The slot to unlink
        /// @param slot2 The slot to unlink from
        constructor UnlinkSlots::new(slot1: &SlotArg, slot2: &SlotArg) -> UnlinkSlots;
        /// @return slot1 The slot to unlink
        fn UnlinkSlots::get_slot1(&self) -> SlotArg; alias getSlot1;
        /// @return slot2 The slot to unlink from
        fn UnlinkSlots::get_slot2(&self) -> SlotArg; alias getSlot2;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn UnlinkSlots::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "UnlinkSlots(slot1, slot2)"
        fn UnlinkSlots::to_string(&self) -> String; alias toString;
        /// Checks whether this UnlinkSlots is equal to another UnlinkSlots
        /// @param other The UnlinkSlots to compare to
        /// @return If this UnlinkSlots is equal to the other UnlinkSlots
        fn UnlinkSlots::eq(&self, other: &UnlinkSlots) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((UnlinkSlots) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot1(), this.getSlot2());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct ConsistFunc(SlotArg, DirfArg);

impl LocoNetMessage for ConsistFunc {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB6 as u8, self.0.slot(), self.1.dirf()])
    }
}

impl ConsistFunc {
    pub fn new(slot: &SlotArg, dirf: &DirfArg) -> Self {
        ConsistFunc(*slot, *dirf)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_dirf(&self) -> DirfArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for ConsistFunc {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConsistFunc({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Set function bits in a consist uplink element
    class ConsistFunc {
        self_type ConsistFunc;
        /// Set function bits in a consist uplink element
        /// @param slot The slot to get uplink element from
        /// @param dirf The function to set
        constructor ConsistFunc::new(slot: &SlotArg, dirf: &DirfArg) -> ConsistFunc;
        /// @return The slot to get uplink element from
        fn ConsistFunc::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The function to set
        fn ConsistFunc::get_dirf(&self) -> DirfArg; alias getDirf;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn ConsistFunc::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "ConsistFunc(slot, dirf)"
        fn ConsistFunc::to_string(&self) -> String; alias toString;
        /// Checks whether this ConsistFunc is equal to another ConsistFunc
        /// @param other The ConsistFunc to compare to
        /// @return If this ConsistFunc is equal to the other ConsistFunc
        fn ConsistFunc::eq(&self, other: &ConsistFunc) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((ConsistFunc) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getDirf());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SlotStat1(SlotArg, Stat1Arg);

impl LocoNetMessage for SlotStat1 {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB5 as u8, self.0.slot(), self.1.stat1()])
    }
}

impl SlotStat1 {
    pub fn new(slot: &SlotArg, stat1: &Stat1Arg) -> Self {
        SlotStat1(*slot, *stat1)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_stat1(&self) -> Stat1Arg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SlotStat1 {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SlotStat1({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Writes slot stat1 to slot
    class SlotStat1 {
        self_type SlotStat1;
        /// Write slot stat1 to slot
        /// @param slot The slot to write to
        /// @param stat1 The stat1 to write to the slot
        constructor SlotStat1::new(slot: &SlotArg, stat1: &Stat1Arg) -> SlotStat1;
        /// @return The slot to write to
        fn SlotStat1::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The stat1 to write
        fn SlotStat1::get_stat1(&self) -> Stat1Arg; alias getStat1;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn SlotStat1::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SlotStat1(slot, stat1)"
        fn SlotStat1::to_string(&self) -> String; alias toString;
        /// Checks whether this SlotStat1 is equal to another SwState
        /// @param other The SlotStat1 to compare to
        /// @return If this SlotStat1 is equal to the other SwState
        fn SlotStat1::eq(&self, other: &SlotStat1) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlotStat1) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getStat1());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LongAck(LopcArg, Ack1Arg);

impl LocoNetMessage for LongAck {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB4 as u8, self.0.lopc(), self.1.ack1()])
    }
}

impl LongAck {
    pub fn new(lopc: &LopcArg, ack1: &Ack1Arg) -> Self {
        LongAck(*lopc, *ack1)
    }
    pub fn get_lopc(&self) -> LopcArg { self.0 }
    pub fn get_ack1(&self) -> Ack1Arg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LongAck {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "LongAck({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Long acknowledgement method. Answer to various messages
    class LongAck {
        self_type LongAck;
        /// Long acknowledgement answer
        /// @param lopc Copy of the op code with seventh bit set to zero
        /// @param ack1 Answer code (0 = error)
        constructor LongAck::new(lopc: &LopcArg, ack1: &Ack1Arg) -> LongAck;
        /// @return Copy of the op code with seventh bit set to zero
        fn LongAck::get_lopc(&self) -> LopcArg; alias getLopc;
        /// @return Answer code (0 = error)
        fn LongAck::get_ack1(&self) -> Ack1Arg; alias getAck1;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn LongAck::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "LongAck(lopc, ack1)"
        fn LongAck::to_string(&self) -> String; alias toString;
        /// Checks whether this LongAck is equal to another LongAck
        /// @param other The LongAck to compare to
        /// @return If this LongAck is equal to the other LongAck
        fn LongAck::eq(&self, other: &LongAck) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LongAck) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getLopc(), this.getAck1());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct InputRep(InArg);

impl LocoNetMessage for InputRep {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB2 as u8, self.0.in1(), self.0.in2()])
    }
}

impl InputRep {
    pub fn new(in_arg: &InArg) -> Self {
        InputRep(*in_arg)
    }
    pub fn get_in_arg(&self) -> InArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for InputRep {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "InputRep({})", self.0)
    }
}

foreign_class!(
    /// General sensor input
    class InputRep {
        self_type InputRep;
        /// General sensor input
        /// @param inArg The sensor input and address
        constructor InputRep::new(inArg: &InArg) -> InputRep;
        /// @return The sensor input and address
        fn InputRep::get_in_arg(&self) -> InArg; alias getInArg;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn InputRep::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "InputRep(in_arg)"
        fn InputRep::to_string(&self) -> String; alias toString;
        /// Checks whether this InputRep is equal to another InputRep
        /// @param other The InputRep to compare to
        /// @return If this InputRep is equal to the other InputRep
        fn InputRep::eq(&self, other: &InputRep) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((InputRep) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getInArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SwRep(SnArg);

impl LocoNetMessage for SwRep {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB1 as u8, self.0.sn1(), self.0.sn2()])
    }
}

impl SwRep {
    pub fn new(sn_arg: &SnArg) -> Self {
        SwRep(*sn_arg)
    }
    pub fn get_sn_arg(&self) -> SnArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SwRep {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SwRep({})", self.0)
    }
}

foreign_class!(
    /// Turnout sensor state report
    class SwRep {
        self_type SwRep;
        /// Turnout sensor state report
        /// @param snArg The sensor state report
        constructor SwRep::new(snArg: &SnArg) -> SwRep;
        /// @return Sensor state report
        fn SwRep::get_sn_arg(&self) -> SnArg; alias getSnArg;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn SwRep::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SwRep(sn_arg)"
        fn SwRep::to_string(&self) -> String; alias toString;
        /// Checks whether this SwRep is equal to another SwRep
        /// @param other The SwRep to compare to
        /// @return If this SwRep is equal to the other SwRep
        fn SwRep::eq(&self, other: &SwRep) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SwRep) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSnArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SwReq(SwitchArg);

impl LocoNetMessage for SwReq {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xB0 as u8, self.0.sw1(), self.0.sw2()])
    }
}

impl SwReq {
    pub fn new(switch_arg: &SwitchArg) -> Self {
        SwReq(*switch_arg)
    }
    pub fn get_switch_arg(&self) -> SwitchArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SwReq {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SwReq({})", self.0)
    }
}

foreign_class!(
    /// Request switch function
    class SwReq {
        self_type SwReq;
        /// Request switch function
        /// @param switchArg The switch and function to request
        constructor SwReq::new(switchArg: &SwitchArg) -> SwReq;
        /// @return The switch and function to request
        fn SwReq::get_switch_arg(&self) -> SwitchArg; alias getSwitchArg;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn SwReq::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SwReq(switch)"
        fn SwReq::to_string(&self) -> String; alias toString;
        /// Checks whether this SwReq is equal to another SwReq
        /// @param other The SwReq to compare to
        /// @return If this SwReq is equal to the other SwReq
        fn SwReq::eq(&self, other: &SwReq) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SwReq) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSwitchArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LocoSnd(SlotArg, SndArg);

impl LocoNetMessage for LocoSnd {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xA2 as u8, self.0.slot(), self.1.snd()])
    }
}

impl LocoSnd {
    pub fn new(slot: &SlotArg, snd: &SndArg) -> Self {
        LocoSnd(*slot, *snd)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_snd(&self) -> SndArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LocoSnd {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "LocoSnd({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Sets slot sound function
    class LocoSnd {
        self_type LocoSnd;
        /// Sets slot sound function
        /// @param slot The slot to set the sound function to
        /// @param snd The sound function to set
        constructor LocoSnd::new(slot: &SlotArg, snd: &SndArg) -> LocoSnd;
        /// @return The slot to set the sound function to
        fn LocoSnd::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The sound function to set
        fn LocoSnd::get_snd(&self) -> SndArg; alias getSnd;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn LocoSnd::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "LocoSnd(slot, snd)"
        fn LocoSnd::to_string(&self) -> String; alias toString;
        /// Checks whether this LocoSnd is equal to another LocoSnd
        /// @param other The LocoSnd to compare to
        /// @return If this LocoSnd is equal to the other LocoSnd
        fn LocoSnd::eq(&self, other: &LocoSnd) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LocoSnd) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getSnd());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LocoDirf(SlotArg, DirfArg);

impl LocoNetMessage for LocoDirf {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xA1 as u8, self.0.slot(), self.1.dirf()])
    }
}

impl LocoDirf {
    pub fn new(slot: &SlotArg, dirf: &DirfArg) -> Self {
        LocoDirf(*slot, *dirf)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_dirf(&self) -> DirfArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LocoDirf {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "LocoDirf({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Set slot direction and functions 0 - 4
    class LocoDirf {
        self_type LocoDirf;
        /// Set slot direction and functions 0 - 4
        /// @param slot The slot to set the direction and function to
        /// @param dirf The direction and function arguments
        constructor LocoDirf::new(slot: &SlotArg, dirf: &DirfArg) -> LocoDirf;
        /// @return The slot to set the direction and function to
        fn LocoDirf::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The direction and function arguments
        fn LocoDirf::get_dirf(&self) -> DirfArg; alias getDirf;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn LocoDirf::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "LocoDirf(slot, dirf)"
        fn LocoDirf::to_string(&self) -> String; alias toString;
        /// Checks whether this LocoDirf is equal to another LocoDirf
        /// @param other The LocoDirf to compare to
        /// @return If this LocoDirf is equal to the other LocoDirf
        fn LocoDirf::eq(&self, other: &LocoDirf) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LocoDirf) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getDirf());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct LocoSpd(SlotArg, SpeedArg);

impl LocoNetMessage for LocoSpd {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xA0 as u8, self.0.slot(), self.1.spd()])
    }
}

impl LocoSpd {
    pub fn new_easy(slot: &SlotArg, spd: u16) -> Self {
        LocoSpd(*slot, SpeedArg::new(spd))
    }
    pub fn new(slot: &SlotArg, spd: &SpeedArg) -> Self {
        LocoSpd(*slot, *spd)
    }
    pub fn emergency_stop(slot: &SlotArg) -> Self {
        LocoSpd(*slot, SpeedArg::EmergencyStop)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_spd(&self) -> SpeedArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for LocoSpd {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "LocoSpd({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Set the slots speed
    class LocoSpd {
        self_type LocoSpd;
        /// Sets the slots speed
        /// @param slot The slot to set the speed to
        /// @param spd The speed to set
        constructor LocoSpd::new(slot: &SlotArg, spd: &SpeedArg) -> LocoSpd;
        /// Sets the slot speed
        /// @param slot The slot to set the speed to
        /// @param spd The speed to set. Only values between 0 and 128 are allowed here.
        constructor LocoSpd::new_easy(slot: &SlotArg, spd: u16) -> LocoSpd;
        /// Sets the slot speed to an emergency stop
        /// @param slot The slot to set the speed to
        constructor LocoSpd::emergency_stop(slot: &SlotArg) -> LocoSpd;
        /// @return The slot to set the speed to
        fn LocoSpd::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The speed to set
        fn LocoSpd::get_spd(&self) -> SpeedArg; alias getSpd;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn LocoSpd::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "LocoSpd(slot, spd)"
        fn LocoSpd::to_string(&self) -> String; alias toString;
        /// Checks whether this LocoSpd is equal to another LocoSpd
        /// @param other The LocoSpd to compare to
        /// @return If this LocoSpd is equal to the other LocoSpd
        fn LocoSpd::eq(&self, other: &LocoSpd) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((LocoSpd) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getSpd());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct MultiSense(MultiSenseArg, AddressArg);

impl LocoNetMessage for MultiSense {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xD0 as u8, self.0.m_high(), self.0.zas(), self.1.adr1(), self.1.adr2()])
    }
}

impl MultiSense {
    pub fn new(multi_sense_arg: &MultiSenseArg, sense_adr: &AddressArg) -> Self {
        MultiSense(*multi_sense_arg, *sense_adr)
    }
    pub fn get_multi_sense_arg(&self) -> MultiSenseArg { self.0 }
    pub fn get_sense_adr(&self) -> AddressArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for MultiSense {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "multi_sense: ({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Power management and transponding message
    class MultiSense {
        self_type MultiSense;
        /// Power management and transponding message
        /// @param multiSenseArg The multi sense part
        /// @param senseAdr The sense address
        constructor MultiSense::new(multiSenseArg: &MultiSenseArg, senseAdr: &AddressArg) -> MultiSense;
        /// @return The multi sense part
        fn MultiSense::get_multi_sense_arg(&self) -> MultiSenseArg; alias getMultiSenseArg;
        /// @return The sense address
        fn MultiSense::get_sense_adr(&self) -> AddressArg; alias getSenseAdr;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn MultiSense::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "MultiSense(multi_sense_arg, sense_address)"
        fn MultiSense::to_string(&self) -> String; alias toString;
        /// Checks whether this MultiSense is equal to another MultiSense
        /// @param other The MultiSense to compare to
        /// @return If this MultiSense is equal to the other MultiSense
        fn MultiSense::eq(&self, other: &MultiSense) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((MultiSense) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getMultiSenseArg(), this.getSenseAdr());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct UhliFun(SlotArg, FunctionArg);

impl LocoNetMessage for UhliFun {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xD4 as u8, 0x20 as u8, self.0.slot(), self.1.group(), self.1.function()])
    }
}

impl UhliFun {
    pub fn new(slot: &SlotArg, function: &FunctionArg) -> Self {
        UhliFun(*slot, *function)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_function(&self) -> FunctionArg { self.1 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for UhliFun {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "UhliFun({}, {})", self.0, self.1)
    }
}

foreign_class!(
    /// Uhlenbrock slot function setting (f9 - f28)
    class UhliFun {
        self_type UhliFun;
        /// Sets the function values to the given slot
        /// @param slot The slot to set the function values to
        /// @param function The function values to set
        constructor UhliFun::new(slot: &SlotArg, function: &FunctionArg) -> UhliFun;
        /// @return The slot to set the function values to
        fn UhliFun::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The function values
        fn UhliFun::get_function(&self) -> FunctionArg; alias getFunction;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn UhliFun::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "UhliFun(slot, function_arg)"
        fn UhliFun::to_string(&self) -> String; alias toString;
        /// Checks whether this UhliFun is equal to another UhliFun
        /// @param other The UhliFun to compare to
        /// @return If this UhliFun is equal to the other UhliFun
        fn UhliFun::eq(&self, other: &UhliFun) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((UhliFun) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getFunction());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct WrSlData(WrSlDataStructure);

impl LocoNetMessage for WrSlData {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(self.0.to_message())
    }
}

impl WrSlData {
    pub fn new(slot_data: &WrSlDataStructure) -> Self {
        WrSlData(*slot_data)
    }
    pub fn get_slot_data_structure(&self) -> WrSlDataStructure { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for WrSlData {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

foreign_class!(
    /// Writes data to a slot. This op code has variable encodings
    class WrSlData {
        self_type WrSlData;
        /// A new write slot data message
        /// @param slotData The slot write data structure to create the message of
        constructor WrSlData::new(slotData: &WrSlDataStructure) -> WrSlData;
        /// @return The slot write data structure to create the message of
        fn WrSlData::get_slot_data_structure(&self) -> WrSlDataStructure; alias getSlotDataStructure;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn WrSlData::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SwState(switch)"
        fn WrSlData::to_string(&self) -> String; alias toString;
        /// Checks whether this WrSlData is equal to another WrSlData
        /// @param other The WrSlData to compare to
        /// @return If this WrSlData is equal to the other WrSlData
        fn WrSlData::eq(&self, other: &WrSlData) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((WrSlData) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlotDataStructure());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct SlRdData(SlotArg, Stat1Arg, AddressArg, SpeedArg, DirfArg, TrkArg, Stat2Arg, SndArg, IdArg);

impl LocoNetMessage for SlRdData {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xE7 as u8, 0x0E as u8, self.0.slot(), self.1.stat1(), self.2.adr1(), self.3.spd(), self.4.dirf(), self.5.trk_arg(),
                                  self.6.stat2(), self.2.adr2(), self.7.snd(), self.8.id1(), self.8.id2()])
    }
}

impl SlRdData {
    pub fn new(slot: &SlotArg, stat1: &Stat1Arg, address: &AddressArg, speed: &SpeedArg, dirf: &DirfArg, trk: &TrkArg, stat2: &Stat2Arg, id: &IdArg) -> Self {
        SlRdData(*slot, *stat1, *address, *speed, *dirf, *trk, *stat2, SndArg::parse(0), *id)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_stat1(&self) -> Stat1Arg { self.1 }
    pub fn get_address(&self) -> AddressArg { self.2 }
    pub fn get_speed(&self) -> SpeedArg { self.3 }
    pub fn get_dirf(&self) -> DirfArg { self.4 }
    pub fn get_trk(&self) -> TrkArg { self.5 }
    pub fn get_stat2(&self) -> Stat2Arg { self.6 }
    pub fn get_snd(&self) -> SndArg { self.7 }
    pub fn get_id(&self) -> IdArg { self.8 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for SlRdData {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SlRdData({}, {}, {}, {}, {}, {}, {}, {}, {})", self.0, self.1, self.2, self.3, self.4, self.5, self.6, self.7, self.8)
    }
}

foreign_class!(
    /// Slot data response
    class SlRdData {
        self_type SlRdData;
        /// Slot data response
        /// @param slot The slot the response is for
        /// @param stat1 The slots status with speed steps
        /// @param address The trains address bound to this slot
        /// @param speed The trains speed
        /// @param dirf The trains direction and functions 0 - 4
        /// @param trk Global system track status
        /// @param stat2 More slot status information
        /// @param id Throttle or PC ID if slot status 2 is id encoded alias
        constructor SlRdData::new(slot: &SlotArg, stat1: &Stat1Arg, address: &AddressArg, speed: &SpeedArg, dirf: &DirfArg, trk: &TrkArg, stat2: &Stat2Arg, id: &IdArg) -> SlRdData;
        /// @return The slot the response is for
        fn SlRdData::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The slots status with speed steps
        fn SlRdData::get_stat1(&self) -> Stat1Arg; alias getStat1;
        /// @return The trains address bound to this slot
        fn SlRdData::get_address(&self) -> AddressArg; alias getAddress;
        /// @return The trains speed
        fn SlRdData::get_speed(&self) -> SpeedArg; alias getSpeed;
        /// @return The trains direction and functions 0 - 4
        fn SlRdData::get_dirf(&self) -> DirfArg; alias getDirf;
        /// @return Global system track status
        fn SlRdData::get_trk(&self) -> TrkArg; alias getTrk;
        /// @return More slot status information
        fn SlRdData::get_stat2(&self) -> Stat2Arg; alias getStat2;
        /// @return The sound information of this slot
        fn SlRdData::get_snd(&self) -> SndArg; alias getSnd;
        /// @return Throttle or PC ID if slot status 2 is id encoded alias
        fn SlRdData::get_id(&self) -> IdArg; alias getId;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn SlRdData::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "SlRdData(slot, stat1, address, speed, dirf, trk, stat2, snd, id)"
        fn SlRdData::to_string(&self) -> String; alias toString;
        /// Checks whether this SlRdData is equal to another SlRdData
        /// @param other The SlRdData to compare to
        /// @return If this SlRdData is equal to the other SlRdData
        fn SlRdData::eq(&self, other: &SlRdData) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((SlRdData) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.toString());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct ImmPacket(ImArg);

impl LocoNetMessage for ImmPacket {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xED as u8, 0x0B as u8, 0x7F as u8, self.0.reps(), self.0.dhi(), self.0.im1(), self.0.im2(), self.0.im3(), self.0.im4(), self.0.im5()])
    }
}

impl ImmPacket {
    pub fn new(im_arg: &ImArg) -> Self {
        ImmPacket(*im_arg)
    }
    pub fn get_im_arg(&self) -> ImArg { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for ImmPacket {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "ImmPacket({})", self.0)
    }
}

foreign_class!(
    /// Send immediate m byte packet (Digitrax f9 - f28)
    class ImmPacket {
        self_type ImmPacket;
        /// Send immediate m byte packet (Digitrax f9 - f28)
        /// @param imArg The im message
        constructor ImmPacket::new(imArg: &ImArg) -> ImmPacket;
        /// @return The im message
        fn ImmPacket::get_im_arg(&self) -> ImArg; alias getImArg;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn ImmPacket::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "ImmPacket(im_arg)"
        fn ImmPacket::to_string(&self) -> String; alias toString;
        /// Checks whether this ImmPacket is equal to another ImmPacket
        /// @param other The ImmPacket to compare to
        /// @return If this ImmPacket is equal to the other ImmPacket
        fn ImmPacket::eq(&self, other: &ImmPacket) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((ImmPacket) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getImArg());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct Rep(RepStructure);

impl LocoNetMessage for Rep {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(match self.0 {
            RepStructure::RFID7Report(report) => report.to_message(),
            RepStructure::RFID5Report(report) => report.to_message(),
            RepStructure::LissyIrReport(report) => report.to_message(),
            RepStructure::WheelcntReport(report) => report.to_message(),
        })
    }
}

impl Rep {
    pub fn new(rep: &RepStructure) -> Self {
        Rep(*rep)
    }
    pub fn get_rep(&self) -> RepStructure { self.0 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for Rep {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

foreign_class!(
    /// A report message, get the type over the report structure.
    class Rep {
        self_type Rep;
        /// A report message.
        /// @param rep The report structure of this message
        constructor Rep::new(rep: &RepStructure) -> Rep;
        /// @return This methods report structure
        fn Rep::get_rep(&self) -> RepStructure; alias getRep;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn Rep::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "report_structure"
        fn Rep::to_string(&self) -> String; alias toString;
        /// Checks whether this Rep is equal to another Rep
        /// @param other The Rep to compare to
        /// @return If this Rep is equal to the other Rep
        fn Rep::eq(&self, other: &Rep) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((Rep) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getRep());
    }
"#;
});

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct PeerXfer(SlotArg, DstArg, PxctData);

impl LocoNetMessage for PeerXfer {
    fn send(&self, loco_connector: &mut LocoNetConnector) -> bool {
        loco_connector.write(vec![0xE5, 0x10, self.0.slot(), self.1.dst_low(), self.1.dst_high(), self.2.pxct1(), self.2.d1(), self.2.d2(), self.2.d3(), self.2.d4(), self.2.pxct2(), self.2.d5(), self.2.d6(), self.2.d7(), self.2.d8()])
    }
}

impl PeerXfer {
    pub fn new(slot: &SlotArg, dst: &DstArg, pxct: &PxctData) -> Self {
        PeerXfer(*slot, *dst, *pxct)
    }
    pub fn get_slot(&self) -> SlotArg { self.0 }
    pub fn get_dst(&self) -> DstArg { self.1 }
    pub fn get_pxct(&self) -> PxctData { self.2 }

    fn to_string(&self) -> String {
        format!("{}", self)
    }
}

impl Display for PeerXfer {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "PeerXfer({}, {}, {})", self.0, self.1, self.2)
    }
}

foreign_class!(
    /// Moves 8 bytes peer to peer from the source to the destination
    class PeerXfer {
        self_type PeerXfer;
        /// Moves 8 bytes peer to peer from the source to the destination
        /// @param slot The slot to get the data from
        /// @param dst The destination to move the byte to
        /// @param pxct The pxct data bytes to move
        constructor PeerXfer::new(slot: &SlotArg, dst: &DstArg, pxct: &PxctData) -> PeerXfer;
        /// @return The slot to get the data from
        fn PeerXfer::get_slot(&self) -> SlotArg; alias getSlot;
        /// @return The destination to move the byte to
        fn PeerXfer::get_dst(&self) -> DstArg; alias getDst;
        /// @return The pxct data bytes to move
        fn PeerXfer::get_pxct(&self) -> PxctData; alias getPxct;
        /// Sends the message to the loco net (You need a loco net connection. I recommend to use {@link de.noisruker.locodrive.control.LocoNetHandler#send(ILocoNetMessage)} to send messages, if the LocoNetHandler has a port set)
        /// @param locoNetConnector The loco net connection to use for sending
        fn PeerXfer::send(&self, locoNetConnector: &mut LocoNetConnector) -> bool;
        /// @return A string in the format "PeerXfer(slot, dst, pxct)"
        fn PeerXfer::to_string(&self) -> String; alias toString;
        /// Checks whether this PeerXfer is equal to another PeerXfer
        /// @param other The PeerXfer to compare to
        /// @return If this PeerXfer is equal to the other PeerXfer
        fn PeerXfer::eq(&self, other: &PeerXfer) -> bool; alias equals;
        foreign_code r#"
    /**
     * Checks whether this object is equal to another object.
     * @param o The object to compare to
     * @return If this object is equal to the given object
     */
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;
        return this.equals((PeerXfer) o);
    }

    /**
     * Generates a hash code for this class.
     * @return The generated hash code
     */
    @Override
    public int hashCode() {
        return java.util.Objects.hash(this.getSlot(), this.getDst(), this.getPxct());
    }
"#;
});

pub fn get_all_ports() -> Vec<String> {
    serialport::available_ports().expect("No ports found").into_iter().map(|port_info| port_info.port_name).collect()
}

foreign_class!(
    /// Helper class for getting all ports
    class PortInfos {
        /// @return All known serial ports from this system
        fn get_all_ports() -> Vec<String>; alias getAllPorts;
});

#[repr(u8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Message {
    Idle(Idle),
    GpOn(GpOn),
    GpOff(GpOff),
    Busy(Busy),

    LocoAdr(LocoAdr),
    SwAck(SwAck),
    SwState(SwState),
    RqSlData(RqSlData),
    MoveSlots(MoveSlots),
    LinkSlots(LinkSlots),
    UnlinkSlots(UnlinkSlots),
    ConsistFunc(ConsistFunc),
    SlotStat1(SlotStat1),
    LongAck(LongAck),
    InputRep(InputRep),
    SwRep(SwRep),
    SwReq(SwReq),
    LocoSnd(LocoSnd),
    LocoDirf(LocoDirf),
    LocoSpd(LocoSpd),
    MultiSense(MultiSense),
    UhliFun(UhliFun),
    WrSlData(WrSlData),
    SlRdData(SlRdData),
    ImmPacket(ImmPacket),
    Rep(Rep),
    PeerXfer(PeerXfer),
}

impl Message {
    pub fn get_message_type(&self) -> u8 {
        match self {
            Message::Idle(_) => 0,
            Message::GpOn(_) => 1,
            Message::GpOff(_) => 2,
            Message::Busy(_) => 3,
            Message::LocoAdr(_) => 4,
            Message::SwAck(_) => 5,
            Message::SwState(_) => 6,
            Message::RqSlData(_) => 7,
            Message::MoveSlots(_) => 8,
            Message::LinkSlots(_) => 9,
            Message::UnlinkSlots(_) => 10,
            Message::ConsistFunc(_) => 11,
            Message::SlotStat1(_) => 12,
            Message::LongAck(_) => 13,
            Message::InputRep(_) => 14,
            Message::SwRep(_) => 15,
            Message::SwReq(_) => 16,
            Message::LocoSnd(_) => 17,
            Message::LocoDirf(_) => 18,
            Message::LocoSpd(_) => 19,
            Message::MultiSense(_) => 20,
            Message::UhliFun(_) => 21,
            Message::WrSlData(_) => 22,
            Message::SlRdData(_) => 23,
            Message::ImmPacket(_) => 24,
            Message::Rep(_) => 25,
            Message::PeerXfer(_) => 26,
        }
    }

    pub fn lack_follows(&self) -> bool {
        match self {
            Message::LocoAdr(_) => true,
            Message::SwAck(_) => true,
            Message::SwState(_) => true,
            Message::SwReq(_) => true,
            Message::WrSlData(_) => true,
            Message::ImmPacket(_) => true,
            _ => false
        }
    }

    pub fn get_idle(&self) -> Idle {
        match *self {
            Message::Idle(idle) => idle,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_gp_on(&self) -> GpOn {
        match *self {
            Message::GpOn(gpon) => gpon,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_gp_off(&self) -> GpOff {
        match *self {
            Message::GpOff(gpoff) => gpoff,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_busy(&self) -> Busy {
        match *self {
            Message::Busy(busy) => busy,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_adr(&self) -> LocoAdr {
        match *self {
            Message::LocoAdr(adr) => adr,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_ack(&self) -> SwAck {
        match *self {
            Message::SwAck(sw_ack) => sw_ack,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_state(&self) -> SwState {
        match *self {
            Message::SwState(sw_state) => sw_state,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_rq_sl_data(&self) -> RqSlData {
        match *self {
            Message::RqSlData(rq_sl_data) => rq_sl_data,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_move_slots(&self) -> MoveSlots {
        match *self {
            Message::MoveSlots(move_slots) => move_slots,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_link_slots(&self) -> LinkSlots {
        match *self {
            Message::LinkSlots(link_slots) => link_slots,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_unlink_slots(&self) -> UnlinkSlots {
        match *self {
            Message::UnlinkSlots(unlink_slots) => unlink_slots,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_consist_func(&self) -> ConsistFunc {
        match *self {
            Message::ConsistFunc(consist_func) => consist_func,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_slot_stat1(&self) -> SlotStat1 {
        match *self {
            Message::SlotStat1(slot_stat1) => slot_stat1,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_long_ack(&self) -> LongAck {
        match *self {
            Message::LongAck(long_ack) => long_ack,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_input_rep(&self) -> InputRep {
        match *self {
            Message::InputRep(input_rep) => input_rep,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_rep(&self) -> SwRep {
        match *self {
            Message::SwRep(sw_rep) => sw_rep,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sw_req(&self) -> SwReq {
        match *self {
            Message::SwReq(sw_req) => sw_req,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_snd(&self) -> LocoSnd {
        match *self {
            Message::LocoSnd(loco_snd) => loco_snd,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_dirf(&self) -> LocoDirf {
        match *self {
            Message::LocoDirf(loco_dirf) => loco_dirf,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_loco_spd(&self) -> LocoSpd {
        match *self {
            Message::LocoSpd(loco_spd) => loco_spd,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_multi_sense(&self) -> MultiSense {
        match *self {
            Message::MultiSense(multi_sense) => multi_sense,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_uhli_fun(&self) -> UhliFun {
        match *self {
            Message::UhliFun(uhli_fun) => uhli_fun,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_wr_sl_data(&self) -> WrSlData {
        match *self {
            Message::WrSlData(wr_sl_data) => wr_sl_data,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_sl_rd_data(&self) -> SlRdData {
        match *self {
            Message::SlRdData(sl_rd_data) => sl_rd_data,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_imm_packet(&self) -> ImmPacket {
        match *self {
            Message::ImmPacket(imm_packet) => imm_packet,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_rep(&self) -> Rep {
        match *self {
            Message::Rep(rep) => rep,
            _ => { panic!("Could not load message") },
        }
    }

    pub fn get_peer_xfer(&self) -> PeerXfer {
        match *self {
            Message::PeerXfer(peer_xfer) => peer_xfer,
            _ => { panic!("Could not load message") },
        }
    }
}

foreign_class!(
/// This class represents a loco net message. Its type can be found out by calling getMessageType. This class is a bridge for rust and java messages, to dont lose the type data.
class Message {
    self_type Message;
    private constructor = empty;
    /// The type of the loco net message
    /// 0 - Idle,<br>
    /// 1 - GpOn,<br>
    /// 2 - GpOff,<br>
    /// 3 - Busy,<br>
    /// 4 - LocoAdr,<br>
    /// 5 - SwAck,<br>
    /// 6 - SwState,
    /// 7 - RqSlData,
    /// 8 - MoveSlots,
    /// 9 - LinkSlots,
    /// 10 - UnlinkSlots,
    /// 11 - ConsistFunc,
    /// 12 - SlotStat1,
    /// 13 - LongAck,
    /// 14 - InputRep,
    /// 15 - SwRep,
    /// 16 - SwReq,
    /// 17 - LocoSnd,
    /// 18 - LocoDirf,
    /// 19 - LocoSpd,
    /// 20 - MultiSense,
    /// 21 - UhliFun,
    /// 22 - WrSlData,
    /// 23 - SlRdData,
    /// 24 - ImmPacket,
    /// 25 - Rep,
    /// 26 - PeerXfer,
    /// @return The loco net message type
    fn Message::get_message_type(&self) -> u8; alias getMessageType;
    /// @return The Idle message if this message is an Idle message
    fn Message::get_idle(&self) -> Idle; alias getIdle;
    /// @return The GpOn message if this message is an GpOn message
    fn Message::get_gp_on(&self) -> GpOn; alias getGpOn;
    /// @return The GpOff message if this message is an GpOff message
    fn Message::get_gp_off(&self) -> GpOff; alias getGpOff;
    /// @return The Busy message if this message is an Busy message
    fn Message::get_busy(&self) -> Busy; alias getBusy;
    /// @return The LocoAdr message if this message is an LocoAdr message
    fn Message::get_loco_adr(&self) -> LocoAdr; alias getLocoAdr;
    /// @return The SwAck message if this message is an SwAck message
    fn Message::get_sw_ack(&self) -> SwAck; alias getSwAck;
    /// @return The SwState message if this message is an SwState message
    fn Message::get_sw_state(&self) -> SwState; alias getSwState;
    /// @return The RqSlData message if this message is an RqSlData message
    fn Message::get_rq_sl_data(&self) -> RqSlData; alias getRqSlData;
    /// @return The MoveSlots message if this message is an MoveSlots message
    fn Message::get_move_slots(&self) -> MoveSlots; alias getMoveSlots;
    /// @return The LinkSlots message if this message is an LinkSlots message
    fn Message::get_link_slots(&self) -> LinkSlots; alias getLinkSlots;
    /// @return The UnlinkSlots message if this message is an UnlinkSlots message
    fn Message::get_unlink_slots(&self) -> UnlinkSlots; alias getUnlinkSlots;
    /// @return The ConsistFunc message if this message is an ConsistFunc message
    fn Message::get_consist_func(&self) -> ConsistFunc; alias getConsistFunc;
    /// @return The SlotStat1 message if this message is an SlotStat1 message
    fn Message::get_slot_stat1(&self) -> SlotStat1; alias getSlotStat1;
    /// @return The LongAck message if this message is an LongAck message
    fn Message::get_long_ack(&self) -> LongAck; alias getLongAck;
    /// @return The InputRep message if this message is an InputRep message
    fn Message::get_input_rep(&self) -> InputRep; alias getInputRep;
    /// @return The SwRep message if this message is an SwRep message
    fn Message::get_sw_rep(&self) -> SwRep; alias getSwRep;
    /// @return The SwReq message if this message is an SwReq message
    fn Message::get_sw_req(&self) -> SwReq; alias getSwReq;
    /// @return The LocoSnd message if this message is an LocoSnd message
    fn Message::get_loco_snd(&self) -> LocoSnd; alias getLocoSnd;
    /// @return The LocoDirf message if this message is an LocoDirf message
    fn Message::get_loco_dirf(&self) -> LocoDirf; alias getLocoDirf;
    /// @return The LocoSpd message if this message is an LocoSpd message
    fn Message::get_loco_spd(&self) -> LocoSpd; alias getLocoSpd;
    /// @return The MultiSense message if this message is an MultiSense message
    fn Message::get_multi_sense(&self) -> MultiSense; alias getMultiSense;
    /// @return The UhliFun message if this message is an UhliFun message
    fn Message::get_uhli_fun(&self) -> UhliFun; alias getUhliFun;
    /// @return The WrSlData message if this message is an WrSlData message
    fn Message::get_wr_sl_data(&self) -> WrSlData; alias getWrSlData;
    /// @return The SlRdData message if this message is an SlRdData message
    fn Message::get_sl_rd_data(&self) -> SlRdData; alias getSlRdData;
    /// @return The ImmPacket message if this message is an ImmPacket message
    fn Message::get_imm_packet(&self) -> ImmPacket; alias getImmPacket;
    /// @return The Rep message if this message is an Rep message
    fn Message::get_rep(&self) -> Rep; alias getRep;
    /// @return The PeerXfer message if this message is an PeerXfer message
    fn Message::get_peer_xfer(&self) -> PeerXfer; alias getPeerXfer;
});

pub trait ExceptionObserver: Send {
    fn on_exception_occurred(&self, error: MessageParseError);
}

pub trait LocoNetMessageObserver: Send {
    fn on_message_occurred(&self, message: Message);
}

pub trait LackMessageObserver: Send {
    fn on_lack_occurred(&self, lack: LongAck, message: Message);
}

foreign_callback!(
/// This interface represents a observer for a loco net message.
callback LocoNetMessageObserver {
    self_type LocoNetMessageObserver;
    /// Called by the locoNetConnector when a message occurred.
    /// @param message The message that occurred
    onMessageOccurred = LocoNetMessageObserver::on_message_occurred(&self, message: Message);
});

foreign_callback!(
/// This interface represents a observer for handling exceptions, that occurred while reading or writing to the loco net
callback ExceptionObserver {
    self_type ExceptionObserver;
    /// Called by the locoNetConnector when a message occurred.
    /// @param message The error that occurred
    onExceptionOccurred = ExceptionObserver::on_exception_occurred(&self, message: MessageParseError);
});

foreign_callback!(
/// This interface represents a observer for handling lack messages. Lack messages are responses to before messages and immediately follows those
callback LackMessageObserver {
    self_type LackMessageObserver;
    /// Called by the locoNetConnector when a lack message occurred.
    /// @param lack The lack message that was received
    /// @param message The message the lack response was received for
    onLackOccurred = LackMessageObserver::on_lack_occurred(&self, lack: LongAck, message: Message);
});

pub struct LocoNetConnector {
    port: Box<dyn SerialPort>,
    message_observer: Box<dyn LocoNetMessageObserver>,
    lack_observer: Box<dyn LackMessageObserver>,
    error_handler: Box<dyn ExceptionObserver>,
    lack: bool,
    last_message: Message,
    send: Arc<(Mutex<Vec<u8>>, Condvar, Condvar)>,
    stop: Mutex<bool>,
    reading_thread: Option<JoinHandle<()>>,
    sending_timeout: u64
}

impl LocoNetConnector {
    /// Creates a new port
    pub fn new(port_name: &str, baud_rate: u32, sending_timeout: u64, update_cycles: u64, flow_control: FlowControl, message_observer: Box<dyn LocoNetMessageObserver>, lack_observer: Box<dyn LackMessageObserver>, error_handler: Box<dyn ExceptionObserver>) -> Result<Self, String> {
        let port = serialport::new(port_name, baud_rate)
            .data_bits(DataBits::Eight)
            .stop_bits(StopBits::Two)
            .parity(Parity::None)
            .flow_control(flow_control)
            .timeout(Duration::from_millis(update_cycles))
            .open();

        return if port.is_err() {
            Err("Could not open port: ".to_owned() + port_name)
        } else {
            Ok(LocoNetConnector {
                port: port.unwrap(),
                message_observer,
                lack_observer,
                error_handler,
                lack: false,
                last_message: Message::Busy(Busy()),
                send: Arc::new((Mutex::new(vec![0u8; 0]), Condvar::new(), Condvar::new())),
                stop: Mutex::new(false),
                reading_thread: None,
                sending_timeout,
            })
        }
    }

    /// Returns the ports name as a string
    pub fn get_port_name(&self) -> String {
        self.port.name().unwrap_or(String::from("-"))
    }

    /// Start a new thread that reads new loco net message
    pub fn start_reader(&'static mut self) -> bool {
        let s = Arc::new(Mutex::new(self));
        let new_s = Arc::clone(&s);
        let mut save_to = (&*s).lock().unwrap();
        if save_to.reading_thread.is_none() {
            save_to.reading_thread = Some(thread::spawn(move|| {
                let mut save_inner = (&*new_s).lock().unwrap();
                *save_inner.stop.lock().unwrap() = false;
                while !*save_inner.stop.lock().unwrap() {
                    save_inner.read();
                }
            }));
            true
        } else {
            false
        }
    }

    /// Stops the loco net message reader and wait for the stop
    pub fn stop_reader(&mut self) {
        if self.reading_thread.is_some() {
            *self.stop.lock().unwrap() = true;
            mem::replace(&mut self.reading_thread, None).take().unwrap().join().unwrap();
        }
    }

    /// Handels a message after a it was parsed successfully
    pub fn read(&mut self) {
        let parsed = self.parse();
        if let Err(err) = parsed {
            if let MessageParseError::Update(_io) = err {

            } else {
                self.error_handler.on_exception_occurred(err);
                self.lack = false;
            }
        } else {
            let message: Message = parsed.unwrap();

            if self.lack {
                if let Message::LongAck(m) = message {
                    self.lack_observer.on_lack_occurred(m, self.last_message);
                }
            }

            if message.lack_follows() {
                self.lack = true;
                self.last_message = message;
            } else {
                self.lack = false;
            }

            self.message_observer.on_message_occurred(message);
        }
    }

    /// Reads and Parses the next message from `stream`.
    ///
    /// # Errors
    ///
    /// This function returns an error if the message could not be parsed:
    ///
    /// * [`UnknownOpcode`] if the message has an unknown opcode
    /// * [`UnexpectedEnd`] if `stream` unexpectedly yields [`None`]
    /// * [`InvalidChecksum`] if the checksum is invalid
    ///
    /// [`UnknownOpcode`]: MessageParseError::UnknownOpcode
    /// [`UnexpectedEnd`]: MessageParseError::UnexpectedEnd
    /// [`InvalidChecksum`]: MessageParseError::InvalidChecksum
    pub fn parse(&mut self) -> Result<Message, MessageParseError> {
        let mut buf = vec![0u8; 1];
        if let Err(error) = self.port.read_exact(&mut buf) {
            return Err(MessageParseError::Update(error));
        }

        let opc = buf[0];

        let len = match opc & 0xE0 {
            0x80 => 2,
            0xA0 => 4,
            0xC0 => 6,
            0xE0 => {
                let mut byte1 = [0u8; 1];
                if let Err(error) = self.port.read_exact(&mut byte1) {
                    return Err(MessageParseError::IoError(error));
                }
                buf.push(byte1[0]);
                byte1[0] as usize - 1
            }
            _ => return Err(MessageParseError::UnknownOpcode(opc)),
        };

        let mut message = vec![0u8; len - 1];

        if let Err(error) = self.port.read_exact(&mut message) {
            return Err(MessageParseError::IoError(error));
        }

        buf.append(&mut message);

        // validate checksum
        if !Self::validate(&buf) {
            return Err(MessageParseError::InvalidChecksum);
        }

        // Check for receiving last send message
        let (lock, cvar, waiter) = &*self.send;
        let mut last_send = lock.lock().unwrap();

        if !(*last_send).is_empty() && (*last_send) == buf {
            *last_send = vec![0u8; 0];
            waiter.notify_all();
            cvar.notify_one();
        }

        // call appropriate parse function
        match len {
            2 => Self::parse2(opc),
            4 => Self::parse4(opc, &buf[1..3]),
            6 => Self::parse6(opc, &buf[1..5]),
            var => Self::parse_var(opc, &buf[1..var]),
        }
    }

    fn parse2(opc: u8) -> Result<Message, MessageParseError> {
        match opc {
            0x85 => Ok(Message::Idle(Idle())),
            0x83 => Ok(Message::GpOn(GpOn())),
            0x82 => Ok(Message::GpOff(GpOff())),
            0x81 => Ok(Message::Busy(Busy())),
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    fn parse4(opc: u8, args: &[u8]) -> Result<Message, MessageParseError> {
        if args.len() != 2 {
            return Err(MessageParseError::UnexpectedEnd);
        }
        match opc {
            0xBF => Ok(Message::LocoAdr(LocoAdr(AddressArg::parse(args[0], args[1])))),
            0xBD => Ok(Message::SwAck(SwAck(SwitchArg::parse(args[0], args[1])))),
            0xBC => Ok(Message::SwState(SwState(SwitchArg::parse(args[0], args[1])))),
            0xBB => Ok(Message::RqSlData(RqSlData(SlotArg::parse(args[0])))),
            0xBA => Ok(Message::MoveSlots(MoveSlots(
                SlotArg::parse(args[0]),
                SlotArg::parse(args[1]),
            ))),
            0xB9 => Ok(Message::LinkSlots(LinkSlots(
                SlotArg::parse(args[0]),
                SlotArg::parse(args[1]),
            ))),
            0xB8 => Ok(Message::UnlinkSlots(UnlinkSlots(
                SlotArg::parse(args[0]),
                SlotArg::parse(args[1]),
            ))),
            0xB6 => Ok(Message::ConsistFunc(ConsistFunc(
                SlotArg::parse(args[0]),
                DirfArg::parse(args[1]),
            ))),
            0xB5 => Ok(Message::SlotStat1(SlotStat1(
                SlotArg::parse(args[0]),
                Stat1Arg::parse(args[1]),
            ))),
            0xB4 => Ok(Message::LongAck(LongAck(
                LopcArg::parse(args[0]),
                Ack1Arg::parse(args[1]),
            ))),
            0xB2 => Ok(Message::InputRep(InputRep(InArg::parse(args[0], args[1])))),
            0xB1 => Ok(Message::SwRep(SwRep(SnArg::parse(args[0], args[1])))),
            0xB0 => Ok(Message::SwReq(SwReq(SwitchArg::parse(args[0], args[1])))),
            0xA2 => Ok(Message::LocoSnd(LocoSnd(
                SlotArg::parse(args[0]),
                SndArg::parse(args[1]),
            ))),
            0xA1 => Ok(Message::LocoDirf(LocoDirf(
                SlotArg::parse(args[0]),
                DirfArg::parse(args[1]),
            ))),
            0xA0 => Ok(Message::LocoSpd(LocoSpd(
                SlotArg::parse(args[0]),
                SpeedArg::parse(args[1]),
            ))),
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    fn parse6(opc: u8, args: &[u8]) -> Result<Message, MessageParseError> {
        if args.len() != 4 {
            return Err(MessageParseError::UnexpectedEnd);
        }
        match opc {
            0xD0 => Ok(Message::MultiSense(MultiSense(
                MultiSenseArg::parse(args[0], args[1]),
                AddressArg::parse(args[2], args[3]),
            ))),
            0xD4 => {
                assert_eq!(0x20, args[0], "Value of arg0 can only be {:?}", 0x20);
                Ok(Message::UhliFun(UhliFun(
                    SlotArg::parse(args[1]),
                    FunctionArg::parse(args[2], args[3]),
                )))
            }
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    fn parse_var(opc: u8, args: &[u8]) -> Result<Message, MessageParseError> {
        if (args.len() + 2) as u8 != args[0] {
            return Err(MessageParseError::UnexpectedEnd);
        }
        match opc {
            0xE7 => Ok(Message::SlRdData(SlRdData(
                SlotArg::parse(args[1]),
                Stat1Arg::parse(args[2]),
                AddressArg::parse(args[8], args[3]),
                SpeedArg::parse(args[4]),
                DirfArg::parse(args[5]),
                TrkArg::parse(args[6]),
                Stat2Arg::parse(args[7]),
                SndArg::parse(args[9]),
                IdArg::parse(args[10], args[11]),
            ))),
            0xED => Ok(Message::ImmPacket(ImmPacket(
                ImArg::parse(args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])
            ))),
            0xEF => Ok(Message::WrSlData(WrSlData(
                WrSlDataStructure::parse(args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11])
            ))),
            0xE4 => Ok(Message::Rep(Rep(RepStructure::parse(args[0], &args[1..])))),
            0xE5 => Ok(Message::PeerXfer(PeerXfer(SlotArg::parse(args[1]), DstArg::parse(args[2], args[3]), PxctData::parse(args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13])))),
            _ => Err(MessageParseError::UnknownOpcode(opc)),
        }
    }

    /// Validates a messages checksum
    fn validate(msg: &[u8]) -> bool {
        return msg.iter().fold(0, |acc, &b| acc ^ b) == 0xFF;
    }

    /// Writes a set of bytes to the loco net by appending the checksum and sending it to the connection
    pub fn write(&mut self, message: Vec<u8>) -> bool {
        if self.reading_thread.is_none() {
            self.error_handler.on_exception_occurred(
                MessageParseError::IoError(
                    std::io::Error::new(
                        std::io::ErrorKind::TimedOut, "Reader not started! Please start the reader before sending messages."
                    )));
            return false;
        }

        let bytes = Self::to_message(message);

        let (lock, cvar, waiter) = &*self.send;

        if !(*lock.lock().unwrap()).is_empty() {
            let result = cvar.wait_timeout_while(lock.lock().unwrap(), Duration::from_millis(self.sending_timeout), |pending| !(*pending).is_empty()).unwrap();

            if result.1.timed_out() {
                self.error_handler.on_exception_occurred(
                    MessageParseError::IoError(
                        std::io::Error::new(
                            std::io::ErrorKind::TimedOut, "Connection timed out! Please check your connected device."
                        )));
                return false;
            }
        }

        let mut send = lock.lock().unwrap();

        *send = bytes;

        match self.port.write_all(&*send) {
            Ok(_) => {
                drop(send);
                if !(*lock.lock().unwrap()).is_empty() {
                    let result = waiter.wait_timeout_while(lock.lock().unwrap(), Duration::from_millis(self.sending_timeout), |pending| !(*pending).is_empty()).unwrap();
                    if result.1.timed_out() {
                        self.error_handler.on_exception_occurred(
                            MessageParseError::IoError(
                                std::io::Error::new(
                                    std::io::ErrorKind::TimedOut, "Connection timed out! Please check your connected device."
                                )));
                        return false;
                    }
                }
                true
            },
            Err(_) => false,
        }
    }

    /// Appends the checksum at the end of the message
    pub fn to_message(mut bytes: Vec<u8>) -> Vec<u8> {
        bytes.push(Self::check_sum(&bytes));

        bytes
    }

    /// Calculates the checksum for an array of bytes
    fn check_sum(msg: &[u8]) -> u8 {
        0xFF - msg.iter().fold(0, |acc, &b| acc ^ b)
    }
}

foreign_enum!(
    /// How to control the data flow to the loco net
    enum FlowControl {
        /// Software based flow control (standard for Uhlenbrock loco net systems)
    SOFTWARE = FlowControl::Software,
        /// Hardware based flow control with cts / rts
    HARDWARE = FlowControl::Hardware,
        /// No flow control
    NONE = FlowControl::None,
});

foreign_class!(
    /// This class represents a connection to the loco net.
    class LocoNetConnector {
    self_type LocoNetConnector;
        /// Creates a new port to the loco net.
        /// @param portName The connections port name. (You can list all ports by calling PortInfos.getAllPorts())
        /// @param baudRate The baud rate of the connection
        /// @param sendingTimeout The time the loco net waits for the loco net to respond to a message, before failing
        /// @param updateCycles How often the loco net leaves the freeze state to check whether to close the connection, before waiting for new messages
        /// @param flowControl The flow control to use
        /// @param messageObserver The observer to call when a new message was received from the loco net
        /// @param lackObserver The observer to call when an answer message to a before message received
        /// @param errorHandler The method to call when an error occurred while reading or writing to the connection
        /// @throws Exception when the loco net connection port can not be accessed.
    constructor LocoNetConnector::new(portName: &str, baudRate: u32, sendingTimeout: u64, updateCycles: u64, flowControl: FlowControl, messageObserver: Box<dyn LocoNetMessageObserver>, lackObserver: Box<dyn LackMessageObserver>, errorHandler: Box<dyn ExceptionObserver>) -> Result<LocoNetConnector, String>;
    foreign_code r#"
    /**
     * Creates a new port to the loco net.<br>
     * Sets the updateCycles to 5000, and the flow control to software.
     * @param portName The connections port name. (You can list all ports by calling PortInfos.getAllPorts())
     * @param baudRate The baud rate of the connection
     * @param sendingTimeout The time the loco net waits for the loco net to respond to a message, before failing
     * @param messageObserver The observer to call when a new message was received from the loco net
     * @param lackObserver The observer to call when an answer message to a before message received
     * @param errorHandler The method to call when an error occurred while reading or writing to the connection
     * @throws Exception when the loco net connection port can not be accessed.
     */
    public LocoNetConnector(String portName, long baudRate, long sendingTimeout, LocoNetMessageObserver messageObserver, LackMessageObserver lackObserver, ExceptionObserver errorHandler) throws Exception {
        this(portName, baudRate, sendingTimeout, 5000, FlowControl.SOFTWARE, messageObserver, lackObserver, errorHandler);
    }

    /**
     * Creates a new port to the loco net.<br>
     * Sets the baud rate to 115_200, the sending timeout to 500, the updateCycles to 5000, and the flow control to software.
     * @param portName The connections port name. (You can list all ports by calling PortInfos.getAllPorts())
     * @param messageObserver The observer to call when a new message was received from the loco net
     * @param lackObserver The observer to call when an answer message to a before message received
     * @param errorHandler The method to call when an error occurred while reading or writing to the connection
     * @throws Exception when the loco net connection port can not be accessed.
     */
    public LocoNetConnector(String portName, LocoNetMessageObserver messageObserver, LackMessageObserver lackObserver, ExceptionObserver errorHandler) throws Exception {
        this(portName, 115_200, 500, 5000, FlowControl.SOFTWARE, messageObserver, lackObserver, errorHandler);
    }
"#;
    /// Starts the reader to the loco net connection.
    /// It creates a new rust threads, which reads incoming bytes from the loco net and sends the received messages to the set observers.
    /// @return true, if the thread is started successfully, false otherwise. (Only one thread can be started at any time, this method returns false if a running thread exists)
    fn LocoNetConnector::start_reader(&mut self) -> bool; alias startReader;
    /// Stops the loco net reading thread if one is started and waits until the thread is stopped completely by using rusts thread join.
    fn LocoNetConnector::stop_reader(&mut self); alias stopReader;
    /// @return The ports name
    fn LocoNetConnector::get_port_name(&self) -> String; alias getPortName;
});
